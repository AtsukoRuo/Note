# 实战

[TOC]

## ID生成器代码

> 持续重构、单元测试、代码的可测试性、解耦、编码规范的应用

### 需求分析

为每个请求添加ID。在打印日记时，可以指定请求的ID，获取其所有的记录。

### 一份能用的代码实现

~~~java
public class IdGenerator {
  private static final Logger logger = LoggerFactory.getLogger(IdGenerator.class);

  public static String generate() {
    String id = "";
    try {
      String hostName = InetAddress.getLocalHost().getHostName();
      String[] tokens = hostName.split("\\.");
      if (tokens.length > 0) {
        hostName = tokens[tokens.length - 1];
      }
        
      char[] randomChars = new char[8];
      int count = 0;
      Random random = new Random();
      while (count < 8) {
        int randomAscii = random.nextInt(122);
        if (randomAscii >= 48 && randomAscii <= 57) {
          randomChars[count] = (char)('0' + (randomAscii - 48));
          count++;
        } else if (randomAscii >= 65 && randomAscii <= 90) {
          randomChars[count] = (char)('A' + (randomAscii - 65));
          count++;
        } else if (randomAscii >= 97 && randomAscii <= 122) {
          randomChars[count] = (char)('a' + (randomAscii - 97));
          count++;
        }
      }
      id = String.format("%s-%d-%s", hostName,
              System.currentTimeMillis(), new String(randomChars));
    } catch (UnknownHostException e) {
      logger.warn("Failed to get the host name.", e);
    }
    return id;
  }
}

/** 
本机名的最后一个字段-精确到毫秒的时间戳-8位的随机字符串
103-1577456311467-3nR3Do45
103-1577456311468-0wnuV5yw
103-1577456311468-sdrnkFxN
103-1577456311468-8lwk0BP0
*/
~~~

这份代码只能算得上“能用”，勉强及格。因为

- 调用者直接依赖实现而非接口，如果只有一种ID生成算法，那就无所谓。但是同时存在多种ID生成算法，就违背了「基于接口而非实现编程」的设计原则。
- 把IdGenerator的generate()函数定义为静态函数，会影响使用该函数的代码的可测试性（无法重载）。
- 代码完全没有注释，生成算法比较难读懂，而且还滥用magic number。因此可读性差



### 重构

接下来我们就要进行重构了。注意一定要分阶段、循序渐进地进行重构。

*   第一轮重构：提高代码的可读性
*   第二轮重构：提高代码的可测试性
*   第三轮重构：编写完善的单元测试
*   第四轮重构：所有重构完成之后添加注释



#### 第一轮重构：提高代码的可读性

对IdGenerator类重命名，并且抽象出对应的接口。下面有三种类的命名方式：

![](assets/8f0de72351eeb9138c7a3b8199767a6b.jpg)

第一种方式是不合理的，因为实现类的命名太过通用了，那之后新的实现类就不好取名了。

第二种方式也是不合理的，因为HostNameMillisIdGenerator的命名暴露了太多实现细节，只要代码稍微有所改动，就会可能需要改动命名，来匹配实现。

综上，第三种方式是合理的，为此我们抽象出两个接口，一个是IdGenerator，一个是LogTraceIdGenerator，LogTraceIdGenerator继承IdGenerator。实现类实现接口LogTraceIdGenerator，命名为RandomIdGenerator、SequenceIdGenerator等。重构之后的代码如下所示：

~~~java
public interface IdGenerator {
  String generate();
}

public interface LogTraceIdGenerator extends IdGenerator {}

public class RandomIdGenerator implements LogTraceIdGenerator {
  private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);

  @Override
  public String generate() {
    String substrOfHostName = getLastfieldOfHostName();
    long currentTimeMillis = System.currentTimeMillis();
    String randomString = generateRandomAlphameric(8);
    String id = String.format("%s-%d-%s",
            substrOfHostName, currentTimeMillis, randomString);
    return id;
  }

  private String getLastfieldOfHostName() {
    String substrOfHostName = null;
    try {
      String hostName = InetAddress.getLocalHost().getHostName();
      substrOfHostName = getLastSubstrSplittedByDot(hostName);
    } catch (UnknownHostException e) {
      logger.warn("Failed to get the host name.", e);
    }
    return substrOfHostName;
  }

  private String getLastSubstrSplittedByDot(String hostName) {
    String[] tokens = hostName.split("\\.");
    String substrOfHostName = tokens[tokens.length - 1];
    return substrOfHostName;
  }
    
  private String generateRandomAlphameric(int length) {
    char[] randomChars = new char[length];
    int count = 0;
    Random random = new Random();
    while (count < length) {
      int maxAscii = 'z';
      int randomAscii = random.nextInt(maxAscii);
      boolean isDigit= randomAscii >= '0' && randomAscii <= '9';
      boolean isUppercase= randomAscii >= 'A' && randomAscii <= 'Z';
      boolean isLowercase= randomAscii >= 'a' && randomAscii <= 'z';
      if (isDigit|| isUppercase || isLowercase) {
        randomChars[count] = (char) (randomAscii);
        ++count;
      }
    }
    return new String(randomChars);
  }
}

//代码使用举例
LogTraceIdGenerator logTraceIdGenerator = new RandomIdGenerator();
~~~



#### 第二轮重构：提高代码的可测试性

关于代码可测试性的问题，主要包含下面两个方面：

*   generate()函数定义为静态函数，会影响使用该函数的代码的可测试性；
*   generate()函数的代码实现依赖运行环境（本机名）、时间函数、随机函数

对于第一点，我们已经在第一轮重构中解决了，即将RandomIdGenerator类中的generate()静态函数，重新定义成了普通函数。对于第二点，我们通过重载的方式进行重构：

~~~java
public class RandomIdGenerator implements LogTraceIdGenerator {
  private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);

  @Override
  public String generate() {
    String substrOfHostName = getLastfieldOfHostName();
    long currentTimeMillis = System.currentTimeMillis();
    String randomString = generateRandomAlphameric(8);
    String id = String.format("%s-%d-%s",
            substrOfHostName, currentTimeMillis, randomString);
    return id;
  }

  private String getLastfieldOfHostName() {
    String substrOfHostName = null;
    try {
      String hostName = InetAddress.getLocalHost().getHostName();
      substrOfHostName = getLastSubstrSplittedByDot(hostName);
    } catch (UnknownHostException e) {
      logger.warn("Failed to get the host name.", e);
    }
    return substrOfHostName;
  }

  @VisibleForTesting
  protected String getLastSubstrSplittedByDot(String hostName) {
    String[] tokens = hostName.split("\\.");
    String substrOfHostName = tokens[tokens.length - 1];
    return substrOfHostName;
  }

  @VisibleForTesting
  protected String generateRandomAlphameric(int length) {
    char[] randomChars = new char[length];
    int count = 0;
    Random random = new Random();
    while (count < length) {
      int maxAscii = 'z';
      int randomAscii = random.nextInt(maxAscii);
      boolean isDigit= randomAscii >= '0' && randomAscii <= '9';
      boolean isUppercase= randomAscii >= 'A' && randomAscii <= 'Z';
      boolean isLowercase= randomAscii >= 'a' && randomAscii <= 'z';
      if (isDigit|| isUppercase || isLowercase) {
        randomChars[count] = (char) (randomAscii);
        ++count;
      }
    }
    return new String(randomChars);
  }
}
~~~

#### 第三轮重构：编写完善的单元测试

现在，我们来补全代码的单元测试。RandomIdGenerator类中有4个函数

~~~java
public String generate();

private String getLastfieldOfHostName();

@VisibleForTesting
protected String getLastSubstrSplittedByDot(String hostName);

@VisibleForTesting
protected String generateRandomAlphameric(int length);
~~~

后两个函数包含的逻辑比较复杂，是我们测试的重点：

~~~java
public class RandomIdGeneratorTest {
  @Test
  public void testGetLastSubstrSplittedByDot() {
    RandomIdGenerator idGenerator = new RandomIdGenerator();
    String actualSubstr = idGenerator.getLastSubstrSplittedByDot("field1.field2.field3");
    Assert.assertEquals("field3", actualSubstr);

    actualSubstr = idGenerator.getLastSubstrSplittedByDot("field1");
    Assert.assertEquals("field1", actualSubstr);

    actualSubstr = idGenerator.getLastSubstrSplittedByDot("field1#field2$field3");
    Assert.assertEquals("field1#field2#field3", actualSubstr);
  }

  // 此单元测试会失败，因为我们在代码中没有处理hostName为null或空字符串的情况
  // 这部分优化留在第36、37节课中讲解
  @Test
  public void testGetLastSubstrSplittedByDot_nullOrEmpty() {
    RandomIdGenerator idGenerator = new RandomIdGenerator();
    String actualSubstr = idGenerator.getLastSubstrSplittedByDot(null);
    Assert.assertNull(actualSubstr);

    actualSubstr = idGenerator.getLastSubstrSplittedByDot("");
    Assert.assertEquals("", actualSubstr);
  }

  @Test
  public void testGenerateRandomAlphameric() {
    RandomIdGenerator idGenerator = new RandomIdGenerator();
    String actualRandomString = idGenerator.generateRandomAlphameric(6);
    Assert.assertNotNull(actualRandomString);
    Assert.assertEquals(6, actualRandomString.length());
    for (char c : actualRandomString.toCharArray()) {
      Assert.assertTrue(('0' < c && c < '9') || ('a' < c && c < 'z') || ('A' < c && c < 'Z'));
    }
  }

  // 此单元测试会失败，因为我们在代码中没有处理length<=0的情况
  // 这部分优化留在第36、37节课中讲解
  @Test
  public void testGenerateRandomAlphameric_lengthEqualsOrLessThanZero() {
    RandomIdGenerator idGenerator = new RandomIdGenerator();
    String actualRandomString = idGenerator.generateRandomAlphameric(0);
    Assert.assertEquals("", actualRandomString);

    actualRandomString = idGenerator.generateRandomAlphameric(-1);
    Assert.assertNull(actualRandomString);
  }
}

~~~

#### 第四轮重构：添加注释

这部分内容过于简单，不再介绍

#### 第五轮重构：处理异常

主机名的获取可能失败，我们必须通过异常通知到调用者。

现在的处理方式是当主机名获取失败的时候，getLastFieldOfHostName()函数返回null值，并且将UnknownHostException异常在函数内部吞掉。但是我们观察到UnknownHostException和getLastFieldOfHostName是业务相关的，因此我们可以直接throw掉，而不是吞掉：

~~~java
 private String getLastFieldOfHostName() throws UnknownHostException{
    String substrOfHostName = null;
    String hostName = InetAddress.getLocalHost().getHostName();
    substrOfHostName = getLastSubstrSplittedByDot(hostName);
    return substrOfHostName;
 }
~~~

而generate()需要包装UnknownHostException异常，然后再抛出，因为：

- 调用者在使用generate()函数的时候，只需要知道它生成的是随机唯一ID，并不关心ID是如何生成的。也就说是，这是依赖抽象而非实现编程。如果generate()函数直接抛出UnknownHostException异常，实际上是暴露了实现细节。
- UnknownHostException异常跟generate()函数，在业务概念上没有相关性。

~~~java
  public String generate() throws IdGenerationFailureException {
    String substrOfHostName = null;
    try {
      substrOfHostName = getLastFieldOfHostName();
    } catch (UnknownHostException e) {
      throw new IdGenerationFailureException("host name is empty.");
    }
    long currentTimeMillis = System.currentTimeMillis();
    String randomString = generateRandomAlphameric(8);
    String id = String.format("%s-%d-%s",
            substrOfHostName, currentTimeMillis, randomString);
    return id;
  }
~~~

仿照这个思路，可以重构generateRandomAlphameric()、getLastSubstrSplittedByDot()，让它们正确地进行异常处理。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

至此，我们完成了ID Generator的重构🎉🎉🎉

## 程序出错应该返回啥？

当方法出错时，我们一般会通过返回值（null、错误码、空对象）或者异常，来通知调用者方法执行失败。

对于通过返回值获取错误信息的方式来说，要确保正确结果值的范围和错误值的范围是不重叠的。

总之，除了错误码的处理方式，其他都是可以接受的。如果错误的含义是「不存在」的话，那么推荐返回null或者空对象。其余情况一律抛出异常。

### 返回错误码

在现代语言中（C++、Java、Python）中，不推荐使用这种方式来表示错误。

错误码的返回方式有两种：

- 函数的返回值表示错误码，而通过参数来返回，函数正常执行的结果值。

  ~~~java
  //这里fd表示返回值
  int open(const char *pathname, int flags, mode_t mode, int* fd) {
    if (/*文件不存在*/) {return EEXIST;}
    
    if (/*没有访问权限*/) {return EACCESS;}
    
    if (/*打开文件成功*/) {
      return SUCCESS; //C语言中的宏定义：#define SUCCESS 0
    }
    // ...
  }
  
  //使用举例
  int fd;
  int result = open(“c:\test.txt”, O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO, &fd);
  if (result == SUCCESS) {
    // 取出fd使用
  } else if (result == EEXIST) {
    //...
  } else if (result == EACESS) {
    //...
  }
  ~~~

- 将错误码定义在全局变量中

  ~~~java
  int errno; // 线程安全的全局变量
  int open(const char *pathname, int flags, mode_t mode）{
    if (/*文件不存在*/) {
      errno = EEXIST;
      return -1;
    }
    
    if (/*没有访问权限*/) {
      errno = EACCESS;
      return -1;
    }
    
    // ...
  }
           
  // 使用举例
  int hFile = open(“c:\test.txt”, O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO);
  if (-1 == hFile) {
    printf("Failed to open file, error no: %d.\n", errno);
    if (errno == EEXIST ) {
      // ...        
    } else if(errno == EACCESS) {
      // ...    
    }
    // ...
  }
   
  ~~~

### 返回null

`null`一般表示“不存在”这种语义。但是不推荐使用这种方式来表示出错，因为：

- 如果忘记对函数的返回值做null判断，那么可能抛出**空指针异常**（Null Pointer Exception）
- 代码中就会充斥着大量的NULL值判断逻辑，一方面写起来比较繁琐，另一方面它们跟正常的业务逻辑耦合在一起，会影响代码的可读性。

~~~java
public class UserService {
  private UserRepo userRepo; // 依赖注入
  
  public User getUser(String telephone) {
    // 如果用户不存在，则返回null
    return null;
  }
}

// 使用函数getUser()
User user = userService.getUser("18917718965");
if (user != null) { // 做NULL值判断，否则有可能会报NPE
  String email = user.getEmail();
  if (email != null) { // 做NULL值判断，否则有可能会报NPE
    String escapedEmail = email.replaceAll("@", "#");
  }
}
~~~

### 返回空对象

应对这个问题有一个比较经典的策略，那就是应用空对象设计模式（Null Object Design Pattern）。这个模式留在以后讲解。

当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代NULL值，来表示不存在的情况，这样避免了null判断。

~~~java
// 使用空集合替代NULL
public class UserService {
  private UserRepo userRepo; // 依赖注入
  
  public List<User> getUsers(String telephonePrefix) {
   // 没有查找到数据
    return Collections.emptyList();
  }
}
// getUsers使用示例
List<User> users = userService.getUsers("189");
for (User user : users) { //这里不需要做NULL值判断
  // ...
}
~~~



~~~java
// 使用空字符串替代NULL
public String retrieveUppercaseLetters(String text) {
  // 如果text中没有大写字母，返回空字符串，而非NULL值
  return "";
}
// retrieveUppercaseLetters()使用举例
String uppercaseLetters = retrieveUppercaseLetters("wangzheng");
int length = uppercaseLetters.length();// 不需要做NULL值判断 
System.out.println("Contains " + length + " upper case letters.");
~~~



### 抛出异常对象

Java支持两种异常类型：**运行时异常（Runtime Exception）**和**编译时异常（Compile Exception）**

实际上，Java支持的编译时异常一直被人诟病。有种观点就是认为，所有的异常情况都应该使用运行时异常。支持这种观点的理由主要有：

- 违反开闭原则，如果我们给某个函数新增一个编译时异常，这个函数所在的函数调用链上的所有位于其之上的函数都需要做相应的代码修改，直到调用链中的某个函数将这个新增的异常try-catch处理掉为止。而新增的运行时异常可以不改动调用链上的代码。我们可以灵活地选择在某个函数中集中处理，比如在Spring中的AOP切面中集中处理异常。
- 编译器强制我们处理异常（try-catch、throws），编写出的代码比较繁琐，可读性下降。

注意，运行时异常的灵活性也意味着不可控，这可能造成遗漏一些本应该捕获处理的异常。至于如何选择，我的意见是：

- 对于不可恢复异常，我们要fail-fast，也就是说直接抛出运行时异常，将程序终止掉。
- 对于可恢复异常、业务异常，比如提现金额大于余额的异常，我们更倾向于使用编译时异常



下面是三种常用的处理异常的方法：

- 直接吞掉。

  ~~~java
  public void func1() throws Exception1 {// ...}
  
  public void func2() {
    try {
      func1();
    } catch(Exception1 e) {
      log.warn("...", e); //吐掉：try-catch打印日志
    }
  }
  ~~~

- 原封不动地re-throw

  ~~~java
  public void func1() throws Exception1 {// ...}
  
  
  public void func2() throws Exception1 {//原封不动的re-throw Exception1
    func1();
  }
  ~~~

- 包装成新的异常re-throw。是否需要包装成新的异常抛出，要看该异常的含义和当前函数的功能是否相关。如果相关则直接抛出，否则重新包装后抛出。

  ~~~java
  public void func1() throws Exception1 {// ...}
  
  public void func2() throws Exception2 {
    try {
      func1();
    } catch(Exception1 e) {
     throw new Exception2("...", e); // wrap成新的Exception2然后re-throw
    }
  }
  ~~~



## 性能计数器

在[设计原则](设计原则.md)一节中，我们介绍过性能计数器项目。现在我们对它进行重构。

`Aggregator`类的问题是里面只有一个静态函数`aggregate`，它集成了所有统计功能。这违反了职责单一原则。

`ConsoleReporter`、`EmailReporter`的问题如下：

- `ConsoleReporter`和`EmailReporter`两个类中存在代码重复问题。在这两个类中，从做统计的逻辑、语义都是相同的，这违反了DRY原则。
- 它们都同时负责获取数据、计算、显示数据的工作，职责不够单一。
- 代码中涉及线程操作，并且调用了`Aggregator`的静态函数，所以代码的可测试性也有待提高。



为此，我们重构代码如下：将`Reporter`类中做统计的逻辑抽离到`Aggregator`类中

~~~java
public class Aggregator {
  //对所有api的数据做统计
  public Map<String, RequestStat> aggregate(
          Map<String, List<RequestInfo>> requestInfos, long durationInMillis) {
      
    Map<String, RequestStat> requestStats = new HashMap<>();
    for (Map.Entry<String, List<RequestInfo>> entry : requestInfos.entrySet()) {
      String apiName = entry.getKey();
      List<RequestInfo> requestInfosPerApi = entry.getValue();
      RequestStat requestStat = doAggregate(requestInfosPerApi, durationInMillis);
      requestStats.put(apiName, requestStat);
    }
    return requestStats;
  }

  //对某个api的数据做统计
  private RequestStat doAggregate(List<RequestInfo> requestInfos, long durationInMillis) {
    List<Double> respTimes = new ArrayList<>();
    for (RequestInfo requestInfo : requestInfos) {
      double respTime = requestInfo.getResponseTime();
      respTimes.add(respTime);
    }

    RequestStat requestStat = new RequestStat();
    requestStat.setMaxResponseTime(max(respTimes));
    requestStat.setMinResponseTime(min(respTimes));
    requestStat.setAvgResponseTime(avg(respTimes));
    requestStat.setP999ResponseTime(percentile999(respTimes));
    requestStat.setP99ResponseTime(percentile99(respTimes));
    requestStat.setCount(respTimes.size());
    requestStat.setTps((long) tps(respTimes.size(), durationInMillis/1000));
    return requestStat;
  }

  // 以下的函数的代码实现均省略...
  private double max(List<Double> dataset) {}
  private double min(List<Double> dataset) {}
  private double avg(List<Double> dataset) {}
  private double tps(int count, double duration) {}
  private double percentile999(List<Double> dataset) {}
  private double percentile99(List<Double> dataset) {}
  private double percentile(List<Double> dataset, double ratio) {}
}
~~~

我们把「统计数据显示到终端」这部分逻辑剥离出来，设计成两个类：ConsoleViewer类和EmailViewer类：

~~~java
public interface StatViewer {
  void output(Map<String, RequestStat> requestStats, long startTimeInMillis, long endTimeInMills);
}

public class ConsoleViewer implements StatViewer {
  public void output(
          Map<String, RequestStat> requestStats, long startTimeInMillis, long endTimeInMills) {
    System.out.println("Time Span: [" + startTimeInMillis + ", " + endTimeInMills + "]");
    Gson gson = new Gson();
    System.out.println(gson.toJson(requestStats));
  }
}

public class EmailViewer implements StatViewer {
  private EmailSender emailSender;
  private List<String> toAddresses = new ArrayList<>();

  public EmailViewer() {
    this.emailSender = new EmailSender(/*省略参数*/);
  }

  public EmailViewer(EmailSender emailSender) {
    this.emailSender = emailSender;
  }

  public void addToAddress(String address) {
    toAddresses.add(address);
  }

  public void output(
          Map<String, RequestStat> requestStats, long startTimeInMillis, long endTimeInMills) {
    // format the requestStats to HTML style.
    // send it to email toAddresses.
  }
}
~~~

组装类（ConsoleReporter 、EmailReporter）只负责组装各个类（MetricsStorage、Aggegrator、StatViewer）来完成整个工作流程：

~~~java
public class ConsoleReporter {
  private MetricsStorage metricsStorage;
  private Aggregator aggregator;
  private StatViewer viewer;
  private ScheduledExecutorService executor;

  public ConsoleReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {
    this.metricsStorage = metricsStorage;
    this.aggregator = aggregator;
    this.viewer = viewer;
    this.executor = Executors.newSingleThreadScheduledExecutor();
  }

  public void startRepeatedReport(long periodInSeconds, long durationInSeconds) {
    executor.scheduleAtFixedRate(new Runnable() {
      @Override
      public void run() {
        long durationInMillis = durationInSeconds * 1000;
        long endTimeInMillis = System.currentTimeMillis();
        long startTimeInMillis = endTimeInMillis - durationInMillis;
        Map<String, List<RequestInfo>> requestInfos =
                metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);
        //原本做统计的工作抽离到aggregator.aggregate()
        Map<String, RequestStat> requestStats = aggregator.aggregate(requestInfos, durationInMillis);
        //输出逻辑抽离到viewer
        viewer.output(requestStats, startTimeInMillis, endTimeInMillis);
      }
    }, 0L, periodInSeconds, TimeUnit.SECONDS);
  }

}

public class EmailReporter {
  private static final Long DAY_HOURS_IN_SECONDS = 86400L;

  private MetricsStorage metricsStorage;
  private Aggregator aggregator;
  private StatViewer viewer;

  public EmailReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {
    this.metricsStorage = metricsStorage;
    this.aggregator = aggregator;
    this.viewer = viewer;
  }

  public void startDailyReport() {
    Calendar calendar = Calendar.getInstance();
    calendar.add(Calendar.DATE, 1);
    calendar.set(Calendar.HOUR_OF_DAY, 0);
    calendar.set(Calendar.MINUTE, 0);
    calendar.set(Calendar.SECOND, 0);
    calendar.set(Calendar.MILLISECOND, 0);
    Date firstTime = calendar.getTime();
    Timer timer = new Timer();
    timer.schedule(new TimerTask() {
      @Override
      public void run() {
        long durationInMillis = DAY_HOURS_IN_SECONDS * 1000;
        long endTimeInMillis = System.currentTimeMillis();
        long startTimeInMillis = endTimeInMillis - durationInMillis;
        Map<String, List<RequestInfo>> requestInfos =
                metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);
        Map<String, RequestStat> stats = aggregator.aggregate(requestInfos, durationInMillis);
        viewer.output(stats, startTimeInMillis, endTimeInMillis);
      }
    }, firstTime, DAY_HOURS_IN_SECONDS * 1000);
  }
} 
~~~

经过上面的重构之后，我们现在再来看一下，现在框架该如何来使用。

~~~java
public class PerfCounterTest {
  public static void main(String[] args) {
    MetricsStorage storage = new RedisMetricsStorage();
    Aggregator aggregator = new Aggregator();

    // 定时触发统计并将结果显示到终端
    ConsoleViewer consoleViewer = new ConsoleViewer();
    ConsoleReporter consoleReporter = new ConsoleReporter(storage, aggregator, consoleViewer);
    consoleReporter.startRepeatedReport(60, 60);

    // 定时触发统计并将结果输出到邮件
    EmailViewer emailViewer = new EmailViewer();
    emailViewer.addToAddress("wangzheng@xzg.com");
    EmailReporter emailReporter = new EmailReporter(storage, aggregator, emailViewer);
    emailReporter.startDailyReport();

    // 收集接口访问数据
    MetricsCollector collector = new MetricsCollector(storage);
    collector.recordRequest(new RequestInfo("register", 123, 10234));
    collector.recordRequest(new RequestInfo("register", 223, 11234));
    collector.recordRequest(new RequestInfo("register", 323, 12334));
    collector.recordRequest(new RequestInfo("login", 23, 12434));
    collector.recordRequest(new RequestInfo("login", 1223, 14234));

    try {
      Thread.sleep(100000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
}

~~~



MetricsStorage、Aggregator、StatViewer三个类的设计也符合迪米特法则。它们只与跟自己有直接相关的数据进行交互。

![](assets/1303d16f75c7266cef9105f540c54834.jpg)



经过上一次重构优化后，代码结构更加清晰。但是在细节方面还是存在一些问题，比如ConsoleReporter、EmailReporter类仍然存在代码重复、可测试性差的问题。



我们可以将ConsoleReporter和EmailReporter中的相同代码逻辑，提取到父类ScheduledReporter中，以解决代码重复问题。这样做的前提是ConsoleReporter和EmailReporter是符合继承语义的，否则应该提取到一个静态类中的。

~~~java
public abstract class ScheduledReporter {
  protected MetricsStorage metricsStorage;
  protected Aggregator aggregator;
  protected StatViewer viewer;

  public ScheduledReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {
    this.metricsStorage = metricsStorage;
    this.aggregator = aggregator;
    this.viewer = viewer;
  }

  protected void doStatAndReport(long startTimeInMillis, long endTimeInMillis) {
    long durationInMillis = endTimeInMillis -  startTimeInMillis;
    Map<String, List<RequestInfo>> requestInfos =
            metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);
    Map<String, RequestStat> requestStats = aggregator.aggregate(requestInfos, durationInMillis);
    viewer.output(requestStats, startTimeInMillis, endTimeInMillis);
  }

}
~~~

将重复代码提取到父类ScheduledReporter之后，EmailReporter代码如下所示：

~~~java
public class EmailReporter extends ScheduledReporter {
  private static final Long DAY_HOURS_IN_SECONDS = 86400L;

  private MetricsStorage metricsStorage;
  private Aggregator aggregator;
  private StatViewer viewer;

  public EmailReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {
    this.metricsStorage = metricsStorage;
    this.aggregator = aggregator;
    this.viewer = viewer;
  }

  public void startDailyReport() {
    Calendar calendar = Calendar.getInstance();
    calendar.add(Calendar.DATE, 1);
    calendar.set(Calendar.HOUR_OF_DAY, 0);
    calendar.set(Calendar.MINUTE, 0);
    calendar.set(Calendar.SECOND, 0);
    calendar.set(Calendar.MILLISECOND, 0);
    Date firstTime = calendar.getTime();

    Timer timer = new Timer();
    timer.schedule(new TimerTask() {
      @Override
      public void run() {
        long durationInMillis = DAY_HOURS_IN_SECONDS * 1000;
        long endTimeInMillis = System.currentTimeMillis();
        long startTimeInMillis = endTimeInMillis - durationInMillis;
        doStatAndReport(startTimeInMillis, endTimeInMillis);
      }
    }, firstTime, DAY_HOURS_IN_SECONDS * 1000);
  }
}
~~~

EmailReporter可测试性不好，一方面是因为用到了线程，另一方面是因为涉及时间的计算逻辑。此时startDailyReport()中比较复杂的部分就是计算firstTime的那部分代码。我们将这部分代码继续抽离出来，封装成一个函数，然后，单独针对这个函数写单元测试。重构之后的代码如下所示：

~~~java
public class EmailReporter extends ScheduledReporter {
  // 省略其他代码...
  public void startDailyReport() {
    Date firstTime = trimTimeFieldsToZeroOfNextDay();
    Timer timer = new Timer();
    timer.schedule(new TimerTask() {
      @Override
      public void run() {
        // 省略其他代码...
      }
    }, firstTime, DAY_HOURS_IN_SECONDS * 1000);
  }

  // 设置成protected而非private是为了方便写单元测试
  @VisibleForTesting
  protected Date trimTimeFieldsToZeroOfNextDay() {
    Calendar calendar = Calendar.getInstance(); // 这里可以获取当前时间
    calendar.add(Calendar.DATE, 1);
    calendar.set(Calendar.HOUR_OF_DAY, 0);
    calendar.set(Calendar.MINUTE, 0);
    calendar.set(Calendar.SECOND, 0);
    calendar.set(Calendar.MILLISECOND, 0);
    return calendar.getTime();
  }
}
~~~

这个trimTimeFieldsToZeroOfNextDay()的可测试性仍然不好，因为它强依赖当前的系统时间。一般的解决方法是，将强依赖的部分通过参数传递进来，类似于依赖注入。按照这个思路，我们再对trimTimeFieldsToZeroOfNextDay()函数进行重构：

~~~java
public class EmailReporter extends ScheduledReporter {
  // 省略其他代码...
  public void startDailyReport() {
    // new Date()可以获取当前时间
    Date firstTime = trimTimeFieldsToZeroOfNextDay(new Date());
    Timer timer = new Timer();
    timer.schedule(new TimerTask() {
      @Override
      public void run() {
        // 省略其他代码...
      }
    }, firstTime, DAY_HOURS_IN_SECONDS * 1000);
  }

  protected Date trimTimeFieldsToZeroOfNextDay(Date date) {
    Calendar calendar = Calendar.getInstance(); // 这里可以获取当前时间
    calendar.setTime(date); // 重新设置时间
    calendar.add(Calendar.DATE, 1);
    calendar.set(Calendar.HOUR_OF_DAY, 0);
    calendar.set(Calendar.MINUTE, 0);
    calendar.set(Calendar.SECOND, 0);
    calendar.set(Calendar.MILLISECOND, 0);
    return calendar.getTime();
  }
}
~~~

不过，EmailReporter类中startDailyReport()还是涉及多线程。至此，我们无需继续编写单元测试了。为什么这么说呢？我们要回到写单元测试的初衷——提高代码质量，减少bug。如果代码足够简单，简单到bug无处隐藏，那我们就没必要为了写单元测试而写单元测试了！



我们继续完善框架的非功能性需求。首先来看看易用性：

~~~java
MetricsStorage storage = new RedisMetricsStorage();
Aggregator aggregator = new Aggregator();

// 定时触发统计并将结果显示到终端
ConsoleViewer consoleViewer = new ConsoleViewer();
ConsoleReporter consoleReporter = new ConsoleReporter(storage, aggregator, consoleViewer);
consoleReporter.startRepeatedReport(60, 60);

// 定时触发统计并将结果输出到邮件
EmailViewer emailViewer = new EmailViewer();
emailViewer.addToAddress("wangzheng@xzg.com");
EmailReporter emailReporter = new EmailReporter(storage, aggregator, emailViewer);
emailReporter.startDailyReport();
~~~

我们可以看出，框架用起来还是稍微有些复杂的，需要组装各种类。除此之外，还有可能存在误用的情况，比如把EmailViewer传递进了ConsoleReporter中。总体上来讲，框架的使用方式暴露了太多细节给用户，过于灵活也带来了易用性的降低。

我们可以提供额外的构造函数，让用户在灵活性与易用性之间自主做出选择：

~~~java
public class MetricsCollector {
  private MetricsStorage metricsStorage;

  // 兼顾代码的易用性，新增一个封装了默认依赖的构造函数
  public MetricsCollectorB() {
    this(new RedisMetricsStorage());
  }

  // 兼顾灵活性和代码的可测试性，这个构造函数继续保留
  public MetricsCollectorB(MetricsStorage metricsStorage) {
    this.metricsStorage = metricsStorage;
  }
  // 省略其他代码...
}

public class ConsoleReporter extends ScheduledReporter {
  private ScheduledExecutorService executor;
  
  // 兼顾代码的易用性，新增一个封装了默认依赖的构造函数
  public ConsoleReporter() {
    this(new RedisMetricsStorage(), new Aggregator(), new ConsoleViewer());
  }

  // 兼顾灵活性和代码的可测试性，这个构造函数继续保留
  public ConsoleReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {
    super(metricsStorage, aggregator, viewer);
    this.executor = Executors.newSingleThreadScheduledExecutor();
  }
  // 省略其他代码...
}

public class EmailReporter extends ScheduledReporter {
  private static final Long DAY_HOURS_IN_SECONDS = 86400L;

  // 兼顾代码的易用性，新增一个封装了默认依赖的构造函数
  public EmailReporter(List<String> emailToAddresses) {
    this(new RedisMetricsStorage(), new Aggregator(), new EmailViewer(emailToAddresses));
  }
  
  // 兼顾灵活性和代码的可测试性，这个构造函数继续保留
  public EmailReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {
    super(metricsStorage, aggregator, viewer);
  }
  // 省略其他代码...
}
~~~

现在，我们再来看下框架如何来使用：

~~~java
ConsoleReporter consoleReporter = new ConsoleReporter();
consoleReporter.startRepeatedReport(60, 60);

List<String> emailToAddresses = new ArrayList<>();
emailToAddresses.add("wangzheng@xzg.com");
EmailReporter emailReporter = new EmailReporter(emailToAddresses);
emailReporter.startDailyReport();
~~~

是不是简单多了。然而这还是有点小缺陷的，RedisMeticsStorage和EmailViewer还需要另外一些配置信息才能构建成功（例如Redis的地址，Email邮箱的POP3地址）。

我们可以将这些配置信息放到配置文件中，在框架启动的时候，读取配置文件中的配置信息到一个Configuration单例类。RedisMetricsStorage类和EmailViewer类都可以从这个Configuration类中获取需要的配置信息来构建自己。（有点Spring框架的味道了😏）



同时对于需要集成到业务系统的框架来说，我们不希望框架本身代码的执行效率，对业务系统有太多性能上的影响。对于高性能计数器这个框架来说，一方面，希望它是低延迟的（尽量降低对接口响应时间的影响）；另一方面，希望它对内存的负担影响小。这些更多涉及到算法，而不是设计模式。所以就简单介绍一些低延迟的部分。

我们现在使用的存储是基于外部的（比如`Redis`），会比较慢。针对这个问题，我们通过在`MetricsCollector`中引入`Google Guava EventBus`异步存储来解决，即先将采集的数据放入内存共享队列中，另一个线程读取共享队列中的数据，写入到外部存储（比如Redis）中：

~~~java
public class MetricsCollector {
  private static final int DEFAULT_STORAGE_THREAD_POOL_SIZE = 20;

  private MetricsStorage metricsStorage;
  private EventBus eventBus;

  public MetricsCollector(MetricsStorage metricsStorage) {
    this(metricsStorage, DEFAULT_STORAGE_THREAD_POOL_SIZE);
  }

  public MetricsCollector(MetricsStorage metricsStorage, int threadNumToSaveData) {
    this.metricsStorage = metricsStorage;
    this.eventBus = new AsyncEventBus(Executors.newFixedThreadPool(threadNumToSaveData));
    this.eventBus.register(new EventListener());
  }

  public void recordRequest(RequestInfo requestInfo) {
    if (requestInfo == null || StringUtils.isBlank(requestInfo.getApiName())) {
      return;
    }
    eventBus.post(requestInfo);
  }
}


public class EventListener {
    @Subscribe
    public void saveRequestInfo(RequestInfo requestInfo) {
      metricsStorage.saveRequestInfo(requestInfo);
    }
  }
}
~~~

