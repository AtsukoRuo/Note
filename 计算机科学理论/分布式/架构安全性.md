# 架构安全性

[TOC]



## 概述

- [**认证**](https://icyfenix.cn/architect-perspective/general-architecture/system-security/authentication)（Authentication）：如何正确确定出用户的真实身份？
- [**授权**](https://icyfenix.cn/architect-perspective/general-architecture/system-security/authorization)（ Authorization）：如何控制一个用户该看到哪些数据、能操作哪些功能？
- [**凭证**](https://icyfenix.cn/architect-perspective/general-architecture/system-security/credentials)（Credential）：如何保证系统与用户之间的承诺是双方当时真实意图的体现，是准确、完整的
- [**保密**](https://icyfenix.cn/architect-perspective/general-architecture/system-security/confidentiality)（Confidentiality）：如何保证敏感数据无法被包括系统内外部人员所窃取、滥用？
- [**传输**](https://icyfenix.cn/architect-perspective/general-architecture/system-security/transport-security)（Transport Security）：如何保证通过网络传输的信息无法被第三方窃听、篡改和冒充？
- [**验证**](https://icyfenix.cn/architect-perspective/general-architecture/system-security/verification)（Verification）：如何确保提交到每项服务中的数据是合乎规则的，不会对系统稳定性、数据一致性、正确性产生风险？

此外，还有其他一些安全功能主要是由管理、运维、审计领域，譬如，安全审计、系统备份与恢复、信息系统安全法规与制度、计算机防病毒制度、保护私有信息规则，等等

安全的三个基本问题：**“你是谁？”（认证）、“你能干什么？”（授权）以及“你如何证明？”（凭证）**

## 认证

在 J2EE 1.2 发布的 Servlet 2.2 中，添加了一系列用于认证的 API。它还提供了四种内置的、不可扩展的认证方案，即 Client-Cert、Basic、Digest 和 Form。这些方案刚好分别覆盖了通信信道、协议和内容层面的认证。其中，**认证方案（Authentication Schemes）**是指用于生成用户身份凭证的某种方法。



IETF 在 RFC 7235 中，要求所有支持 HTTP 协议的服务器，在未授权的用户意图访问服务端保护区域的资源时，应返回 401 Unauthorized 的状态码，同时应在响应报文头里附带以下 Header 之一，告知客户端应该采取何种方式产生能代表访问者身份的凭证信息

~~~http
WWW-Authenticate: <认证方案> realm=<保护区域的描述信息>
Proxy-Authenticate: <认证方案> realm=<保护区域的描述信息>
~~~

接收到该响应后，客户端必须遵循服务端指定的认证方案，在请求资源的报文头中加入身份凭证信息，由服务端核实通过后才会允许该请求正常返回，否则将返回 403 Forbidden 错误

~~~http
Authorization: <认证方案> <凭证内容>
Proxy-Authorization: <认证方案> <凭证内容>
~~~

HTTP 这种做法将「要产生身份凭证」目的与「具体如何产生凭证」实现分离开来

![image-20240329132151940](./assets/image-20240329132151940.png)



我们以 HTTP Basic 为例，Basic 认证让用户输入用户名和密码，然后经过 Base64 编码加密后作为身份凭证。

1. 服务器响应

   ~~~http
   HTTP/1.1 401 Unauthorized
   Date: Mon, 24 Feb 2020 16:50:53 GMT
   WWW-Authenticate: Basic realm="example from icyfenix.cn"
   ~~~

2. 浏览器询问用户

   ![Basic-Authentication](./assets/Basic-Authentication.9ab6d1ac.png)

3. 客户端请求

   ~~~http
   GET /admin HTTP/1.1
   Authorization: Basic aWN5ZmVuaXg6MTIzNDU2
   ~~~

   

WebAuthn 彻底抛弃了传统的密码登录方式，改为直接采用生物识别（指纹、人脸、虹膜、声纹）或者实体密钥（以 USB、蓝牙、NFC 连接的物理密钥容器）来作为身份凭证。

![img](./assets/webauthen.6420c14f.png)

WebAuthn 规范涵盖了“注册”与“认证”两大流程，先来介绍注册流程，它大致可以分为以下步骤：

1. 用户进入系统的注册页面。注册的内容、页面格式均都不在 WebAuthn 标准内
2. 点击「提交注册信息」的按钮后，服务端先暂存用户提交的数据，生成一个随机字符串（Challenge）和用户的 UserID（凭证 ID），返回给客户端
3. 客户端的 WebAuthn API 接收到 Challenge 和 UserID，把这些信息发送给验证器（Authenticator）
4. 验证器提示用户进行验证。验证的结果是生成一个密钥对（公钥和私钥），由验证器存储私钥、用户信息以及当前的域名。然后使用私钥对 Challenge 进行签名。并将签名结果、UserID 和公钥一起返回客户端
5. 客户端将验证器返回的结果转发给服务器
6. 服务器核验信息，检查 UserID 与之前发送的是否一致，并用公钥解密后得到的结果与之前发送的 Challenge 相比较，一致即表明注册通过，由服务端存储该 UserID 对应的公钥。

![image-20240329133446139](./assets/image-20240329133446139.png)

登录流程大致可以分为以下步骤：

1. 用户访问登录页面，填入用户名后即可点击登录按钮
2. 服务器返回随机字符串 Challenge、用户 UserID
3. 浏览器将 Challenge 和 UserID 转发给验证器
4. 验证器提示用户进行认证操作。由于在注册阶段验证器已经存储了该域名的私钥和用户信息，直接以存储的私钥加密 Challenge，然后返回给浏览器。用户尚未在此设备上进行过注册，或者密钥对已被清除或丢失，那么必须重新注册
5. 服务端接收到浏览器转发来的被私钥加密的 Challenge，以此前注册时存储的公钥进行解密，如果解密成功则宣告登录成功

私钥是保密的，只有验证器需要知道它。公钥可用于验证私钥生成的签名，但不能用来签名

## 授权

授权这个概念通常伴随着认证、审计、账号一同出现，并称为 AAAA（Authentication、Authorization、Audit、Account）。授权通常涉及以下两个相对独立的问题：

- **确保授权的过程可靠**：如何既让第三方系统能够访问到所需的资源，又能保证其不泄露用户的敏感数据呢？常用的多方授权协议主要有 OAuth2 和 SAML 2.0
- **确保授权的结果可控**：授权结果用于对程序功能或者资源的访问控制（Access Control）。权限控制模型有很多，譬如[自主访问控制](https://en.wikipedia.org/wiki/Discretionary_access_control)（Discretionary Access Control，DAC）、[强制访问控制](https://en.wikipedia.org/wiki/Mandatory_access_control)（Mandatory Access Control，MAC）、[基于属性的访问控制](https://en.wikipedia.org/wiki/Attribute-based_access_control)（Attribute-Based Access Control，ABAC），还有最为常用的[基于角色的访问控制](https://en.wikipedia.org/wiki/Role-based_access_control)（Role-Based Access Control，RBAC）

这里我们介绍 RBAC 和 OAuth2 这两种访问控制和授权方案

###  RBAC

所有的访问控制模型，实质上都是在解决同一个问题：“**谁**（User）拥有什么**权限**（Authority）去**操作**（Operation）哪些**资源**（Resource）”。一种直观的解决方案就是权限直接关联在用户上，但当某个系统涉及到成百上千的资源时，需要为每个用户访问每个资源都分配合适的权限，这必定导致巨大的操作量和极高的出错概率。为了避免对每一个用户设定权限，RBAC 将权限从用户身上剥离，改为绑定到「角色」（Role）上，将权限控制变为对「角色拥有操作哪些资源的许可」这个逻辑表达式的值是否为真的求解过程。角色为的是解耦用户与权限之间的多对多关系，而许可为的是解耦操作与资源之间的多对多关系。

![image-20240329135209189](./assets/image-20240329135209189.png)

- RBAC 不仅是为了简化配置操作，还天然地满足了计算机安全中的“[最小特权原则](https://en.wikipedia.org/wiki/Principle_of_least_privilege)”（Least Privilege）。在 RBAC 模型中，角色拥有许可的数量，是根据完成该角色工作职责所需的最小权限来赋予的。

- RBAC 还允许对不同角色之间定义关联与约束，进一步强化它的抽象描述能力

- 不同角色之间也可以具有互斥性，即应遵循的强制性职责分离规定

  

建立访问控制模型的基本目的是为了管理垂直权限和水平权限

- **垂直权限即功能权限**。由于实际应用与权限模型具有高度对应关系（CRUD），将权限从具体的应用中抽离出来，放到通用的模型中是相对容易的，Spring Security、Apache Shiro 等权限框架就是这样的抽象产物
- **水平权限即数据权限**。但管理数据权限是困难很多的。



SpringSecurity 中的访问控制模型：

![image-20240329140154646](./assets/image-20240329140154646.png)

Role 和 Authority 完全共享同一套存储结构，唯一的差别仅是 Role 会在存储时自动带上“ROLE_”前缀罢了。在使用上，权限可以更加细粒度地管理 Permission。

### OAuth2

OAuth2 是**面向于解决第三方应用**（Third-Party Application）的认证授权协议。如果直接给第三方应用账户与密码，那么有以下几个问题（这里我们以 Travis-CI 作为第三方服务访问 GitHub 为例）：

- **密码泄漏**：如果 Travis-CI 被黑客攻破，将导致 GitHub 的密码也同时被泄漏
- **访问范围**：Travis-CI 将有能力读取、修改、删除、更新 GitHub 上的所有代码仓库
- **授权回收**：只有修改密码才能回收我授予给 Travis-CI 的权力。但是授权的应用除了 Travis-CI 之外却还有许多，修改了的话意味着所有别的第三方的应用程序会全部失效。

OAuth2 通过令牌（Token）代替用户密码作为授权的凭证。令牌上可以设定访问资源的范围以及时效性；每个应用都持有独立的令牌

![image-20240329140837229](./assets/image-20240329140837229.png)

“要求/同意授权”、“要求/同意发放令牌”、“要求/同意开放资源”几个服务请求、响应该如何设计。对此，OAuth2 一共提出了四种不同的授权方式，分别为：

- **授权码模式（Authorization Code）**
- **隐式授权模式（Implicit）**
- **密码模式（Resource Owner Password Credentials）**
- **客户端模式（Client Credentials）**



#### 授权码模式

![image-20240329141902193](./assets/image-20240329141902193.png)

0. 开始进行授权过程以前，第三方应用要先到授权服务器上进行注册，即提供一个域名地址，然后从授权服务器中获取 ClientID 和 ClientSecret
1. 第三方应用将资源所有者（用户）导向授权服务器的授权页面，并向授权服务器提供 ClientID 及用户同意授权后的回调 URI
2. 授权服务器根据 ClientID 确认第三方应用的身份，
3. 用户在授权页面中同意向该身份的应用进行授权
4. 如果用户同意授权，授权服务器将转向第三方应用在第 1 步调用中提供的回调 URI，并附带上以下查询参数：
   1. 授权码
   2. 获取令牌的地址。这里为了避免令牌在HTTP 302 重定向过程中被泄漏的风险。
5. 第三方应用通过回调地址收到授权码，然后将授权码与自己的 ClientSecret 一起作为参数，向授权服务器提供的获取令牌的服务地址发起请求，换取令牌。此处的 ClientSecret 保证了不会有其他应用冒充第三方应用骗取授权。
6. 授权服务器核对授权码和 ClientSecret，确认无误后，向第三方应用授予令牌。令牌有两个：
   1. 访问令牌（Access Token）：出于安全性的考虑，访问令牌通常具有较短的过期时间，到期后需要重新获取。
   2. 刷新令牌（Refresh Token）：客户端可以使用它来获取新的访问令牌，而不需要用户再次进行身份验证。刷新令牌的有效期要比访问令牌长得多，从而可以用于持久授权。
7. 资源服务器根据访问令牌所允许的权限，向第三方应用提供资源



现在很多 Web PWA 应用（Cordova、Electron、Node-Webkit.js）都没有应用服务器的支持，因此不支持授权码模式。所以就引出了 OAuth2 的第二种授权模式：隐式授权。

#### 隐式授权模式

![image-20240329141909350](./assets/image-20240329141909350.png)

在隐式授权中，授权服务器不会再去验证第三方应用的身份。因此，ClientSecret 就没有存在的意义了。但仍然需要在注册时提供回调域名，此时会要求该域名与接受令牌的服务处于同一个域内。此外，同样基于安全考虑，在隐式模式中明确禁止发放刷新令牌。

Fragment 就是地址中`#`号后面的部分，譬如这个地址 `http://bookstore.icyfenix.cn/#/detail/1` 的 Fragment 就是 `detail/1`. RFC 3986 中解释了 Fragment 是用于客户端定位的 URI 从属资源，譬如 HTML 中就可以使用 Fragment 来做文档内的跳转，而不会发起服务端请求。对一个带有 Fragment 的地址发出 Ajax 请求，那 Fragment 是不会跟随请求被发送到服务端的，只能在客户端通过 Script 脚本来读取。



#### 密码模式

在密码模式里，认证和授权就被整合成了同一个过程。它只能在高度可信任的场景中使用，比如系统内不同模块之间的授权。

![image-20240329141917409](./assets/image-20240329141917409.png)

#### 客户端模式

![image-20240329150301466](./assets/image-20240329150301466.png)



OAuth2 中还有一种与客户端模式类似的授权模式，在[RFC 8628](https://tools.ietf.org/html/rfc8628#section-3.4)中定义为“设备码模式”（Device Code）。典型的应用便是设备激活

![image-20240329151300438](./assets/image-20240329151300438.png)

## 凭证

对于「如何承载认证授权信息」这个问题，就两种思路：

-  Cookie-Session 为代表的服务端状态存储
- JWT 为代表的客户端状态存储

### Cookie-Session

RFC 6265 规范定义了 HTTP 的状态管理机制，在 HTTP 协议中增加了 Set-Cookie 指令，该指令的含义是以键值对的方式向客户端发送一组信息，此信息将在此后一段时间内的每次 HTTP 请求中，以名为 Cookie 的 Header 附带着重新发回给服务端

~~~http
Set-Cookie: id=icyfenix; Expires=Wed, 21 Feb 2020 07:28:00 GMT; Secure; HttpOnly
~~~

~~~http
GET /index.html HTTP/2.0
Host: icyfenix.cn
Cookie: id=icyfenix
~~~

一般来说，系统会把状态信息保存在服务端，在 Cookie 里只传输的是一个随机字符串，习惯上以`sessionid`或者`jsessionid`为名。服务器拿这个字符串为 Key，在内存中开辟一块空间，以 Key/Entity 的结构存储每一个在线用户的上下文状态。状态信息都存储于服务器，只要依靠客户端的同源策略和 HTTPS 的传输层安全，保证 Cookie 中的键值不被窃取而出现被冒认身份的情况

Session-Cookie 在单节点的单体服务环境中是最合适的方案，但当需要水平扩展服务能力，要部署集群时就开始面临麻烦了，但有以下几种解决方案：

1. 让均衡器采用亲和式的负载均衡算法，譬如根据用户 IP 或者 Session 来分配节点
2. 让各个节点之间采用复制式的 Session，每一个节点中的 Session 变动都会发送到组播地址的其他服务器上
3. 将上下文存储在一个所有服务节点都能访问到的数据节点中



### JWT

JWT（JSON Web Token）定义于 [RFC 7519](https://tools.ietf.org/html/rfc7519) 标准之中。JWT 分为三个部分：

- **令牌头**（Header）

  ~~~json
  {
    "alg": "HS256",
    "typ": "JWT"
  }
  ~~~

- **负载**（Payload）：针对认证问题，负载至少应该包含能够告知服务端“这个用户是谁”的信息。针对授权问题，令牌至少应该包含能够告知服务端“这个用户拥有什么角色/权限”的信息。

- **签名**（Signature）：它的意义在于确保负载中的信息是可信的、没有被篡改的、完整的

![img](./assets/jwt.b07b0d79.png)

使用 Base64URL 进行编码，注意令牌是明文传输的。JWT 只解决防篡改的问题，并不解决防泄漏的问题。



采用 JWT 令牌的 HTTP 实际请求：

~~~http
GET /restful/products/1 HTTP/1.1
Host: icyfenix.cn
Connection: keep-alive
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9....
~~~



可以通过 JWT 来维护上下文状态，使得服务端不持有状态。JWT 有以下几个问题：

1. **令牌难以主动失效**：设计一个「黑名单」的逻辑，用来把要主动失效的令牌集中存储起来。而无论这个黑名单是实现在 Session、Redis 或者数据库中，都会让服务退化成有状态服务，降低了 JWT 本身的价值。但黑名单依然是很常见的做法，因为它一般保存着很小的状态量。
2. **相对更容易遭受重放攻击**
3. **只能携带相当有限的数据**
4. **必须考虑令牌在客户端如何存储**
5. **无状态也不总是好的**

## 保密

密码储存中常见的保密手段：

1. 以摘要代替明文。但是不能防范彩虹表攻击，它是哈希值与原始密码之间的映射表。

   ![img](./assets/1116722-20181129160121107-1864223689.png)

2. 加入盐值。通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。一定程度上防御彩虹表攻击，但不能阻止加密结果被窃取后，攻击者直接发送加密结果给服务端进行冒认

3. 将盐值变为动态值能有效防止冒认。但是但这样协商出盐值的过程将变得极为复杂，而且每次协商只保护一次操作，也难以阻止对其他服务的重放攻击。可以使用伪动态盐值，即使用日期或用户名等内容作为盐值

4. 启用 HTTPS 可以防御链路上的恶意嗅探，也能在通信层面解决了重放攻击的问题。但是依然有伪造根证书的风险

5. 为了抵御上述风险，保密强度还要进一步提升

   1. 独立于客户端的存储证书的物理设备（俗称的 U 盾），来避免根证书被客户端中的恶意程序窃取伪造
   2. 使用双重验证开辟一条独立于网络的信息通道（如手机验证码、电子邮件），来显著提高冒认的难度
   3. 建设专用内部网络来保障通信安全

上述加密过程可以在客户端进行，也可以在服务端上进行。注意，为了保证信息不被黑客在链路上窃取而做客户端加密，是没有太多意义，因为有**中间人攻击（Man-in-the-Middle Attack，MitM）**。



我们下面通过一个例子来说明加密过程

1. 用户在客户端输入明文密码`123456`

2. 客户端对用户密码进行简单哈希摘要

   ~~~bash
   client_hash = MD5(password) // e10adc3949ba59abbe56e057f20f883e
   ~~~

3. 为了防御彩虹表攻击，进行了加盐处理

   ~~~bash
   client_hash = MD5(MD5(password) + salt)  // SALT = $2a$10$o5L.dWYEjZjaejOmN3x4Qu
   ~~~

   为了应对暴力破解，并不提倡在盐值上做动态化，更理想的方式是引入慢哈希函数来解决。慢哈希函数是指这个函数执行时间是可以调节的哈希函数。BCrypt 算法就是一种典型的慢哈希函数，它做哈希计算时接受盐值 Salt 和执行成本 Cost 两个参数（代码层面 Cost 一般是混入在 Salt 中）。如果 Cost 为 10，那么表示进行  10 轮运算，即 $2^{10}$ 次哈希。

   ~~~bash
   client_hash = BCrypt(MD5(password) + salt)  // MFfTW3uNI4eqhwDkG7HP9p2mzEUu/r2
   ~~~

4. 在服务端上生成为密码生成一个随机盐值：

   ~~~java
   SecureRandom random = new SecureRandom();
   byte server_salt[] = new byte[36];
   random.nextBytes(server_salt);   // tq2pdxrblkbgp8vt8kbdpmzdh1w8bex
   ~~~

5. 将动态盐值混入客户端传来的哈希值再做一次哈希，产生出最终的密文，并和上一步随机生成的盐值一起写入到同一条数据库记录中

   ~~~java
   server_hash = SHA256(client_hash + server_salt);  
   DB.save(server_hash, server_salt);
   ~~~

验证过程：

1. 客户端输入密码明文：`123456`。经过与注册相同的加密过程，向服务端传输加密后的结果

   ~~~java
   authentication_hash = MFfTW3uNI4eqhwDkG7HP9p2mzEUu/r2
   ~~~

2. 服务端从数据库中取出对应的盐值，采用相同的哈希算法，计算摘要结果

   ~~~java
   result = SHA256(authentication_hash + server_salt)
   ~~~

3. 比较上一步的结果和数据库储存的哈希值是否相同，如果相同那么密码正确

   ~~~java
   authentication = compare(result, server_hash) // yes
   ~~~

## 验证



验证逻辑在哪一层上实现？Controller 层、Service层、Dao层还是前端？笔者推荐在 Bean 上做。即 Java Bean Validation。这样校验便和业务逻辑就完全分离开来，在需要校验时用`@Valid`注解自动触发。

