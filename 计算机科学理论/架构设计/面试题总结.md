# 面试题

[TOC]

## 布隆过滤器

它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中，存在着一定误识别率。

![布隆过滤器.png](./assets/9ebde5c11ad69447314c216acf188fc8.png)

添加的 key 需要根据 k 个无偏 hash 函数，计算得到多个 hash 值。然后分别取模 hash 得到数组下标。最后将对应的 bit 设置为 1。

![增加元素.png](./assets/a3e7d217ecb825e94bdc577a467eb29d.png)

当查询元素时，根据 k 个无偏 hash 函数，计算得到多个 hash 值。然后分别取模 hash 得到数组下标。如果对应 bit 全都为 1，那么元素就存在，否则不存在。

布隆过滤器对元素的删除不太支持

实际上，可以通过提升误判率来减少布隆过滤器的空间占用。公式 4.6. 1给出了误判率、空间占用等参数之间的关系式。假设有以下参数：

- n：过滤器中有多少个元素
- p：误判率
- m：过滤器需要占用的空间（单位为Bit）
- k：要使用的哈希函数的个数

$$
m = -\frac{n * ln(p)}{(ln2)^2}
$$

$$
k = \frac{m}{n} * ln2
$$

这里取 n = 2,0000,0000 以及p = 0.1 。计算出 k = 3.32 以及m = 958505838 bits (117005.10 KB)

**布隆过滤器在线计算的网址**：https://krisives.github.io/bloom-calculator/



下面介绍 Redis 如何集成布隆过滤器：

1. https://github.com/RedisLabsModules/rebloom/archive/v2.2.6.tar.gz

2. 编译插件：

   ~~~shell
   cd RedisBloom-2.2.6/
   make
   ~~~

   ![image.png](./assets/f11054f4f831b629a46b3d4e727b4c6d.png)

3. 在 redis.conf 配置文件中，加入如 RedisBloom 的 redisbloom.so 文件的地址

   ~~~conf
   loadmodule /usr/local/soft/RedisBloom-2.2.6/redisbloom.so
   ~~~

4. 重启 Redis 





布隆过滤器的主要指令如下：

- bf.add 添加一个元素
- bf.exists 判断一个元素是否存在
- bf.madd 添加多个元素
- bf.mexists 判断多个元素是否存在

通过`BF.RESERVE`命令手动创建布隆过滤器：

~~~shell
# BF.RESERVE {key} {error_rate} {capacity} [EXPANSION {expansion}] [NONSCALING]
BF.RESERVE orders 0.1 10000000
~~~

- key：filter 的名字；
- error_rate：期望的错误率，默认 0.1，值越低，需要的空间越大；
- capacity：初始容量，默认 100，当实际元素的数量超过这个初始化容量时，误判率上升。

如果不使用`BF.RESERVE`命令创建，而是使用 Redis 自动创建的布隆过滤器，默认的 `error_rate` 是 `0.01`，`capacity`是 100。



添加 Redission 依赖：

```xml
<dependency>
  <groupId>org.redisson</groupId>
  <artifactId>redisson-spring-boot-starter</artifactId>
  <version>3.16.7</version>
</dependency>
```

创建布隆过滤器

```java
@Service
public class BloomFilterService {

    @Autowired
    private RedissonClient redissonClient;

    /**
     * 创建布隆过滤器
     * @param filterName 过滤器名称
     * @param expectedInsertions 预测插入数量
     * @param falseProbability 误判率
     * @param <T>
     * @return
     */
    public <T> RBloomFilter<T> create(String filterName, long expectedInsertions, double falseProbability) {
        RBloomFilter<T> bloomFilter = redissonClient.getBloomFilter(filterName);
        bloomFilter.tryInit(expectedInsertions, falseProbability);
        return bloomFilter;
    }

}
```

单元测试如下：

```java
@Autowired
private BloomFilterService bloomFilterService;

@Test
public void testBloomFilter() {
    // 预期插入数量
    long expectedInsertions = 10000L;
    // 错误比率
    double falseProbability = 0.01;
    RBloomFilter<Long> bloomFilter = bloomFilterService.create("ipBlackList", expectedInsertions, falseProbability);

    // 布隆过滤器增加元素
    for (long i = 0; i < expectedInsertions; i++) {
        bloomFilter.add(i);
    }
    long elementCount = bloomFilter.count();
    log.info("elementCount = {}.", elementCount);

    // 统计误判次数
    int count = 0;
    for (long i = expectedInsertions; i < expectedInsertions * 2; i++) {
        if (bloomFilter.contains(i)) {
            count++;
        }
    }
    log.info("误判次数 = {}.", count);
    bloomFilter.delete();
}
```



## 事务与锁

下面我们来看一个例子：

~~~java
@Transactional(rollbackFor = Exception.class)
public Result func(seckillId, long userId) {
    lock.lock();
    lock.unlock();
}
~~~

这样事务的提交在解锁之后，在这段时间，很可能产生线程安全问题。因此我们要这样写，把整个事务放在锁的工作范围之内：

~~~java
public void lockProduct() {
    try {
        lock.lock();
        sellProduct();
    } finally {
        lock.unlock();
    }
}
@Transactional(rollbackFor = Exception.class)
public Result sellProduct() {
    
}
~~~



## JVM Dump

获取 JVM 的 dump 文件的两种方式：

-  JVM 启动时增加两个参数：

  ~~~shell
  #出现 OOME 时生成堆 dump: 
  -XX:+HeapDumpOnOutOfMemoryError
  
  #生成堆文件地址：
  -XX:HeapDumpPath=/opt/jvmlogs/
  ~~~

- 直接生成当前 JVM 的 dump 文件

  ~~~java
  jmap -dump:format=b,file=/var/logs/heap.hprof 1234
  // 1234是指JVM的进程号
  ~~~

## 配置项加密

1. 增加配置项 `jasypt.encryptor.password = Afei@2018`，这是加密的秘钥；
2. 所有明文密码替换为 ENC（加密字符串），例如 `ENC(XW2daxuaTftQ+F2iYPQu0g==)`；
3. 引入一个 MAVEN 依赖；

~~~xml
<dependency>
    <groupId>com.github.ulisesbocchio</groupId>
    <artifactId>jasypt-spring-boot-starter</artifactId>
    <version>2.0.0</version>
</dependency>
~~~

## 分布式 Session

- Session 复制
- 数据库保存
- 分布式缓存保存
- 客户端存储

