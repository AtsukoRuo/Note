

[TOC]

## 链表

### 区块世界 UVA101

~~~c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int numberOfBlock;
vector<vector<int>> blocks;

pair<int, int> whereBlock(int target) {
	for (int i = 0; i < numberOfBlock; i++) {
		vector<int> &v = blocks[i];
		for (int j = 0; j < v.size(); j++) {
			if (v[j] == target) {
				return {i, j};
			}
		}
	}
	return {};
}


void printBlocks() {
	for (int i = 0; i < numberOfBlock; i++) {
		cout << i << ": ";
		vector<int> &v = blocks[i];
		for (int j = 0; j < v.size(); j++) {
			cout << v[j] << " ";
		}
		cout << "\n";
	}
	cout << "\n\n";
}

void moveBlocks(int ai, int ah, int bi) {
	vector<int> &v = blocks[ai];
	for_each(v.begin() + ah, v.end(), [=](int num) {
		blocks[bi].push_back(num);
	});
	v.resize(ah);
	return;
}


void init(int index, int height) {
	vector<int> &v = blocks[index];
	for (int i = height + 1; i < v.size(); i++) {
		int k = v[i];
		blocks[k].push_back(k);
	}
	v.resize(height + 1);
}


int main() {
	cin >> numberOfBlock;
	for (int i = 0; i < numberOfBlock ; i++) {
		blocks.push_back(vector<int> {i});
	}

	while (true) {
		int a, b;
		string A, B;
		cin >> A ;
		if (A == "quit") 
			break;
		cin >> a >> B >> b;

		pair<int, int> ai = whereBlock(a);
		pair<int, int> bi = whereBlock(b);
		if (ai.first == bi.first) continue;
		if (A == "move") {
			if (B == "onto") {
				init(ai.first, ai.second);
				init(bi.first, bi.second);
				blocks[ai.first].pop_back();
				blocks[bi.first].push_back(a);
			} else {
				init(ai.first, ai.second);
				blocks[ai.first].pop_back();
				blocks[bi.first].push_back(a);
			}
		} else {
			if (B == "onto") {
				init(bi.first, bi.second);
				moveBlocks(ai.first, ai.second, bi.first);
			} else {
				moveBlocks(ai.first, ai.second, bi.first);
			}
		}
	}
	printBlocks();
}
~~~



### 悲剧文本 UVA11988

~~~c++
#include <iostream>
using namespace std;

const int MAX  = 40'0000;

string _data[MAX];
int _next[MAX];
int _prev[MAX];
int idx = 0;

void initList() {
    _next[0] = 1;
    _prev[1] = 0;
    idx = 2;
}

void addHeader(string data) {
    _next[idx] = _next[0];
    _prev[idx] = 0;

    _prev[_next[0]] = idx;
    _next[0] = idx;

    _data[idx++] = data;
}

void addTailer(string data) {
    _next[idx] = 1;
    _prev[idx] = _prev[1];

    _next[_prev[1]] = idx;
    _prev[1] = idx;

    _data[idx++] = data;
}


int main() {
    
    string line;
    while (cin >> line) {
        initList();
        string word = "";
        char last = '[';
        for (const auto &ch : line) {
            if (ch == '[' || ch == ']') {
                if (last == '[') {
                    addHeader(word);
                } else if (last == ']') {
                    addTailer(word);
                }
                word = "";
                last = ch;
            } else {
                word.push_back(ch);
            }
        }
        if (last == '[') {
            addHeader(word);
        } else if (last == ']') {
            addTailer(word);
        }
        for (int i = _next[0]; i != 1; i = _next[i]) {
            cout << _data[i];
        }
        cout << "\n";
    }
    return 0;
}
~~~



### 移动盒子 UVA12657

~~~c++
#include <iostream>
#include <algorithm>
#include <list>
#include <vector>
using namespace std;

const int MAX_NUM = 10'0010;
int _data[MAX_NUM];
int _next[MAX_NUM];
int _prev[MAX_NUM];


void init(int n) {
    _next[0] = 2;
    _next[1] = 1;
    _prev[1] = n + 1;
    for (int i = 2; i < n + 1; i++) {
        _next[i] = i + 1;
    }
    _next[n + 1] = 1;
    for (int i = n + 1; i > 2; i--) {
        _prev[i] = i - 1;
    }
    _prev[2] = 0;
}

void link(int l, int r) {
    _next[l] = r;
    _prev[r] = l;
}


void printList() {
    for (int i = _next[0]; i != 1; i = _next[i]) {
        cout << _data[i] << " ";
    }
    cout << "\n";
}
int main() {
    int n, m;

    int value = 1;
    generate(_data + 2, _data + MAX_NUM, [&value]() {
        return value++;
    });
    int index = 1;
    bool isFlipped = false;
    while (cin >> n >> m) {
        init(n);
        int op, x = 0, y = 0;
        for (int i = 0; i < m; i++) {
            cin >> op;
            if (op == 4) {
                isFlipped = !isFlipped;
            } else {
                cin >> x >> y;
                x += 1, y += 1;
                if (op == 3 && _next[y] == x) {
                    swap(x, y);
                }
                int Lx = _prev[x];
                int Rx = _next[x];
                int Ly = _prev[y];
                int Ry = _next[y];
                if (op != 3 && isFlipped) {
                    op = 3 - op;
                }
                if ((op == 1 && x == Ly) || (op == 2 && x == Ry))
                    continue;
                if (op == 1) {
                    link(Lx, Rx);
                    link(Ly, x);
                    link(x, y);
                } else if (op == 2) {
                    link(Lx, Rx);
                    link(y, x);
                    link(x, Ry);
                } else if (op == 3) {
                    if (Rx == y) {
                        link(Lx, y);
                        link(y, x);
                        link(x, Ry);
                    } else {
                        link(Lx, y);
                        link(y, Rx);
                        link(Ly, x);
                        link(x, Ry);
                    }
                }
            }
        }
        unsigned long ans = 0;
        for (int i = _next[0]; i != 1; i = _next[_next[i]]) {
            ans += _data[i];
        }

        if (isFlipped && n % 2 == 0) {
            ans = (unsigned long)n * (n + 1) / 2 - ans;
        }
        cout << "Case " << (index++) << ": " << ans << "\n";
    }
    return 0;
}
~~~

## 栈

### 铁轨 UVA514

~~~c++
int main() {
    int n;
    while ((cin >> n) && n != 0) {
        
        while (true) {
            vector<int> out;
            stack<int> s;
            int tmp;
            cin >> tmp;
            if (tmp == 0) break;
            out.push_back(tmp);
            for (int i = 0; i < n - 1; i++) {
                cin >> tmp;
                out.push_back(tmp);
            }
            int index = 0;
            // 将1 2 3 ... n依次和out[index]对比
        	// 如果不匹配，暂时放入栈中
        	// 若匹配，则index++，并且考察栈顶元素是否与out[index]匹配
            for (int i = 1; i <= n; i++) {
                
                if (i == out[index]) {
                    index++;
                    while (!s.empty() && s.top() == out[index++]) {
                        s.pop();
                    }
                } else {
                    s.push(i);
                }
            }
            cout << (s.empty() ? "YES" :"NO") << '\n';
        }
    }
}
~~~

