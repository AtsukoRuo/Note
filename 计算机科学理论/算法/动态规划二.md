## èƒŒåŒ…

[TOC]



### 01 èƒŒåŒ…

![0-1 èƒŒåŒ…é—®é¢˜](./assets/20240514111617.png)

- é˜¶æ®µåˆ’åˆ†ï¼šå‡è®¾ç¬¬ i é˜¶æ®µè¡¨ç¤ºå¤„ç†ç¬¬ i ç§ç‰©å“

- çŠ¶æ€è¡¨ç¤ºï¼š`c[i][j]`è¡¨ç¤ºå‰ i ç§ç‰©å“åœ¨ä¸Šé™å®¹é‡ä¸º j çš„èƒŒåŒ…ä¸­æ‰€è·å¾—çš„æœ€å¤§ä»·å€¼ã€‚

- çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
  $$
  dp[i][j] =  \left \{ 
  \begin{array}{lr} 
  dp[i - 1][j] &, j < w[i] \\ 
  max\{dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]\} &, j\geq w[i]\end{array}
  \right \}
  $$

  ```java
  // n è¡¨ç¤º n ä»¶ç‰©å“
  for (int i = 1; i <= n; i++) {
      //  W è¡¨ç¤ºèƒŒåŒ…çš„æœ€å¤§å®¹é‡
      for (int j = 1; j <= W; j++) 
          // è‹¥ç‰©å“ i çš„ä½“ç§¯å¤§äºèƒŒåŒ…å®¹é‡ï¼Œå°±ä¸æ”¾ç½®
  		if (j < w[i])	 
              c[i][j] = c[i - 1][j]
          else 
              c[i][j] = max(c[i - 1][j], c[i - 1][j - w[i]] + v[i])
  }
  ```


æ„é€ è§£ï¼š

  [![image-20240216114505201](https://github.com/AtsukoRuo/note/raw/default/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E7%90%86%E8%AE%BA/%E7%AE%97%E6%B3%95/assets/image-20240216114505201.png)](https://github.com/AtsukoRuo/note/blob/default/è®¡ç®—æœºç§‘å­¦ç†è®º/ç®—æ³•/assets/image-20240216114505201.png)

- è‹¥`c [i][j] > c [i âˆ’1][j]`ï¼Œåˆ™è¯´æ˜ç¬¬ i ç§ç‰©å“è¢«æ”¾å…¥èƒŒåŒ…ï¼Œä»¤`x[i] = 1ï¼Œj âˆ’= w [i ]` 

- è‹¥`c[i][j] â‰¤ c[i âˆ’1][j]`ï¼Œåˆ™è¯´æ˜ç¬¬ i ç§ç‰©å“æ²¡è¢«æ”¾å…¥èƒŒåŒ…ï¼Œä»¤`x[i] = 0`ã€‚

  ```java
  for (int i = n; i > 0; i--) {
  	if (c[i][j] > c[i - 1][j]) {
          x[i] = 1;
          j -= w[i];
      } else {
          x[i] = 0;
      }
  }
  ```

 

ä¼˜åŒ–æ€è·¯ ï¼Œ**è‹¥ä¸æ„é€ æœ€ä¼˜è§£**ï¼Œé‚£ä¹ˆç¬¬ i -1 ç§ç‰©å“ä¹‹å‰çš„å¤„ç†ç»“æœå·²ç»æ²¡ç”¨äº†ï¼Œå› æ­¤å¯ä»¥å°†ä¼˜åŒ–ä¸ºï¼š $$ dp[j] = max\{dp[j], dp[j - w[i]] + v[i]\} $$

```java
// è¿™éœ€è¦å€’æ¨
for (int i = 1; i <= n; i++) {
    for (int j = W; j >= w[i]; j--) {
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}
```

**æ³¨æ„ï¼Œè¿™ä»…ä»…ä¼˜åŒ–å­˜å‚¨ç©ºé—´ï¼Œå¹¶ä¸ä¼˜åŒ–æ—¶é—´å¤æ‚åº¦**



### å®Œå…¨èƒŒåŒ…

![å®Œå…¨èƒŒåŒ…é—®é¢˜](./assets/20240514111640.png)

çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
$$
c[i][j] = \left \{ 
\begin{array}{lr} 
c[i - 1][j] &, j < w[i]\\ max\{c[i - 1][j - w[i] * k] + v[i] * k\} &, k = 0, 1,... \and  k * v[i] \leq j \end{array} \right.
$$


æˆ‘ä»¬æ¥ä¸‹æ¥å¯¹ä¸Šè¿°æ–¹ç¨‹è¿›è¡Œä¼˜åŒ–ï¼Œå¯ä»¥è§‚å¯Ÿåˆ°ï¼š
$$
c[i][j] = max\{c[i - 1][j], c[i-1][j-w[i]]+v[i], c[i-1][j - 2w[i]]+2v[i],....\}
$$
ç”±
$$
c[i][j-w[i]] = max\{c[i - 1][j - w[i]],c[i-1][j-2w[i]]+v[i],c[i-1][j-3w[i]] + 2v[i],...\}
$$
å¯ä»¥æ¨å‡ºï¼š
$$
c[i][j-w[i]] + v[i]= max\{c[i - 1][j - w[i]] + v[i],c[i-1][j-2w[i]]+2v[i],c[i-1][j-3w[i]] + 3*v[i],...\}
$$
 ç»“åˆä¸Šé¢ä¸¤å¼ï¼Œå¯ä»¥æˆ‘ä»¬å¾—åˆ°
$$
dp[i][j] = max\{dp[i-1][j], dp[i][j-w[i]] + v[i]\}
$$
01èƒŒåŒ…ä¸å®Œå…¨èƒŒåŒ…çš„å¯¹æ¯”ï¼š

- 01èƒŒåŒ…ï¼š$max\{c[i - 1][j], \textcolor{red}{c[i - 1]}[j - w[i]] + v[i]\}$
- å®Œå…¨èƒŒåŒ…ï¼š$max\{c[i-1][j], \textcolor{red}{c[i]}[j-w[i]] + v[i]\}$





ä»£ç å¯ä»¥ä¼˜åŒ–ä¸º

```java
for (int i = 1; i <= n; i++) {
    // æ­£æ¨å³å¯
    for (int j = w[i]; j <= W; j++) {
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}
```



ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `cost` å’Œä¸€ä¸ªæ•´æ•° `target` ã€‚è¯·ä½ è¿”å›æ»¡è¶³å¦‚ä¸‹è§„åˆ™å¯ä»¥å¾—åˆ°çš„ **æœ€å¤§** æ•´æ•°ï¼š

- ç»™å½“å‰ç»“æœæ·»åŠ ä¸€ä¸ªæ•°ä½ï¼ˆ`i + 1`ï¼‰çš„æˆæœ¬ä¸º `cost[i]` ï¼ˆ`cost` æ•°ç»„ä¸‹æ ‡ä» 0 å¼€å§‹ï¼‰ã€‚
- æ€»æˆæœ¬å¿…é¡»æ°å¥½ç­‰äº `target` ã€‚
- æ·»åŠ çš„æ•°ä½ä¸­æ²¡æœ‰æ•°å­— 0 ã€‚

ç”±äºç­”æ¡ˆå¯èƒ½ä¼šå¾ˆå¤§ï¼Œè¯·ä½ ä»¥å­—ç¬¦ä¸²å½¢å¼è¿”å›ã€‚å¦‚æœæŒ‰ç…§ä¸Šè¿°è¦æ±‚æ— æ³•å¾—åˆ°ä»»ä½•æ•´æ•°ï¼Œè¯·ä½ è¿”å› "0" ã€‚

~~~go
func largestNumber(cost []int, target int) string {
	W := target
	n := len(cost)
	dp := make([][]string, n+1)
	
    INF := "0"
	for i, _ := range dp {
		dp[i] = make([]string, W+1)
		for j, _ := range dp[i] {
			dp[i][j] = string(INF)      // ç½®äºæ— æ•ˆçŠ¶æ€
		}
	}
	// è¿™é‡Œçš„ value æ•°ç»„æ˜¯éšå¼çš„ï¼Œä¸‹é¢ä¼šè¯´æ˜
    
    // åˆå§‹åŒ–è¾¹ç•Œ
    for j := 0; j <= n; j++ {
        dp[j][0] = ""
    }

    // è¿™ä¸ªè¾¹ç•Œä¸èƒ½åˆå§‹åŒ–ï¼Œå› ä¸ºä¸ç¬¦åˆæ°å¥½çš„è¯­ä¹‰
    // for j := 0; j <= W; j++ {
    //     dp[0][j] = ""
    // }

    // é€šè¿‡è¿™ä¸ªå‡½æ•°æ¥é—´æ¥è¡¨è¾¾ value æ•°ç»„
	betterString := func(a, b string) string {
        //å¦‚æœaå’Œbé•¿åº¦ä¸€æ ·ã€‚è¿”å›string å­—å…¸åº
	if len(a) == len(b) {
		if a > b {
			return a
		}
		return b
	}
	//å¦åˆ™è¿”å›é•¿åº¦è¾ƒé•¿çš„å€¼
	if len(a) > len(b) {
		return a
	}
	return b
	}

	for i := 0; i < n; i++ {
		for j := 1; j <= W; j++ {
			if cost[i] > j {
                // æ— æ•ˆçŠ¶æ€ç›´æ¥è·³è¿‡
                if (dp[i][j] != INF) {
                    dp[i+1][j] = dp[i][j]
                }
			} else {
                if dp[i+1][j-cost[i]] != INF && dp[i][j] != INF{
                    dp[i+1][j] = betterString(dp[i][j], string(i+1 +'0')+dp[i+1][j-cost[i]])
                } else if dp[i][j] != INF  && dp[i+1][j-cost[i]] == INF {
                    dp[i+1][j] = dp[i][j]
                } else if dp[i][j] == INF  && dp[i+1][j-cost[i]] != INF {
                    dp[i+1][j] = string(i+1 +'0')+dp[i+1][j-cost[i]]
                }
			}
		}
	}

	if dp[n][W] == INF {
		return "0"
	}
	return dp[n][W]
}

~~~

### å¤šé‡èƒŒåŒ…

![å¤šé‡èƒŒåŒ…é—®é¢˜](./assets/20240514111701.png)

å¯¹äºå®¹é‡ä¸º w çš„ èƒŒåŒ…ï¼Œæœ€å¤šå¯ä»¥è£… $min\{count[i-1],\frac{w}{weight[i-1]}\}$ä»¶ç¬¬ `i-1` ä¸ªç‰©å“ã€‚é‚£ä¹ˆæˆ‘ä»¬å¤–åŠ ä¸€å±‚å¾ªç¯ï¼Œæšä¸¾ç¬¬ `i-1` ä»¶ç‰©å“å¯ä»¥é€‰æ‹©çš„ä»¶æ•°ï¼Œä»è€Œå°†ã€Œå¤šé‡èƒŒåŒ…é—®é¢˜ã€è½¬æ¢ä¸ºã€Œ0-1 èƒŒåŒ…é—®é¢˜ã€ã€‚

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨äºŒè¿›åˆ¶æ¥ä¼˜åŒ–æšä¸¾ï¼Œä½¿å¾—æ—¶é—´å¤æ‚åº¦é™ä½ã€‚å°±æ˜¯æŠŠç‰©å“çš„æ•°é‡ $count[i]$ æ‹†åˆ†æˆç”± $1,2,4,...,2^m$ ä»¶å•ä¸ªç‰©å“ç»„æˆçš„å¤§ç‰©å“ï¼Œä»¥åŠç”±å‰©ä½™ä¸è¶³ 2 çš„æ•´æ•°æ¬¡å¹‚æ•°é‡çš„ç‰©å“ç»„æˆå¤§ç‰©å“



~~~go
func  multiplePackMethod(weight []int, value []int, count []int, W int) {
    n := len(count)
    newWeight, newValue := []int{}, []int{}
    for i := 0; i < n; i++ {
        cnt := count[i]
        k := 1
        // å¼€å§‹ä»¥ 2 æ¬¡å¹‚æ¥è¿›è¡Œåˆå¹¶
        for k <= cnt {
            cnt -= k
            newWeight = append(newWeight, weight[i] * k)
            newValue = append(newValue, value[i] * k)
            k *= 2
        }
        // å°†å‰©ä¸‹ä¸è¶³ 2 æ¬¡å¹‚çš„éƒ¨åˆ†è¿›è¡Œåˆå¹¶
        if cnt > 0 {
        	newWeight = append(newWeight, cnt)
            newValue = append(newValue, cnt)
        }
    }
    
    // æŒ‰ 01 èƒŒåŒ…å¼€å§‹å¤„ç†
}
~~~



### æ··åˆèƒŒåŒ…

![æ··åˆèƒŒåŒ…é—®é¢˜](./assets/20240514111727.png)

~~~go
func mixedPackMethod(weight []int, value []int, count []int, W int) {
    n := len(count)
    newWeight, newValue, newCount := []int{}, []int{}, []int{}
    for i := 0; i < n; i++ {
        cnt := count[i]
        // å¤šé‡èƒŒåŒ…é—®é¢˜ï¼Œè½¬æ¢ä¸º 0-1 èƒŒåŒ…é—®é¢˜
        if cnt > 0 {
            k := 1
            // å¼€å§‹ä»¥ 2 æ¬¡å¹‚æ¥è¿›è¡Œåˆå¹¶
            for k <= cnt {
                cnt -= k
                newWeight = append(newWeight, weight[i] * k)
                newValue = append(newValue, value[i] * k)
                k *= 2
            }
            // å°†å‰©ä¸‹ä¸è¶³ 2 æ¬¡å¹‚çš„éƒ¨åˆ†è¿›è¡Œåˆå¹¶
            if cnt > 0 {
                newWeight = append(newWeight, cnt)
                newValue = append(newValue, cnt)
            }
            newCount = append(newCount, 1)
        } else if cnt == -1 {
            //  0-1 èƒŒåŒ…é—®é¢˜ï¼Œç›´æ¥æ·»åŠ 
            newWeight = append(newWight, weight[i])
            newValue = append(newValue, value[i])
            newCount = append(newCount, 1)
        } else {
            // å®Œå…¨èƒŒåŒ…é—®é¢˜
            newWeight = append(newWight, weight[i])
            newValue = append(newValue, value[i])
            newCount = append(newCount, 0)
        }
    }
    
    // ä¸€ç»´ä¼˜åŒ–å½¢å¼ï¼š
    dp := make([]int, W)
    n = len(newWeight)
    for i := 1; i <= n; i++ {
        if newCount[i - 1] == 1{
            // 01 èƒŒåŒ…é—®é¢˜
            // é€†åºéå†
        } else {
            // å®Œå…¨èƒŒåŒ…é—®é¢˜
            // æ­£åºéå†
        }
    }
}
~~~



### åˆ†ç»„èƒŒåŒ…

![åˆ†ç»„èƒŒåŒ…é—®é¢˜](./assets/20240514111745.png)

æ¯ç»„ç‰©å“ä¸­æœ€å¤šåªèƒ½é€‰æ‹© 1 ä»¶ç‰©å“è£…å…¥èƒŒåŒ…ã€‚

- çŠ¶æ€å®šä¹‰ï¼š`dp[i][w]`è¡¨ç¤ºä¸ºå‰ ğ‘– ç»„ç‰©å“æ”¾å…¥æœ€å¤šèƒ½è£…é‡é‡ä¸º ğ‘¤ çš„èƒŒåŒ…ä¸­ï¼Œå¯ä»¥è·å¾—çš„æœ€å¤§ä»·å€¼ã€‚

- çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
  $$
  dp[i][w] = max\{dp[i-1][w], dp[i-1][w-weight[i-1][k]] + value[i - 1][k]\}, 0\leq k \leq group_count[i-1]
  $$
  

~~~python
def groupPackMethod1(self, group_count: [int], weight: [[int]], value: [[int]], W: int):
    size = len(group_count)
    dp = [[0 for _ in range(W + 1)] for _ in range(size + 1)]

    # æšä¸¾å‰ i ç»„ç‰©å“
    for i in range(1, size + 1):
        # æšä¸¾èƒŒåŒ…è£…è½½é‡é‡
        for w in range(W + 1):
            # æšä¸¾ç¬¬ i - 1 ç»„ç‰©å“èƒ½å–ä¸ªæ•°
            dp[i][w] = dp[i - 1][w]
            for k in range(group_count[i - 1]):
                if w >= weight[i - 1][k]:
                    # dp[i][w] å–æ‰€æœ‰ dp[i - 1][w - weight[i - 1][k]] + value[i - 1][k] ä¸­æœ€å¤§å€¼
                    dp[i][w] = max(dp[i][w], dp[i - 1][w - weight[i - 1][k]] + value[i - 1][k])
~~~



### å¤šç»´èƒŒåŒ…

![äºŒç»´è´¹ç”¨èƒŒåŒ…é—®é¢˜](./assets/20240514111802.png)

- å®šä¹‰çŠ¶æ€ `dp[i][w][v]` ï¼šå‰ i ä»¶ç‰©å“æ”¾å…¥ä¸€ä¸ªæœ€å¤šèƒ½è£…é‡é‡ä¸º *w*ã€å®¹é‡ä¸º *v* çš„èƒŒåŒ…ä¸­ï¼Œå¯ä»¥è·å¾—çš„æœ€å¤§ä»·å€¼ã€‚

- çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
  $$
  dp[i][w][v] = max(dp[i - 1][w][v], dp[i-1][w-weight[i-1]][v-volume[v - 1]] + value[i-1]), 0\leq weight[i-1] \leq w, 0 \leq volume[i-1] \leq v
  $$
  

### å˜ç§

#### æ°å¥½è£…æ»¡

åœ¨æ°å¥½è£…æ»¡çš„è¯­ä¹‰ä¸‹ï¼ŒèƒŒåŒ…çŠ¶æ€çš„å«ä¹‰å‘ç”Ÿäº†å¾®å¦™çš„å˜åŒ–ï¼Œå³å‰ i ç§ç‰©å“åœ¨**è£…æ»¡**å®¹é‡ä¸º j çš„èƒŒåŒ…ä¸­æ‰€è·å¾—çš„æœ€å¤§ä»·å€¼ã€‚åœ¨æ™®é€šèƒŒåŒ…ä¸‹ï¼Œå¦‚æœå°šæœªè£…æ»¡ï¼Œé‚£ä¹ˆçŠ¶æ€å€¼ä¸ºæœ‰æ•ˆçš„ï¼›ä½†æ˜¯åœ¨æ°å¥½è£…æ»¡èƒŒåŒ…ä¸‹ï¼Œ**çŠ¶æ€å€¼å¿…é¡»æ˜¯æ— æ•ˆçš„**ã€‚è€Œä¸”æ— æ³•ä»æ— æ•ˆçŠ¶æ€æ¨å¯¼å‡ºæœ‰æ•ˆçŠ¶æ€

æˆ‘ä»¬ä»¥ 01 èƒŒåŒ…ä¸ºä¾‹æ¥è¯´æ˜ï¼Œåœ¨å–æœ€å¤§å€¼çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†æ— æ•ˆçŠ¶æ€å®šä¹‰ä¸º <0 çš„å€¼ï¼Œå¹¶ä¸”éƒ½åˆå§‹åŒ–ä¸º -INFï¼Œ

~~~c++
#define INF 0x80000000

for (int i = 0; i <= N; i++) {
    f[i] = INF;
}

// f[0] æ˜¯æœ‰æ•ˆçŠ¶æ€
f[0] = 0;

// åŠ¨æ€è§„åˆ’è¿‡ç¨‹
for (int i = 1; i <= N; i++) {
    for (int j = V; j >= v[i]; j--) {
        f[j] = max(f[j], f[j - v[i]] + w[i]);
        // å¤„ç† f[j] å’Œ f[j - v[i]] + w[i] éƒ½æ˜¯æ— æ•ˆçš„æƒ…å†µ
        if (f[j] < 0)
            f[j] = INF;
    }
}

// åˆ¤æ–­èƒ½å¦æ°å¥½è£…æ»¡èƒŒåŒ…
if (f[V] > 0) {
    cout << f[V] << endl;		//èƒŒåŒ…æ°å¥½è£…æ»¡äº†ï¼Œè¾“å‡ºç»“æœ
} else {
    cout << "error" << endl; 	//èƒŒåŒ…ä¸èƒ½æ°å¥½è£…æ»¡
}
~~~

#### æ±‚æ€»æ–¹æ¡ˆæ•°

è¿™ç§é—®é¢˜å°±æ˜¯å°†åŸæœ‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸­çš„ã€Œæ±‚æœ€å¤§å€¼ã€å˜ä¸ºã€Œæ±‚å’Œã€å³å¯ï¼Œè€Œä¸”æ— éœ€è€ƒè™‘ value æ•°ç»„ã€‚**æ­¤æ—¶ï¼Œå°±æŒ‰ç…§æ­£å¸¸çš„ DP æ€è·¯æ¥è€ƒè™‘å³å¯**ã€‚ä»¥æ±‚  01 èƒŒåŒ…é—®é¢˜çš„æ–¹æ¡ˆæ•°ä¸ºä¾‹ï¼Œå®ƒçš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š
$$
dp[i][w] = dp[i-1][w] + dp[i][w-weight[i-1]]
$$
ä¾‹å¦‚ï¼Œ2585 è·å¾—åˆ†æ•°çš„æ–¹æ³•æ•°ã€0879 ç›ˆåˆ©è®¡åˆ’

#### æ±‚æœ€ä¼˜æ–¹æ¡ˆæ•°

æˆ‘ä»¬è¦ç»´æŠ¤ä¸¤ä¸ªçŠ¶æ€ï¼š

- `dp[i][w]`ï¼šå‰ ğ‘– ç§ç‰©å“æ”¾å…¥ä¸€ä¸ªæœ€å¤šèƒ½è£…é‡é‡ä¸º ğ‘¤ çš„èƒŒåŒ…ä¸­ï¼Œå¯è·å¾—çš„æœ€å¤§ä»·å€¼ã€‚
- `op[i][w]`ï¼šå‰ ğ‘– ç§ç‰©å“æ”¾å…¥ä¸€ä¸ªæœ€å¤šèƒ½è£…é‡é‡ä¸º ğ‘¤ çš„èƒŒåŒ…ä¸­ï¼Œä½¿èƒŒåŒ…æ€»ä»·å€¼æœ€å¤§çš„æ–¹æ¡ˆæ•°ã€‚

çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š

~~~python
# é€‰æ‹©ç¬¬ i - 1 ä»¶ç‰©å“è·å¾—ä»·å€¼æ›´é«˜
if dp[i - 1][w] < dp[i - 1][w - weight[i - 1]] + value[i - 1]:
    dp[i][w] = dp[i - 1][w - weight[i - 1]] + value[i - 1]
    
    # åœ¨ä¹‹å‰æ–¹æ¡ˆåŸºç¡€ä¸Šæ·»åŠ äº†ç¬¬ i - 1 ä»¶ç‰©å“ï¼Œå› æ­¤æ–¹æ¡ˆæ•°é‡ä¸å˜
    op[i][w] = op[i - 1][w - weight[i - 1]]
    
# ä¸¤ç§æ–¹å¼è·å¾—ä»·æ ¼ç›¸ç­‰
elif dp[i - 1][w] == dp[i - 1][w - weight[i - 1]] + value[i - 1]:
    dp[i][w] = dp[i - 1][w]
    # æ–¹æ¡ˆæ•° = ä¸ä½¿ç”¨ç¬¬ i - 1 ä»¶ç‰©å“çš„æ–¹æ¡ˆæ•° + ä½¿ç”¨ç¬¬ i - 1 ä»¶ç‰©å“çš„æ–¹æ¡ˆæ•°
    op[i][w] = op[i - 1][w] + op[i - 1][w - weight[i - 1]]
    # ä¸é€‰æ‹©ç¬¬ i - 1 ä»¶ç‰©å“è·å¾—ä»·å€¼æœ€é«˜
    
else:
    dp[i][w] = dp[i - 1][w]
    # ä¸é€‰æ‹©ç¬¬ i - 1 ä»¶ç‰©å“ï¼Œä¸ä¹‹å‰æ–¹æ¡ˆæ•°ç›¸ç­‰
    op[i][w] = op[i - 1][w]
~~~



## æ ‘å½¢ DP

ç®€ç§°ä¸ºã€Œæ ‘å½¢ DPã€ï¼Œæ˜¯ä¸€ç§åœ¨æ ‘å½¢ç»“æ„ä¸Šè¿›è¡Œæ¨å¯¼çš„åŠ¨æ€è§„åˆ’æ–¹æ³•ã€‚

![æ ‘å½¢ DP](./assets/20240514113355.png)

å¤§éƒ¨åˆ†æ ‘å½¢ DP éƒ½æ˜¯é‡‡ç”¨ã€Œè‡ªåº•å‘ä¸Šã€çš„æ–¹å‘è¿›è¡Œæ¨å¯¼ã€‚å¦‚æœæ ‘å½¢ DP æŒ‰ç…§ã€Œæ˜¯å¦æœ‰å›ºå®šæ ¹ã€è¿›è¡Œåˆ’åˆ†ï¼Œå¯ä»¥åˆ’åˆ†ä¸ºä»¥ä¸‹ä¸¤ç§ç±»å‹ï¼š

1. **å›ºå®šæ ¹çš„æ ‘å½¢ DP**ï¼šäº‹å…ˆæŒ‡å®šæ ¹èŠ‚ç‚¹çš„æ ‘å½¢ DP é—®é¢˜ï¼Œé€šå¸¸åªéœ€è¦ä»ç»™å®šçš„æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œä½¿ç”¨ 1 æ¬¡æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆå…ˆåºã€ä¸­åºã€ååºï¼‰ã€‚

2. **ä¸å®šæ ¹çš„æ ‘å½¢ DP**ï¼šäº‹å…ˆæ²¡æœ‰æŒ‡å®šæ ¹èŠ‚ç‚¹çš„æ ‘å½¢ DP é—®é¢˜ï¼Œå¹¶ä¸”æ ¹èŠ‚ç‚¹çš„å˜åŒ–ä¼šå¯¹ä¸€äº›å€¼ï¼Œä¾‹å¦‚å­èŠ‚ç‚¹æ·±åº¦å’Œã€ç‚¹æƒå’Œç­‰äº§ç”Ÿå½±å“ã€‚é€šå¸¸éœ€è¦ä½¿ç”¨ 2 æ¬¡æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œç¬¬ 1 æ¬¡é¢„å¤„ç†è¯¸å¦‚æ·±åº¦ï¼Œç‚¹æƒå’Œä¹‹ç±»çš„ä¿¡æ¯ï¼Œç¬¬ 2 æ¬¡å¼€å§‹è¿è¡Œ**æ¢æ ¹åŠ¨æ€è§„åˆ’**ã€‚

   è¿™é‡Œçš„æ ¸å¿ƒæ“ä½œå°±æ˜¯æ¢æ ¹ï¼Œåœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œæ ¹æ®ç¬¬ä¸€æ¬¡è·å–çš„é¢„å¤„ç†ä¿¡æ¯ï¼Œå¤„ç†æ¢æ ¹çš„åŠ¨æ€è§„åˆ’ä¿¡æ¯ã€‚å¹¶ä¸”è¦ä¸æ–­æ‰§è¡Œä¸€äº›é€†æ“ä½œï¼Œæ¥æ›´æ–°é¢„å¤„ç†ä¿¡æ¯ã€‚

### ç›¸é‚»å­—ç¬¦ä¸åŒçš„æœ€é•¿è·¯å¾„

ç»™ä½ ä¸€æ£µ**æ ‘**ï¼ˆå³ä¸€ä¸ªè¿é€šã€æ— å‘ã€æ— ç¯å›¾ï¼‰ï¼Œæ ¹èŠ‚ç‚¹æ˜¯èŠ‚ç‚¹ `0` ï¼Œè¿™æ£µæ ‘ç”±ç¼–å·ä» `0` åˆ° `n - 1` çš„ `n` ä¸ªèŠ‚ç‚¹ç»„æˆã€‚ç”¨ä¸‹æ ‡ä» **0** å¼€å§‹ã€é•¿åº¦ä¸º `n` çš„æ•°ç»„ `parent` æ¥è¡¨ç¤ºè¿™æ£µæ ‘ï¼Œå…¶ä¸­ `parent[i]` æ˜¯èŠ‚ç‚¹ `i` çš„çˆ¶èŠ‚ç‚¹ï¼Œç”±äºèŠ‚ç‚¹ `0` æ˜¯æ ¹èŠ‚ç‚¹ï¼Œæ‰€ä»¥ `parent[0] == -1` ã€‚å¦ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² `s` ï¼Œé•¿åº¦ä¹Ÿæ˜¯ `n` ï¼Œå…¶ä¸­ `s[i]` è¡¨ç¤ºåˆ†é…ç»™èŠ‚ç‚¹ `i` çš„å­—ç¬¦ã€‚è¯·ä½ æ‰¾å‡ºè·¯å¾„ä¸Šä»»æ„ä¸€å¯¹ç›¸é‚»èŠ‚ç‚¹éƒ½æ²¡æœ‰åˆ†é…åˆ°ç›¸åŒå­—ç¬¦çš„ **æœ€é•¿è·¯å¾„** ï¼Œå¹¶è¿”å›è¯¥è·¯å¾„çš„é•¿åº¦ã€‚

~~~go
type _TreeNode struct {
	children [](*_TreeNode)
	str      byte
}

func NewTreeNode(str byte) *_TreeNode {
	return &_TreeNode{make([]*_TreeNode, 0), str}
}
func longestPath(parent []int, s string) int {
	table := map[int]*_TreeNode{}
	var root *_TreeNode = NewTreeNode(s[0])
	table[0] = root
	for i, v := range parent {
		if i == 0 {
			continue
		}
		if _, ok := table[v]; !ok {
			table[v] = NewTreeNode(s[v])
		}
		if _, ok := table[i]; !ok {
			table[i] = NewTreeNode(s[i])
		}
		table[v].children = append(table[v].children, table[i])
	}

	ans := 1
	var dfs func(node *_TreeNode) int
	dfs = func(node *_TreeNode) int {
		if node == nil {
			return 0
		}
        // ç»´æŠ¤ç¬¬ä¸€å¤§ä¸ç¬¬äºŒå¤§
		first, second := 0, 0
		for _, v := range node.children {
            tmp := dfs(v)
			if node.str != v.str {
				if tmp > first {
					second = first
					first = tmp
				} else if tmp > second {
					second = tmp
				}
			}
			ans = max(ans, first+second+1)
		}
		return first + 1
	}
	dfs(root)
	return ans
}
~~~

### æœ€å¤§ä»·å€¼å’Œä¸æœ€å°ä»·å€¼å’Œçš„å·®å€¼

ç»™ä½ ä¸€ä¸ª `n` ä¸ªèŠ‚ç‚¹çš„æ— å‘æ— æ ¹å›¾ï¼ŒèŠ‚ç‚¹ç¼–å·ä¸º `0` åˆ° `n - 1` ã€‚ç»™ä½ ä¸€ä¸ªæ•´æ•° `n` å’Œä¸€ä¸ªé•¿åº¦ä¸º `n - 1` çš„äºŒç»´æ•´æ•°æ•°ç»„ `edges` ï¼Œå…¶ä¸­ `edges[i] = [ai, bi]` è¡¨ç¤ºæ ‘ä¸­èŠ‚ç‚¹ `ai` å’Œ `bi` ä¹‹é—´æœ‰ä¸€æ¡è¾¹ã€‚æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªä»·å€¼ã€‚ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `price` ï¼Œå…¶ä¸­ `price[i]` æ˜¯ç¬¬ `i` ä¸ªèŠ‚ç‚¹çš„ä»·å€¼ã€‚ä¸€æ¡è·¯å¾„çš„ **ä»·å€¼å’Œ** æ˜¯è¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„ä»·å€¼ä¹‹å’Œã€‚ä½ å¯ä»¥é€‰æ‹©æ ‘ä¸­ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹ `root` ã€‚é€‰æ‹© `root` ä¸ºæ ¹çš„ **å¼€é”€** æ˜¯ä»¥ `root` ä¸ºèµ·ç‚¹çš„æ‰€æœ‰è·¯å¾„ä¸­ï¼Œ**ä»·å€¼å’Œ** æœ€å¤§çš„ä¸€æ¡è·¯å¾„ä¸æœ€å°çš„ä¸€æ¡è·¯å¾„çš„å·®å€¼ã€‚è¯·ä½ è¿”å›æ‰€æœ‰èŠ‚ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹çš„é€‰æ‹©ä¸­ï¼Œ**æœ€å¤§** çš„ **å¼€é”€** ä¸ºå¤šå°‘ã€‚

![img](./assets/example14.png)

å·¦å›¾ï¼ˆçº¢è‰²çš„èŠ‚ç‚¹ï¼‰æ˜¯æœ€å¤§ä»·å€¼å’Œè·¯å¾„ï¼Œå³å›¾ï¼ˆè“è‰²çš„èŠ‚ç‚¹ï¼‰æ˜¯æœ€å°ä»·å€¼å’Œè·¯å¾„ã€‚

~~~go
func maxOutput(n int, edges [][]int, price []int) int64 {
	graph := make([][]int, n)

	for i, _ := range graph {
		graph[i] = []int{}
	}
    
	for _, v := range edges {
		u, v := v[0], v[1]
		graph[u] = append(graph[u], v)
        graph[v] = append(graph[v], u)
	}

	maxPath := make([]int, n)
	dp := make([]int, n)

	var dfs1 func(u, p int) int
	dfs1 = func(u, p int) int {
		maxSum := 0
		for _, v := range graph[u] {
			if v == p {
				continue
			}
			maxSum = max(maxSum, dfs1(v, u))
		}
		maxPath[u] = maxSum + price[u]
		return maxPath[u]
	}

	var dfs2 func(u, p int)
	dfs2 = func(u, p int) {
		// å…ˆå¤„ç† DP
		maxSum1, maxSum2 := 0, 0
		for _, v := range graph[u] {
			if maxPath[v] > maxSum1 {
				maxSum1, maxSum2 = maxPath[v], maxSum1
			} else if maxPath[v] > maxSum2 {
				maxSum2 = maxPath[v]
			}
		}
		dp[u] = maxSum1 + price[u]

		// æ¢æ ¹
		for _, v := range graph[u] {
			if v == p {
				continue
			}
			// æ›´æ–°ç¬¬ä¸€æ¬¡è·å–çš„é¢„å¤„ç†ä¿¡æ¯
			if maxPath[v] != maxSum1 {
				maxPath[u] = maxSum1
			} else {
                // æ¢æ ¹æ­£å¥½æ˜¯ u çš„æœ€é•¿è·¯å¾„ï¼Œæ­¤æ—¶æ›´æ–°
				maxPath[u] = maxSum2
			}
            maxPath[u] += price[u]
			dfs2(v, u)
		}
	}
	dfs1(0, -1)
	dfs2(0, -1)

	ans := 0
	for i, v := range dp {
		ans = max(ans, v-price[i])
	}
	return int64(ans)
}
~~~

## çŠ¶æ€å‹ç¼© DP

åœ¨çŠ¶å‹ DP ä¸­ï¼Œæˆ‘ä»¬é€šå¸¸é‡‡ç”¨äºŒè¿›åˆ¶æ•°çš„å½¢å¼æ¥è¡¨ç¤ºä¸€ç»´çŠ¶æ€ã€‚äºŒè¿›åˆ¶æ•°çš„æ¯ä¸€ä¸ªäºŒè¿›ä½ï¼Œéƒ½å¯¹åº”äº†é›†åˆä¸­æŸä¸€ä¸ªå…ƒç´ çš„é€‰å–çŠ¶æ€ã€‚çŠ¶å‹ DP çš„çŠ¶æ€è½¬ç§»æ–¹å¼æœ‰ä¸¤ç§ï¼š

1. æšä¸¾å­é›†ï¼šå¯¹äºä¸€ä¸ªçŠ¶æ€ï¼Œæšä¸¾å®ƒçš„æ‰€æœ‰å­é›†ï¼Œæ‰¾åˆ°æ¯”å½“å‰çŠ¶æ€å°‘é€‰ä¸€ä¸ªå…ƒç´ çš„å­é›†ã€‚ç„¶åæ ¹æ®å­é›†çš„å€¼å’ŒçŠ¶æ€ä¹‹é—´çš„å…³ç³»ï¼Œæ›´æ–°å½“å‰çŠ¶æ€çš„å€¼ã€‚
2. æšä¸¾è¶…é›†ï¼šå¯¹äºä¸€ä¸ªçŠ¶æ€ï¼Œæšä¸¾å®ƒçš„æ‰€æœ‰è¶…é›†ã€‚ç„¶åæ ¹æ®è¶…é›†çš„å€¼å’ŒçŠ¶æ€ä¹‹é—´çš„å…³ç³»ï¼Œæ›´æ–°å½“å‰çŠ¶æ€çš„å€¼ã€‚

 DP åªé€‚ç”¨äºæ±‚è§£å°æ•°æ®è§„æ¨¡é—®é¢˜ï¼ˆé€šå¸¸ ğ‘›â‰¤20ï¼‰

è®¾ n ä¸ºé›†åˆä¸­å…ƒç´ çš„ä¸ªæ•°ï¼ŒAï¼ŒB ä¸ºä¸¤ä¸ªé›†åˆå¯¹åº”çš„äºŒè¿›åˆ¶æ•°ï¼Œi è¡¨ç¤ºæŸä¸ªå…ƒç´ çš„ä½ç½®ï¼Œé‚£ä¹ˆæœ‰ï¼š

- æ€»çŠ¶æ€æ•°é‡ï¼š`1 << n`

- åœ¨é›†åˆ A ä¸­åŠ å…¥ç¬¬ i ä½å…ƒç´ ï¼š`A = A | (1 << i)`

- åœ¨é›†åˆ A ä¸­åˆ é™¤ç¬¬ i ä½å…ƒç´ ï¼š`A & ~ï¼ˆ1 << iï¼‰`    `A = A ^ (1 <)`

- åˆ¤æ–­é›†åˆ A æ˜¯å¦é€‰å–äº†ç¬¬ i ä½å…ƒç´ ï¼š`(A & (1 << i)) > 0`

- æ±‚é›†åˆ A çš„è¡¥é›†ï¼š`A = A ^ ((1 << n) - 1)`

- æ±‚é›†åˆ A ä¸é›†åˆ B çš„å¹¶é›†ï¼š`A|B`

- æ±‚é›†åˆ A ä¸é›†åˆ B çš„äº¤é›†ï¼š`A & B`

- æšä¸¾é›†åˆ A çš„å­é›†

  ~~~go
  subA := A
  for subA > 0 {
      //...
      subA = (subA - 1) & A
  }
  ~~~

- æšä¸¾å…¨é›†çš„æ‰€æœ‰å­é›†ï¼š

  ~~~python
  for state in range(1 << n):		# state ä¸ºå­é›†
      for i in range(n):			# æšä¸¾ç¬¬ i ä½å…ƒç´ 
          if (state >> i) & 1:	# å¦‚æœç¬¬ i ä½å…ƒç´ å¯¹åº”äºŒè¿›åˆ¶ä½ 1ï¼Œåˆ™è¡¨ç¤ºé›†åˆä¸­é€‰å–äº†è¯¥å…ƒç´ 
              ...
  ~~~

  

### ä¸¤ä¸ªæ•°ç»„æœ€å°çš„å¼‚æˆ–å€¼ä¹‹å’Œ

~~~go
func minimumXORSum(nums1 []int, nums2 []int) int {
	n := len(nums1)
	states := 1 << n
	dp := make([]int, states)
	for i := 0; i < states; i++ {
		dp[i] = 0x03f3f3f3f
	}
	dp[0] = 0
	// states è¡¨ç¤ºå…¨é›†ï¼Œå³é€‰æ‹©å…¨éƒ¨åœ¨ nums2 ä¸­çš„å…ƒç´ 
	// è€Œ state è¡¨ç¤º states çš„ä¸€ä¸ªå­é›†
	for state := 1; state < states; state++ {
		// ç»Ÿè®¡ 1 çš„ä¸ªæ•°
		numOf1 := getNumOf1(state)
		for i := 0; i < n; i++ {
			// å¦‚æœé€‰å–äº†åœ¨ nums2 ä¸­çš„ç¬¬ i ä¸ªå…ƒç´ 
			if (state>>i)&1 == 1 {
				// state ^ (1 << i) è¡¨ç¤ºä¸€ä¸ª state çš„å­é›†ï¼ˆæ³¨æ„ if è¯­å¥å‰æï¼‰ï¼Œè¯¥å­é›†å‰”é™¤äº†ç¬¬ i ä¸ªå…ƒç´ 
				dp[state] = min(dp[state], dp[state^(1<<i)]+(nums1[numOf1-1]^nums2[i]))
			}
		}
	}
	return dp[states-1]
}

func getNumOf1(m int) int {
	count := 0
	for m > 0 {
		// é€šè¿‡å‡æ³•çš„å€Ÿä½æ¥æ¶ˆé™¤ç¬¬ä¸€ä¸ª 1
		m = m & (m - 1)
		count++
	}
	return count
}
~~~

### æ•°ç»„çš„æœ€å¤§ä¸å’Œ

~~~go
func maximumANDSum(nums []int, numSlots int) int {
	n := len(nums)
    // å°† n ä¸ªç¯®å­æ‰©å±•åˆ° 2 * n ä¸ªç¯®å­
	states := 1 << (2 * numSlots)
	dp := make([]int, states)
	ans := 0
	for state := 1; state < states; state++ {
		numOf1 := getNumOf1(state)
		if numOf1 > n {
			continue
		}
		for i := 0; i < 2*numSlots; i++ {
			if (state>>i)&1 == 1 {
				dp[state] = max(dp[state], dp[state^(1<<i)]+(nums[numOf1-1]&(i/2+1)))
			}
		}
		ans = max(ans, dp[state])
	}
	return ans
}

~~~

## è®¡æ•° DP

å¡ç‰¹å…°æ•°çš„é€’æ¨å¼ä¸ºï¼š
$$
H_n = \sum^{n-1}_{i=0}H_iH_{n-i-1}
$$
å¯ä»¥ç®€åŒ–ä¸º
$$
H_n = \frac{H_{n-1}(4n-2)}{n+1}
$$

å…¶å¯¹åº”çš„åºåˆ—ä¸ºï¼š

|  H0  |  H1  |  H2  |  H3  |  H4  |  H5  |  H6  | ...  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  1   |  2   |  5   |  14  |  42  | 132  | ...  |



**å¶æ•°** ä¸ªäººç«™æˆä¸€ä¸ªåœ†ï¼Œæ€»äººæ•°ä¸º `num_people` ã€‚æ¯ä¸ªäººä¸é™¤è‡ªå·±å¤–çš„ä¸€ä¸ªäººæ¡æ‰‹ï¼Œæ‰€ä»¥æ€»å…±ä¼šæœ‰ `num_people / 2` æ¬¡æ¡æ‰‹ã€‚å°†æ¡æ‰‹çš„äººä¹‹é—´è¿çº¿ï¼Œè¯·ä½ è¿”å›è¿çº¿ä¸ä¼šç›¸äº¤çš„æ¡æ‰‹æ–¹æ¡ˆæ•°ã€‚ç”±äºç»“æœå¯èƒ½ä¼šå¾ˆå¤§ï¼Œè¯·ä½ è¿”å›ç­”æ¡ˆ **æ¨¡** **`10^9+7`** åçš„ç»“æœã€‚

~~~go
func numberOfWays(numPeople int) int {
    // dp[i] è¡¨ç¤º i æ¬¡æ¡æ‰‹çš„ä¸ç›¸äº¤æ¡æ‰‹æ–¹æ¡ˆæ•°ã€‚
	dp := make([]int, numPeople/2+1)
	dp[0], dp[1] = 1, 1
	const MODULO int = 1e9 + 7
	for i := 2; i <= numPeople/2; i++ {
		for j := 0; j < i; j++ {
            // è€ƒè™‘æœ€åä¸€ä¸ªäººä¸å¦ä¸€ä¸ªäººçš„æ¡æ‰‹ï¼Œä¸¤ä¸ªæ¡æ‰‹çš„äººä¹‹é—´çš„è¿çº¿å°†å…¶ä½™çš„äººåˆ†æˆä¸¤éƒ¨åˆ†
            // å¦‚æœç¬¬ä¸€éƒ¨åˆ†çš„æ¡æ‰‹æ¬¡æ•°æ˜¯ j ä¸”ç¬¬äºŒéƒ¨åˆ†çš„æ¡æ‰‹æ¬¡æ•°æ˜¯ iâˆ’jâˆ’1ï¼Œåˆ™æ­¤æ—¶çš„ä¸ç›¸äº¤æ¡æ‰‹æ–¹æ¡ˆæ•°æ˜¯ dp[j]Ã—dp[iâˆ’jâˆ’1]
			dp[i] = (dp[i] + dp[j]*dp[i-j-1]) % MODULO
		}
	}
	return dp[numPeople/2]
}

~~~

## æ•°ä½ DP

DP ç”¨äºè§£å†³æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„æ•°å€¼ä¸ªæ•°ï¼Œæˆ–è€…æ±‚è§£æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„ç¬¬ ğ‘˜ å°çš„æ•°ã€‚

é¢˜ç›®è¦æ±‚ä¸€æ®µåŒºé—´  `[left, right - 1]` å†…æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„æ•°å€¼ä¸ªæ•°ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ã€Œå‰ç¼€å’Œã€æ€æƒ³ï¼Œåˆ†åˆ«è®¡ç®—å‡ºåŒºé—´ `[0, left - 1]` ä¸åŒºé—´ `[0, right]` å†…æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„æ•°å€¼ä¸ªæ•°ï¼Œç„¶åå°†ä¸¤è€…ç›¸å‡å³ä¸ºæ‰€æ±‚ç­”æ¡ˆã€‚

ç„¶åä½¿ç”¨æ•°ä½ DP ç­–ç•¥ï¼Œå³å°†åŒºé—´æ•°å­—æ‹†åˆ†ä¸ºæ•°ä½ï¼Œç„¶åé€ä½è¿›è¡Œç¡®å®šã€‚å› ä¸ºæ•°ä½ DP ä¸­éœ€è¦è€ƒè™‘çš„å‚æ•°æœ‰ï¼š

- posï¼šå½“å‰æ‰€æšä¸¾æ•°ä½çš„ä½ç½®
- totalï¼šå‰ä¸€ä½æ•°ä½ï¼ˆæˆ–å‰å‡ ä½æ•°ä½ï¼‰çš„æƒ…å†µ
- cntï¼šæŸä¸ªæ•°å­—å‡ºç°æ¬¡æ•°
- stateï¼šå‰å‡ ä½æ‰€é€‰æ•°å­—é›†åˆ
- isLimitï¼šè¡¨ç¤ºæ˜¯å¦å—åˆ°é€‰æ‹©é™åˆ¶ã€‚å¦‚æœä¸ºå‡ï¼Œåˆ™æœ€å¤§å¯ä¸º 9ã€‚
  - minXï¼šå½“å‰ä½æ•°ä½æ‰€èƒ½é€‰æ‹©çš„æœ€å°æ•°å­—
  - maxXï¼šæ‰€èƒ½é€‰æ‹©çš„æœ€å¤§æ•°å­—
- isNumï¼šè¡¨ç¤º pos å‰é¢çš„æ•°ä½æ˜¯å¦å¡«äº†æ•°å­—ã€‚å¦‚æœä¸ºçœŸï¼Œåˆ™å½“å‰ä½ä¸å¯è·³è¿‡ï¼›å¦‚æœä¸ºå‡ï¼Œåˆ™å½“å‰ä½å¯è·³è¿‡ã€‚

è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ã€Œè®°å¿†åŒ–æœç´¢ã€ï¼Œæ¥æ›´åŠ æ–¹ä¾¿åœ°å¤„ç†è¿™äº›å‚æ•°

