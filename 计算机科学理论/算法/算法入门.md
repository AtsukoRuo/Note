[TOC]

## 贪心

贪心算法的正确性由两个性质保证

- **贪心选择性质**：原问题的整体最优解可以通过一系列局部最优的选择得到
- **最优子结构性质**：一个问题的最优解包含其子问题的最优解

贪心算法的求解步骤如下：

- 确定贪心策略
- 根据贪心策略，一步步地得到局部最优解
- 把所有的局部最优解组合成原问题的一个最优解



## 分治

使用分治算法需要满足以下三个条件

- 原问题可被分解为若干规模较小的、性质相同的子问题；
- 子问题相互独立
- 子问题的解可以合并为原问题的解



## STL

在STL中，但凡涉及到区间的，都是左闭右开。

### Vector

~~~c++
vector<int> a;								// 空的vector
vector<int> a(100);							// 元素个数为100，初值都为0
vector<int> a(10, 666);						// 元素个数为10，初值都为666
vector<int> b(a);							
vector<int> b(a.begin() + 3, a.end() - 3);
vector<int> v = {1, 2, 3, 4, 5};			// 列表初始化
~~~

~~~c++
a.push_back(5)							// 向vector尾部插入5
a.insert(a.begin() + 1, 10)				// 向vector头部插入10
a.insert(a.begin() + 1, 5, 10)			// 向vector头部插入5个10
~~~

~~~c++
a.pop_back()
a.erase(a.begin() + 1)
~~~

~~~c++
a.resize(5)
~~~

resize可以改变当前向量的大小，如果它比当前向量大，则填充默认值；如果比当前向量小，则舍弃后面的部分。

### List

~~~c++
list<int> a; // 定义一个int类型的列表a
list<int> a(10); // 定义一个int类型的列表a，并设置初始大小为10
list<int> a(10, 1); // 定义一个int类型的列表a，并设置初始大小为10且初始值都为1
list<int> a {1, 2};	// 列表初始化
~~~

- 头部添加元素：`lst.push_front(const T& x);`
- 末尾添加元素：`lst.push_back(const T& x);`
- 在指定位置前面，插入一个元素：`lst.insert(iterator it, const T& x);`
- 在指定位置前面，插入 n 个相同元素：`lst.insert(iterator it, int n, const T& x);`
- 在指定位置前面，插入另一个向量的 [forst,last] 间的数据：`lst.insert(iterator it, iterator first, iterator last);`



- 头部删除元素：`lst.pop_front();`
- 末尾删除元素：`lst.pop_back();`
- 任意位置删除一个元素：`lst.erase(iterator it);`
- 删除 [first,last] 之间的元素：`lst.erase(iterator first, iterator last);`
- 清空所有元素：`lst.clear();`



- 访问第一个元素：`lst.front();`
- 访问最后一个元素：`lst.back();`



### Stack

Stack的方法：

- push(x)：x 入栈
- pop()：出栈
- top()：取栈顶（未出栈）
- empty()：判断栈是否为空，若为空则返回true
- size()：求栈大小，返回栈中的元素个数。

### Queue

Queue的方法：

- push(x)：x 入队
- pop()：出队
- front()：取队头（未出队）
- empty()：判断队列是否为空，若为空，则返回true
- size()：求队列大小，返回队列中的元素个数

### priority_queue

Priority_queue的方法：

- push(x)：x 入队
- pop()：出队
- top()：取队头
- size()：返回队中的元素个数
- empty()：判断队空，若为空则返回true



~~~c++
#include <queue>
std::priority_queue<int> pq;


std::vector<int> vec = {1, 8, 5, 6, 3, 4, 0, 9, 7, 2};
std::priority_queue<int> pq2(vec.begin(), vec.end());
~~~



### Bitset

bitset的方法：

- count()：统计有多少位是1
- set()：将所有位置1
- set(k)：将第k位置1
- set(k ,val)：将第k位的值改为val，即s [k]=val
- reset(k)：将第k位置0
- reset()：将所有位置0
- flip(k)：将第k位取反
- flip()：将所有位取反
- to_ulong()
- to_string()

~~~c++
bitset<1000> s;		// 定义一个1000位的二进制数s
s[0] = 1;			// 将最低有效位设置为1
~~~

### Set

set是有序集合（键是唯一的）

### Map

map是哈希表（键是唯一的）

~~~c++
// 创建一个map
std::map<std::string, int> mymap;

// 向map中插入键值对
mymap["apple"] = 50;
mymap.insert(std::pair<std::string, int>("apple", 50));
mymap.insert(std::make_pair("apple", 50));

// 访问
mymap["apple"]
    
// 遍历 
for(auto it = mymap.begin(); it != mymap.end(); ++it) {
    std::cout << it->first << " => " << it->second << '\n';
}

~~~

### Pair

~~~c++
std::pair<int, int> p1;
std::pair<int, int> p2(10, 20);
std::pair<int, int> p3 = {30, 40};
auto p4 = std::make_pair(50, 60);
std::cout << "p2: " << p2.first << ", " << p2.second << std::endl;
~~~



## Algorithm

查找算法

```cpp
std::vector<int> v = {1, 2, 4, 8, 16, 32};

auto result = std::find_if(v.begin(), v.end(), [](int i){ return i > 10; });

if (result != v.end()) {
    std::cout << "第一个大于10的数是 " << *result << '\n';
} else {
    std::cout << "没有大于10的数\n";
}
```



遍历

~~~c++
std::vector<int> nums = {1, 2, 3, 4, 5, 6};

std::for_each(nums.begin(), nums.end(), [](int& num) {
    num *= 2;  // 倍增每个元素
});

for(const auto & num : nums) {
    std::cout << num << " ";  // 输出： 2 4 6 8 10 12
}
~~~



生成器

~~~c++
std::vector<int> vec(10); // 创建一个包含10个元素的空白向量

int value = 0; 
std::generate(vec.begin(), vec.end(), [&value] { return ++value; }); 

for(int n : vec)
    std::cout << n << ' '; // 输出每个元素
~~~



## Lambda

~~~dart
auto plus = [] (int v1, int v2) -> int { return v1 + v2; }

plus();
~~~

Labmda有以下部分组成：

- **captures** 捕获列表，lambda可以把上下文变量以值或引用的方式捕获，在body中直接使用。
  - **[]** 什么也不捕获
  - **[=]** 按值的方式捕获所有变量
  - **[&]** 按引用的方式捕获所有变量
  - **[=, &a]** 除了变量a之外，按值的方式捕获所有局部变量，而变量a使用引用的方式来捕获
  - ...

编译器实际上将`Lambda`表达式翻译为一个重载()运算符的类，并进行调用。



## 结构体

~~~c
// 定义结构体，并初始化结构体变量
struct Init {
	int a;
	double b;
	char *c;
	float d;
} id1 = {1,2.0,"hello"},id2[2],*id;
~~~



~~~c
// 命名赋值
struct Init id2 = {
	id2.a = -1,
	.c = "hello",
	.b = 4.0
};
~~~



## 初始化

~~~c++
// 复制初始化
int i = 0;
int i = {0};
// 等价于，编译器会做优化
int temp = 0;
int i = temp;

// 直接初始化
int i {0};
int i (0);
~~~

- 复制初始化不支持explicit的构造函数
- 编译器可以优化复制初始化中额外的操作

在C++11中，将数组或结构体的列表初始化推广到更一般的场景。



注意，重载operator =只涉及赋值操作，并不考虑初始化操作

匿名初始化

~~~c++
class Cat {}

//
Cat {}
Cat ()
~~~

下面这段代码涉及到匿名初始化以及复制初始化，但是编译器会对此做出优化，变成直接初始化

~~~c++
int i = int {1}
~~~



`std::initializer_list<int> list`参数也需要`{}`语法，但是`list`参数的优先级比多个相同类型的参数高

~~~c
class Cat {
    public:
    // 接受初始化列表的构造函数
    Cat(std::initializer_list<int> list) {
    	cout << 2;
    }
    Cat(int i, int k) {
    	cout << 1;
    }
};

Cat cat (1, 2); 	// 1
Cat {1, 2}			// 2
Cat cat = {1, 2} 	// 2
~~~



