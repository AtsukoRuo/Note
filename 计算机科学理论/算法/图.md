# å›¾

[TOC]

## æ¦‚å¿µ

å›¾å¯ä»¥è¡¨ç¤ºä»»æ„çš„äºŒå…ƒå…³ç³»ï¼Œå› æ­¤å®ƒå±äº**éçº¿æ€§ç»“æ„ï¼ˆnon-linear structureï¼‰**ã€‚

**å›¾ï¼ˆgraphï¼‰**ï¼Œå¯å®šä¹‰ä¸º G = (V, E)ã€‚å…¶ä¸­ï¼Œé›†åˆ V ä¸­çš„å…ƒç´ ç§°ä½œ**é¡¶ç‚¹ï¼ˆvertexï¼‰**ï¼›é›†åˆ E ä¸­çš„å…ƒç´ åˆ†åˆ«å¯¹åº”äº V ä¸­çš„æŸä¸€å¯¹é¡¶ç‚¹ (u, v)ï¼Œè¡¨ç¤ºå®ƒä»¬ä¹‹é—´å­˜åœ¨æŸç§å…³ç³»ï¼Œæ•…äº¦ç§°ä½œ**è¾¹ï¼ˆedgeï¼‰**ã€‚ä»è®¡ç®—çš„éœ€æ±‚å‡ºå‘ï¼Œæˆ‘ä»¬çº¦å®š V å’Œ E å‡ä¸ºæœ‰é™é›†ï¼Œé€šå¸¸å°†å…¶è§„æ¨¡åˆ†åˆ«è®° n = |V| å’Œ e = |E| ã€‚

è‹¥æˆ‘ä»¬å¹¶ä¸å…³å¿ƒè¾¹ (u, v) æ‰€å¯¹åº”é¡¶ç‚¹ u å’Œ v çš„æ¬¡åºï¼Œåˆ™ç§°ä½œ**æ— å‘è¾¹ï¼ˆundirected edgeï¼‰**åä¹‹è‹¥ u å’Œ v ä¸å¯¹ç­‰ï¼Œåˆ™ç§°**(u, v)ä¸ºæœ‰å‘è¾¹ï¼ˆdirected edgeï¼‰**ã€‚æœ‰å‘è¾¹ (u, v)ä» u æŒ‡å‘ vï¼Œå…¶ä¸­ u ç§°ä½œè¯¥è¾¹çš„**èµ·ç‚¹ï¼ˆoriginï¼‰**æˆ–å°¾é¡¶ç‚¹ï¼ˆtailï¼‰ï¼Œè€Œ v ç§°ä½œè¯¥è¾¹çš„**ç»ˆç‚¹ï¼ˆdestinationï¼‰**æˆ–å¤´é¡¶ç‚¹ï¼ˆheadï¼‰ã€‚

è‹¥ E ä¸­å„è¾¹å‡æ— æ–¹å‘ï¼Œåˆ™ G ç§°ä½œ**æ— å‘å›¾ï¼ˆundirected graphï¼Œç®€ç§°undigraphï¼‰**ã€‚è‹¥Eä¸­åªå«æœ‰å‘è¾¹ï¼Œåˆ™ G ç§°ä½œ**æœ‰å‘å›¾ï¼ˆdirected graphï¼Œç®€ç§°digraphï¼‰**ã€‚è‹¥ E åŒæ—¶åŒ…å«æ— å‘è¾¹å’Œæœ‰å‘è¾¹ï¼Œåˆ™Gç§°ä½œ**æ··åˆå›¾ï¼ˆmixed graphï¼‰**ã€‚ç›¸å¯¹è€Œè¨€ï¼Œæœ‰å‘å›¾çš„é€šç”¨æ€§æ›´å¼ºï¼Œå› ä¸ºæ— å‘å›¾å’Œæ··åˆå›¾éƒ½å¯è½¬åŒ–ä¸ºæœ‰å‘å›¾ã€‚

![image-20230822152147758](./assets/image-20230822152147758.png)

ä»»ä½•è¾¹ e = (u, v)ï¼Œç§°é¡¶ç‚¹ u å’Œ v å½¼æ­¤**é‚»æ¥ï¼ˆadjacentï¼‰**ï¼Œäº’ä¸ºé‚»å±…ï¼›è€Œå®ƒä»¬éƒ½ä¸è¾¹ e å½¼æ­¤**å…³è”ï¼ˆincidentï¼‰**ã€‚åœ¨æ— å‘å›¾ä¸­ï¼Œä¸é¡¶ç‚¹ v å…³è”çš„è¾¹æ•°ï¼Œç§°ä½œ v çš„**åº¦æ•°ï¼ˆdegreeï¼‰**ï¼Œè®°ä½œ deg(v)ã€‚

å¯¹äºæœ‰å‘è¾¹ e = (u, v)ï¼Œe ç§°ä½œ u çš„**å‡ºè¾¹ï¼ˆoutgoing edgeï¼‰**ã€v çš„**å…¥è¾¹ï¼ˆincoming edgeï¼‰**ã€‚v çš„å‡ºè¾¹æ€»æ•°ç§°ä½œå…¶**å‡ºåº¦ï¼ˆout-degreeï¼‰**ï¼Œè®°ä½œ outdeg(v)ï¼›å…¥è¾¹æ€»æ•°ç§°ä½œå…¶**å…¥åº¦ï¼ˆin-degreeï¼‰**ï¼Œè®°ä½œ indeg(v)ã€‚

è¿æ¥äºåŒä¸€é¡¶ç‚¹ v ä¹‹é—´çš„è¾¹ (v, v)ï¼Œç§°ä½œ**è‡ªç¯ï¼ˆself-loopï¼‰**ï¼Œä¸å«ä»»ä½•è‡ªç¯çš„å›¾ç§°ä½œ**ç®€å•å›¾ï¼ˆsimple graphï¼‰**ï¼Œä¹Ÿæ˜¯æœ¬ä¹¦ä¸»è¦è®¨è®ºçš„å¯¹è±¡ã€‚



![image-20230822152332004](./assets/image-20230822152332004.png)

æ‰€è°“**è·¯å¾„**æˆ–**é€šè·¯ï¼ˆpathï¼‰**ï¼Œå°±æ˜¯ç”± m + 1 ä¸ªé¡¶ç‚¹ä¸ m æ¡è¾¹äº¤æ›¿è€Œæˆçš„ä¸€ä¸ªåºåˆ—ï¼š
$$
\pi = \{v_0, e_1, v_1, e_2, ..., e_m, v_m\} \quad \forall0 < i \leq m,e_i=(v_{i-1}, v_i)
$$
å…¶ä¸­æ²¿é€”è¾¹çš„æ€»æ•° $m$ï¼Œäº¦ç§°ä½œé€šè·¯çš„é•¿åº¦ï¼Œè®°ä½œ$|\pi| = m$ã€‚ä¹Ÿå¯ä»¥ç®€åŒ–è¡¨è¿°ä¸º
$$
\pi = \{v_0, v_1, ... ,v_m\}
$$
æ²¿é€”é¡¶ç‚¹äº’å¼‚çš„é€šè·¯ï¼Œç§°ä½œ**ç®€å•é€šè·¯ï¼ˆsimple pathï¼‰**ã€‚



å¯¹äºé•¿åº¦$m \geq1$çš„é€šè·¯ $\pi$ï¼Œè‹¥èµ·æ­¢é¡¶ç‚¹ç›¸åŒï¼ˆå³$v_0 = v_m$ï¼‰ï¼Œåˆ™ç§°ä½œ**ç¯è·¯ï¼ˆcycleï¼‰**ã€‚è‹¥æ²¿é€”é™¤ $v_0 = v_m$ å¤–æ‰€æœ‰é¡¶ç‚¹å‡äº’å¼‚ï¼Œåˆ™ç§°ä½œ**ç®€å•ç¯è·¯ï¼ˆsimple cycleï¼‰**ã€‚

ä¸å«ä»»ä½•ç¯è·¯çš„æœ‰å‘å›¾ï¼Œç§°ä½œ**æœ‰å‘æ— ç¯å›¾ï¼ˆdirected acyclic graph, DAGï¼‰**ã€‚

ç»è¿‡å›¾ä¸­å„è¾¹ä¸€æ¬¡ä¸”æ°å¥½ä¸€æ¬¡çš„ç¯è·¯ï¼Œç§°ä½œ**æ¬§æ‹‰ç¯è·¯ï¼ˆEulerian tourï¼‰**ã€‚ç»è¿‡å›¾ä¸­å„é¡¶ç‚¹ä¸€æ¬¡ä¸”æ°å¥½ä¸€æ¬¡çš„ç¯è·¯ï¼Œç§°ä½œ**å“ˆå¯†å°”é¡¿ç¯è·¯ï¼ˆHamiltonian tourï¼‰**



å¯ä»¥ä¸ºæ¯ä¸€æ¡è¾¹$e$æŒ‡å®šä¸€ä¸ªæƒé‡$W(e)$â€‹ã€‚å„è¾¹å‡å¸¦æœ‰æƒé‡çš„å›¾ï¼Œç§°ä½œ**å¸¦æƒå›¾ï¼ˆweighted graphï¼‰**æˆ–å¸¦æƒç½‘ç»œï¼ˆweighted networkï¼‰ï¼Œæœ‰æ—¶ä¹Ÿç®€ç§°**ç½‘ç»œï¼ˆnetworkï¼‰**ï¼Œè®°ä½œ$G(V, E, W)$ã€‚

## å›¾çš„å­˜å‚¨

### çŸ©é˜µ

![image-20240718012456194](./assets/image-20240718012456194.png)

è¾¹çš„é™æ€å’ŒåŠ¨æ€æ“ä½œä¹Ÿä»…éœ€$O(1)$æ—¶é—´ã€‚ä½†æ˜¯ï¼Œé¡¶ç‚¹çš„åŠ¨æ€æ“ä½œæ¥å£å‡ååˆ†è€—æ—¶ã€‚å‘é‡ `E[][]`ä¹Ÿéœ€è¦å¢åŠ ä¸€è¡Œï¼Œä¸”æ¯è¡Œéƒ½éœ€è¦æ·»åŠ ä¸€ä¸ªå…ƒç´ ã€‚é¡¶ç‚¹åˆ é™¤æ“ä½œï¼Œäº¦ä¸æ­¤ç±»ä¼¼ï¼Œåˆ é™¤æ“ä½œçš„ç©ºé—´å¤æ‚åº¦ä¸º$O(n^2 )$

### é‚»æ¥è¡¨

![image-20240718012637824](./assets/image-20240718012637824.png)

exists(v, u) éœ€åœ¨ v å¯¹åº”çš„åˆ—è¡¨ä¸­é¡ºåºæŸ¥æ‰¾ï¼Œå…±éœ€$O(n)$æ—¶é—´ã€‚é¡¶ç‚¹çš„æ’å…¥æ“ä½œï¼Œå¯åœ¨$O(1)$å®Œæˆã€‚é¡¶ç‚¹çš„åˆ é™¤æ“ä½œï¼Œä»éœ€éå†æ‰€æœ‰é‚»æ¥è¡¨ï¼Œå…±éœ€$O(e)$æ—¶é—´ã€‚

å°½ç®¡é‚»æ¥è¡¨è®¿é—®å•æ¡è¾¹çš„æ•ˆç‡å¹¶ä¸ç®—é«˜ï¼Œå´ååˆ†æ“…é•¿äºä»¥æ‰¹é‡æ–¹å¼ï¼Œå³å¤„ç†åŒä¸€é¡¶ç‚¹çš„æ‰€æœ‰å…³è”è¾¹ã€‚åœ¨ä»¥ä¸‹å›¾éå†ç­‰ç®—æ³•ä¸­ï¼Œè¿™æ˜¯å…¸å‹çš„å¤„ç†æµç¨‹å’Œæ¨¡å¼ã€‚



## å›¾éå†

å›¾çš„éå†éƒ½å¯ç†è§£ä¸ºï¼Œ**å°†éçº¿æ€§ç»“æ„è½¬åŒ–ä¸ºåŠçº¿æ€§ç»“æ„çš„è¿‡ç¨‹**ã€‚ç»éå†è€Œç¡®å®šçš„è¾¹ç±»å‹ä¸­ï¼Œæœ€é‡è¦çš„ä¸€ç±»å³æ‰€è°“çš„æ ‘è¾¹ï¼Œå®ƒä»¬ä¸æ‰€æœ‰é¡¶ç‚¹å…±åŒæ„æˆäº†åŸå›¾çš„ä¸€æ£µæ”¯æ’‘æ ‘ï¼ˆæ£®æ—ï¼‰ï¼Œç§°ä½œ**éå†æ ‘ï¼ˆtraversal treeï¼‰**ã€‚å„ç§å›¾æœç´¢ä¹‹é—´çš„åŒºåˆ«ï¼Œä½“ç°ä¸ºè¾¹åˆ†ç±»ç»“æœçš„ä¸åŒï¼Œä»¥åŠæ‰€å¾—éå†æ ‘ï¼ˆæ£®æ—ï¼‰çš„ç»“æ„å·®å¼‚ã€‚å…¶å†³å®šå› ç´ åœ¨äºï¼Œæœç´¢è¿‡ç¨‹ä¸­çš„æ¯ä¸€æ­¥è¿­ä»£ï¼Œå°†ä¾ç…§ä½•ç§ç­–ç•¥æ¥é€‰å–ä¸‹ä¸€æ¥å—è®¿é—®çš„é¡¶ç‚¹ã€‚

~~~java
//è¾¹åœ¨éå†æ ‘ä¸­æ‰€å±çš„ç±»å‹
enum EType {
    UNDETERMINED,			// å°šæœªè¢«å‘ç°
    TREE,				   // æ ‘è¾¹ï¼Œå½“ä» v éå†åˆ°å°šæœªè®¿é—®è¿‡çš„ u æ—¶ï¼Œ(v, u) è¢«æ ‡è®°ä¸ºæ ‘è¾¹
    CROSS,				   // è·¨è¾¹ï¼Œå½“ v éå†åˆ°å·²è®¿é—®è¿‡çš„ u æ—¶ï¼Œ(v, u) æ ‡è®°ä¸ºè·¨è¾¹
    FORWARD,
    BACKWARD;
}
~~~



å›¾éå†å¯¹äºæ— å‘å›¾å¿…èƒ½è¦†ç›– s æ‰€å±çš„**è¿é€šåˆ†é‡ï¼ˆconnected componentï¼‰**ï¼Œå¯¹äºæœ‰å‘å›¾å¿…èƒ½è¦†ç›–ä»¥sä¸ºèµ·ç‚¹çš„**å¯è¾¾åˆ†é‡ï¼ˆreachable componentï¼‰**ã€‚

### å¹¿åº¦ä¼˜å…ˆ

![image-20240718013546465](./assets/image-20240718013546465.png)

- `TREE`ï¼šæ ‘è¾¹ï¼Œå½“ä» v éå†åˆ°å°šæœªè®¿é—®è¿‡çš„ u æ—¶ï¼Œ(v, u) è¢«æ ‡è®°ä¸ºæ ‘è¾¹
- `CROSS`ï¼šè·¨è¾¹ï¼Œå½“ v éå†åˆ°å·²è®¿é—®è¿‡çš„ u æ—¶ï¼Œ(v, u) æ ‡è®°ä¸ºè·¨è¾¹

ä¸‹é¢å¾ˆå¤šç®—æ³•å°±æ˜¯ä»¥ BFS ä¸ºåŸºç¡€çš„ï¼Œä¾‹å¦‚ Primã€Dijskraã€SPFAã€æ‹“æ‰‘æ’åºç­‰ç­‰ã€‚åŸºæœ¬æ€è·¯å°±æ˜¯

1. ç»´æŠ¤ä¸€ä¸ªé˜Ÿåˆ—ã€‚æ¯æ¬¡éå†æ—¶ï¼Œä»é˜Ÿé¦–å¼¹å‡ºå…ƒç´ ã€‚
2. ä»¥è¯¥å…ƒç´ éå†å‘¨å›´çš„èŠ‚ç‚¹ï¼Œæ ¹æ®æ¡ä»¶åšæ¾å¼›æ“ä½œã€ç»Ÿè®¡æ“ä½œç­‰ç­‰ã€‚
3. æœ€åå°†è¿™ä¸ªå‘¨å›´èŠ‚ç‚¹åŠ å…¥åˆ°é˜Ÿåˆ—ä¸­ã€‚

### æ·±åº¦ä¼˜å…ˆ

![image-20240718013559777](./assets/image-20240718013559777.png)

![image-20240718013919319](./assets/image-20240718013919319.png)

~~~java
public void dfs(int s) {
    int v = s;
    do {
        if (status(v) == VStatus.UNDISCOVERED)
            dfs(v, clock);
    } while (s != (v = (v + 1) % n));
}

private void dfs(int s, MutableInteger clock) {
    status(s, VStatus.DISCOVERED);
    for (var iterator = getIteratorOfNode(s);
         iterator.hasNext();) {
        int v = iterator.next();
        if (status(v) == UNDISCOVERED) {
            dfs(v, clock);
        }
    }
    status(s, VStatus.VISITED);
}
~~~

## æœ€å°ç”Ÿæˆæ ‘

è¿é€šå›¾ G çš„æŸä¸€æ— ç¯è¿é€šå­å›¾ T è‹¥è¦†ç›– G ä¸­æ‰€æœ‰çš„é¡¶ç‚¹ï¼Œåˆ™ç§°ä½œ G çš„ä¸€æ£µæ”¯æ’‘æ ‘æˆ–**ç”Ÿæˆæ ‘ï¼ˆspanning treeï¼‰**ã€‚

![image-20240718120614008](./assets/image-20240718120614008.png)

è‹¥å›¾Gä¸ºä¸€å¸¦æƒç½‘ç»œï¼Œåˆ™æ¯ä¸€æ£µæ”¯æ’‘æ ‘çš„æˆæœ¬ï¼ˆcostï¼‰å³ä¸ºå…¶æ‰€é‡‡ç”¨å„è¾¹æƒé‡çš„æ€»å’Œã€‚åœ¨Gçš„æ‰€æœ‰æ”¯æ’‘æ ‘ä¸­ï¼Œæˆæœ¬æœ€ä½è€…ç§°ä½œ**æœ€å°æ”¯æ’‘æ ‘ï¼ˆminimum spanning tree, MSTï¼‰**ã€‚

æ˜¾ç„¶ï¼Œæœ‰äº›å›¾çš„æœ€å°æ”¯æ’‘æ ‘å…·æœ‰**æ­§ä¹‰æ€§**ï¼Œå³æœ€å°ç”Ÿæˆæ ‘å¹¶ä¸å”¯ä¸€ï¼Œä¸‹é¢ç»™å‡ºä¸€ä¸ªä¾‹å­ï¼š

![image-20230829115056064](./assets/image-20230829115056064.png)

### Kruskal

è¯¥ç®—æ³•çš„åŸºæœ¬æ€æƒ³æ˜¯ä»å°åˆ°å¤§åŠ å…¥è¾¹ï¼Œæ˜¯ä¸ªè´ªå¿ƒç®—æ³•ã€‚Kruskal åœ¨ç¼–ç ä¸Šçš„å¥½å¤„æ˜¯ï¼Œä½ æ— éœ€å»ºå›¾ï¼Œä»…ä»…ç»´æŠ¤è¾¹çš„é›†åˆå³å¯ã€‚å¯ä»¥ç”¨ã€Œæ’åºã€æˆ–è€…ã€Œä¼˜å…ˆé˜Ÿåˆ—ã€æ¥ç»´æŠ¤è¾¹çš„å¤§å°ã€‚åœ¨æ·»åŠ è¾¹çš„æ—¶å€™ï¼Œå¦‚æœå·²ç»ç»ˆç‚¹å·²ç»è¢«è®¿é—®è¿‡äº†ï¼Œé‚£ä¹ˆå°±ç›´æ¥ç•¥è¿‡è¿™æ¡è¾¹ã€‚



ä¾‹é¢˜ï¼šä½ å‡†å¤‡å‚åŠ ä¸€åœºè¿œè¶³æ´»åŠ¨ã€‚ç»™ä½ ä¸€ä¸ªäºŒç»´ `rows x columns` çš„åœ°å›¾ `heights` ï¼Œå…¶ä¸­ `heights[row][col]` è¡¨ç¤ºæ ¼å­ `(row, col)` çš„é«˜åº¦ã€‚ä¸€å¼€å§‹ä½ åœ¨æœ€å·¦ä¸Šè§’çš„æ ¼å­ `(0, 0)` ï¼Œä¸”ä½ å¸Œæœ›å»æœ€å³ä¸‹è§’çš„æ ¼å­ `(rows-1, columns-1)` ï¼ˆæ³¨æ„ä¸‹æ ‡ä» **0** å¼€å§‹ç¼–å·ï¼‰ã€‚ä½ æ¯æ¬¡å¯ä»¥å¾€ **ä¸Š**ï¼Œ**ä¸‹**ï¼Œ**å·¦**ï¼Œ**å³** å››ä¸ªæ–¹å‘ä¹‹ä¸€ç§»åŠ¨ï¼Œä½ æƒ³è¦æ‰¾åˆ°è€—è´¹ **ä½“åŠ›** æœ€å°çš„ä¸€æ¡è·¯å¾„ã€‚ä¸€æ¡è·¯å¾„è€—è´¹çš„ **ä½“åŠ›å€¼** æ˜¯è·¯å¾„ä¸Šç›¸é‚»æ ¼å­ä¹‹é—´ **é«˜åº¦å·®ç»å¯¹å€¼** çš„ **æœ€å¤§å€¼** å†³å®šçš„ã€‚è¯·ä½ è¿”å›ä»å·¦ä¸Šè§’èµ°åˆ°å³ä¸‹è§’çš„æœ€å° **ä½“åŠ›æ¶ˆè€—å€¼** ã€‚

![img](./assets/ex1.png)

![img](./assets/ex3.png)

~~~go
func minimumEffortPathKrusKkal(heights [][]int) int {
    // è¾“å…¥çš„åŸå§‹å›¾ï¼Œä¸å¯ç›´æ¥ç”¨ï¼Œè¦ç»è¿‡å¤„ç†
	h, w := len(heights), len(heights[0])

	type Pair struct{ x, y int }
	directions := []Pair{
		{1, 0},
		{0, 1},
	}
    // é‚»æ¥è¡¨çš„ Edge æ— éœ€å­˜å‚¨èµ·ç‚¹ u
	type Edge struct{ u, v, w int }
    // æ³¨æ„ï¼Œè¿™å¯ä¸æ˜¯é‚»æ¥è¡¨ï¼Œè€Œæ˜¯ä¸€ä¸ª Edge çš„é›†åˆ
	edges := []Edge{}
	abs := func(num int) int {
		if num < 0 {
			num = -num
		}
		return num
	}
	getId := func(x, y int) int {
		return x*w + y
	}

	for i, row := range heights {
		for j, _ := range row {
			for _, d := range directions {
				if ni, nj := d.x+i, d.y+j; ni != h && nj != w {
					weight := abs(heights[ni][nj] - heights[i][j])
					edges = append(edges, Edge{getId(i, j), getId(ni, nj), weight})
					edges = append(edges, Edge{getId(ni, nj), getId(i, j), weight})
				}
			}
		}
	}
 	// æ’åº
	sort.Slice(edges, func(i, j int) bool {
		return edges[i].w < edges[j].w
	})

	pa := make([]int, h*w)
	for i, _ := range pa {
		pa[i] = i
	}
	var find func(x int) int
	find = func(x int) int {
		if pa[x] != x {
			pa[x] = find(pa[x])
		}
		return pa[x]
	}
	union := func(x, y int) {
		pa[find(x)] = find(y)
	}
	query := func(x, y int) bool {
		return find(pa[x]) == find(pa[y])
	}
	ans := 0
	for _, edge := range edges {
		ans = max(ans, edge.w)
		union(edge.u, edge.v)
		if query(0, w*h-1) {
			return ans
		}
	}
	return 0
}
~~~



### Prim

![img](./assets/format,png.png)

è¯¥ç®—æ³•çš„åŸºæœ¬æ€æƒ³æ˜¯ä»ä¸€ä¸ªç»“ç‚¹å¼€å§‹ï¼Œä¸æ–­åŠ ç‚¹ï¼ˆè€Œä¸æ˜¯ Kruskal ç®—æ³•çš„åŠ è¾¹ï¼‰ã€‚å…·ä½“æ¥è¯´ï¼Œæ¯æ¬¡è¦é€‰æ‹©è·ç¦»æœ€å°çš„ä¸€ä¸ªç»“ç‚¹ï¼Œä»¥åŠç”¨æ–°çš„è¾¹æ›´æ–°å…¶ä»–ç»“ç‚¹çš„è·ç¦»ã€‚

~~~go
type Vertex struct {
    // è¿™é‡Œçš„å°è£…æ˜¯å¿…è¦çš„ï¼Œå› ä¸ºè¦æ ¹æ® dist æ¥æ’åº
   v, dist int
}
// å·²å®ç° heap.interface æ¥å£
type VertexHeap []Vertex

type Graph struct {
   n      int
   adjMat [][]int		// é‚»æ¥çŸ©é˜µ
}

func prim() int {
    // n ä¸ºèŠ‚ç‚¹çš„ä¸ªæ•°
    visited := make([]bool, n)
    dist := make([]int, g.n)
    parent := make([]int, g.n)		// è®°å½•ç”Ÿæˆè·¯å¾„
    for i := range dist {
        dist[i] = math.MaxInt32
    }
    dist[0] = 0
    h := &VertexHeap{}
    heap.Push(h, Vertex{0, 0})
    cost := 0
    for h.Len() > 0 {
        u := heap.Pop(vertex).(Vertex).v
        if visited[u] {
            continue
        }
        visited[u] = true
        cost += dist[u]
        for v := 0; v < g.n; v++ {
            // é›†åˆä¸­çš„ u åˆ° v çš„è·ç¦»ï¼Œæ¯” dist[v] å°ï¼Œé‚£ä¹ˆå°±æ›´æ–°
            if g.adjMat[u][v] != 0 && !visited[v] && g.adjMat[u][v] < dist[v] {
                dist[v] = g.adjMat[u][v]
                parent[v] = u
                heap.Push(h, Vertex{v, dist[v]})
            }
        }
    }
    return cost
}
~~~



è¿˜æ˜¯ä»¥ä¸Šé¢ä¾‹é¢˜æ¥è¯´æ˜ Prim ç®—æ³•ï¼š

~~~go

import "math"
type Vertex struct {
    v, dist int
}

// ä¼˜å…ˆé˜Ÿåˆ—ï¼Œå·²å®ç° heap.Interface æ¥å£
type VertexHeap []Vertex

func minimumEffortPath(heights [][]int) int {
    h, w := len(heights), len(heights[0])
    // è¿™é‡Œçš„ Edge å®šä¹‰å’Œ Kraskal ä¸­çš„ä¸ä¸€æ ·ï¼Œæ³¨æ„åŒºåˆ«
    type Edge struct{ u, w int }
    edges := make([][]Edge, h*w)
    for i, _ := range edges {
        edges[i] = []Edge{}
    }
    // è¿™é‡Œå°±çœç•¥é‚»æ¥è¡¨å»ºå›¾çš„é€»è¾‘äº†
    // æ„Ÿè§‰æ²¡å¿…è¦å»ºå›¾ï¼Œç›´æ¥ä½¿ç”¨åŸç”Ÿè¾“å…¥å³å¯
	// è¿™é‡Œå»ºå›¾ç›¸å½“äºå°†ã€Œé‚»æ¥çŸ©é˜µã€è½¬æ¢ä¸ºã€Œé‚»æ¥è¡¨ã€ï¼Œæ„Ÿè§‰å¤šæ¬¡ä¸€ä¸¾
    // prim
    dis := make([]int, w*h)
    for i := range dis {
        dis[i] = math.MaxInt32
    }
    dis[0] = 0
    visited := make([]bool, w*h)
    ans := 0
    vertex := &VertexHeap{}
    parent := make([]int, w*h)
    heap.Push(vertex, Vertex{0, 0})
    for vertex.Len() > 0 {
        x := heap.Pop(vertex).(Vertex).v
        if visited[x] {
            continue
        }
        for _, edge := range edges[parent[x]] {
            if edge.u == x {
                ans = max(ans, edge.w)
            }
        }
        if x == w*h-1 {
            return ans
        }
        visited[x] = true
        for _, edge := range edges[x] {
            u := edge.u
            if !visited[u] && dis[u] > edge.w {
                dis[u] = edge.w
                parent[u] = x
                heap.Push(vertex, Vertex{u, dis[u]})
            }
        }
    }
    return 0
}

~~~



## æ‹“æ‰‘æ’åº

å‘½é¢˜ï¼šæœ‰å‘æ— ç¯å›¾ä¸€å®šå­˜åœ¨æ‹“æ‰‘æ’åº

~~~go
// DFS ç‰ˆ
private boolean tSort(int s, Stack<VertexType> stack) {
    status(s, VStatus.DISCOVERED);
    for (var iterator = getIteratorOfNode(s);
        iterator.hasNext();) {
        int t = iterator.next();
        switch (status(t)) {
            case DISCOVERED:
                //åœ¨æœ‰å‘å›¾ä¸­å‘ç°åå‘è¾¹ï¼ˆback edgeï¼‰
                return false;
            case UNDISCOVERED:
                if (!tSort(t, stack))
                    return false;
			// visited çš„èŠ‚ç‚¹å¯¹äºæ¥ä¸‹æ¥æ‹“æ‰‘æ’åºæ— å½±å“ï¼Œå¯ä»¥è®¤ä¸ºæ˜¯å·²ç»ä»å›¾ä¸­åˆ é™¤äº†ï¼Œä¸å†è€ƒè™‘
        }
    }
    status(s, VStatus.VISITED);
    // æŒ‰é€†åºç»™å‡ºäº†åŸå›¾çš„ä¸€ä¸ªæ‹“æ‰‘æ’åºã€‚
    stack.push(vertex(s));
    return true;
}
~~~

~~~go
// BFS ç‰ˆ

in := make([]int, n)
graph := make([][]int, n)		// å»ºå›¾
for i, _ := range graph {
    graph[i] = []int{}
}

cnt := n // ç”¨äºåˆ¤æ–­æ˜¯å¦æœ‰ç¯
for _, relation := range relations {
    v, u := relation[0], relation[1]
    graph[v] = append(graph[v], u)
    in[u]++
}

queue := []int{}
for i, v := range in {
    if v == 0  {
        queue = append(queue, i)
        cnt--
    }
    
}

for len(queue) != 0 {
    n := queue[0]
    queue = queue[1:]
    for _, v := range graph[n] {
        in[v]--
        if in[v] == 0 {
            queue = append(queue, v)
            cnt--
        }
    }
}
if (cnt != 0) {
    return -1 // è¯´æ˜æœ‰ç¯
}
~~~



## å•æºæœ€çŸ­è·¯å¾„

### Bellman-Ford

è¿™é‡Œæˆ‘ä»¬ä»‹ç» Bellman-Ford ç®—æ³•å¯ä»¥å¤„ç†è´Ÿæƒè¾¹çš„æƒ…å†µï¼Œä½†æ˜¯å®ƒè¦æ±‚ä¸èƒ½å­˜åœ¨è´Ÿç¯ï¼ˆå›è·¯çš„æƒå€¼ä¹‹å’Œä¸ºè´Ÿï¼‰

å¯¹äºè¾¹ $(u, v)$ï¼Œå…¶æ¾å¼›æ“ä½œå¯¹åº”ä¸‹é¢è¿™ä¸ªå¼å­ï¼š
$$
dis(v) = min(dis(v), dis(u) + w(u, v))
$$
å› ä¸ºä¸€æ¬¡æ¾å¼›æ“ä½œä¼šä½¿æœ€çŸ­è·¯çš„è¾¹æ•°è‡³å°‘ + 1ï¼Œè€Œæœ€çŸ­è·¯çš„è¾¹æ•°æœ€å¤šä¸º n - 1ã€‚æ‰€ä»¥å¦‚æœç¬¬ n è½®å¾ªç¯æ—¶ä»ç„¶å­˜åœ¨èƒ½æ¾å¼›çš„è¾¹ï¼Œè¯´æ˜ä» S ç‚¹å‡ºå‘ï¼Œèƒ½å¤ŸæŠµè¾¾ä¸€ä¸ªè´Ÿç¯ã€‚

~~~c++
struct Edge {
    int u, v, w
}
vector<Edge> edge; 			// æ³¨æ„ï¼Œè¿™é‡Œå¹¶æ²¡æœ‰å»ºå›¾ï¼Œä»…ä½¿ç”¨è¾¹é›†å³å¯

int dis[MAXN], u, v, w;
const int INF = 0x3f3f3f3f;	// æ³¨æ„åˆå§‹åŒ–çš„å€¼

bool bellmanford(int n, int s) {
    memset(dis, 0x3f, sizeof(dis));
    dis[s] = 0
    bool flag = false;  // åˆ¤æ–­ä¸€è½®å¾ªç¯è¿‡ç¨‹ä¸­æ˜¯å¦å‘ç”Ÿæ¾å¼›æ“ä½œ
    for (int i = 1; i <= n; i++) {
        flag = false;
        // éå†æ‰€æœ‰çš„è¾¹
        for (int j = 0; j < edge.size(); j++) {
            u = edge[j].u, v = edge[j].v, w = edge[j].w;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                flag = true;
            }
        }
        // æ²¡æœ‰å¯ä»¥æ¾å¼›çš„è¾¹æ—¶å°±åœæ­¢ç®—æ³•
        if (!flag) {
            break;
        }
    }
    // ç¬¬ n è½®å¾ªç¯ä»ç„¶å¯ä»¥æ¾å¼›æ—¶è¯´æ˜ s ç‚¹å¯ä»¥æŠµè¾¾ä¸€ä¸ªè´Ÿç¯
    return flag;
}
~~~

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä»¥ S ç‚¹ä¸ºæºç‚¹è·‘ Bellmanâ€“Ford ç®—æ³•æ—¶ï¼Œå¦‚æœæ²¡æœ‰ç»™å‡ºå­˜åœ¨è´Ÿç¯çš„ç»“æœï¼Œåªèƒ½è¯´æ˜ä» S ç‚¹å‡ºå‘ä¸èƒ½æŠµè¾¾ä¸€ä¸ªè´Ÿç¯ï¼Œè€Œä¸èƒ½è¯´æ˜å›¾ä¸Šä¸å­˜åœ¨è´Ÿç¯ã€‚

ç‰¹åˆ«å¼ºè°ƒï¼Œåœ¨è§£å†³**ã€Œæœ‰è¾¹æ•°é™åˆ¶çš„æœ€çŸ­è·¯é—®é¢˜ã€**æ—¶ï¼Œè¦è®°å¾—åœ¨è¿­ä»£æ—¶å¤åˆ¶ä»¥ä¸‹ Dis æ•°ç»„ï¼Œä»¥åŠé™åˆ¶è¿­ä»£æ¬¡æ•°ã€‚ç»å…¸ä¾‹é¢˜ï¼š[787. K ç«™ä¸­è½¬å†…æœ€ä¾¿å®œçš„èˆªç­](https://leetcode.cn/problems/cheapest-flights-within-k-stops/)

### SPFA

å¾ˆæ˜¾ç„¶ï¼Œåªæœ‰ä¸Šä¸€æ¬¡è¢«æ¾å¼›çš„ç»“ç‚¹ï¼Œæ‰€è¿æ¥çš„è¾¹ï¼Œæ‰æœ‰å¯èƒ½å¼•èµ·ä¸‹ä¸€æ¬¡çš„æ¾å¼›æ“ä½œã€‚é‚£ä¹ˆæˆ‘ä»¬ç”¨é˜Ÿåˆ—æ¥ç»´æŠ¤ã€Œå“ªäº›ç»“ç‚¹å¯èƒ½ä¼šå¼•èµ·æ¾å¼›æ“ä½œã€ï¼Œå°±èƒ½åªè®¿é—®å¿…è¦çš„è¾¹äº†ã€‚



~~~c++
struct edge {
  int v, w;
};
vector<edge> e[maxn];  			// è¿™é‡Œç”¨é‚»æ¥è¡¨è¿›è¡Œäº†å»ºå›¾

int dis[maxn], cnt[maxn], vis[maxn];
queue<int> q;					// ä¸ç”¨ä¼˜å…ˆé˜Ÿåˆ—

bool spfa(int n, int s) {
    memset(dis, 63, sizeof(dis));
    dis[s] = 0;
    q.push(s);
    while (!q.empty()) {
        int u = q.front();
        q.pop(), vis[u] = 0;
        for (auto ed : e[u]) {
            int v = ed.v, w = ed.w;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                cnt[v] = cnt[u] + 1;  // è®°å½•æœ€çŸ­è·¯ç»è¿‡çš„è¾¹æ•°
                // åœ¨ä¸ç»è¿‡è´Ÿç¯çš„æƒ…å†µä¸‹ï¼Œæœ€çŸ­è·¯è‡³å¤šç»è¿‡ n - 1 æ¡è¾¹
                // å› æ­¤å¦‚æœç»è¿‡äº†å¤šäº n æ¡è¾¹ï¼Œä¸€å®šè¯´æ˜ç»è¿‡äº†è´Ÿç¯
                if (cnt[v] >= n) 
                    return false;
                if (!vis[v]) 
                    q.push(v), vis[v] = 1;
            }
        }
    }
    return true;
}
~~~

### Dijkstra

Dijkstra æ˜¯ä¸€ç§æ±‚è§£éè´Ÿæƒå›¾ä¸Šå•æºæœ€çŸ­è·¯å¾„çš„ç®—æ³•ï¼š

~~~c++
// è¿™ä¸ªç‹¬ç«‹äºé‚»æ¥è¡¨çš„
struct node {
    int dis, u;
    // ç”¨åœ¨ä¼˜å…ˆé˜Ÿåˆ—ä¸­åšæ¯”è¾ƒ
    bool operator>(const node& a) const { return dis > a.dis; }
};
// ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–
priority_queue<node, vector<node>, greater<node> > q;

struct edge {
    int v, w;
};
vector<edge> e[maxn];			// é‚»æ¥è¡¨
int dis[maxn], vis[maxn];


void dijkstra(int n, int s) {
    memset(dis, 63, sizeof(dis));
    dis[s] = 0;
    q.push({0, s});
    while (!q.empty()) {
        int u = q.top().u;
        q.pop();
        if (vis[u]) 
            continue;
        vis[u] = 1;
        for (auto ed : e[u]) {
            int v = ed.v, w = ed.w;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                q.push({dis[v], v});
            }
        }
    }
}
~~~

æˆ‘ä»¬å‘ç° Dijkstra ç®—æ³•çš„ä¼˜å…ˆé˜Ÿåˆ—ç‰ˆæœ¬ä¸ Spfa ç®—æ³•çš„ä»£ç æä¸ºç›¸ä¼¼ï¼Œä½†æ˜¯æ ¸å¿ƒæ€æƒ³å®Œå…¨ä¸ä¸€æ ·ï¼Œå…·ä½“ä½“ç°åœ¨ `vis[u]` çš„ä½¿ç”¨ä¸Šã€‚

åœ¨ç¨€ç–å›¾ä¸­ï¼Œä½¿ç”¨äºŒå‰å †å®ç°çš„ Dijkstra ç®—æ³•è¾ƒ Bellmanâ€“Ford ç®—æ³•å…·æœ‰è¾ƒå¤§çš„æ•ˆç‡ä¼˜åŠ¿ï¼›è€Œåœ¨ç¨ å¯†å›¾ä¸­ï¼Œè¿™æ—¶å€™ä½¿ç”¨æš´åŠ›åšæ³•è¾ƒäºŒå‰å †å®ç°æ›´ä¼˜ã€‚

## å¤šæºæœ€çŸ­è·¯å¾„

### Floyd ç®—æ³•

~~~c++

for (k = 1; k <= n; k++) {
    for (x = 1; x <= n; x++) {
        for (y = 1; y <= n; y++) {
            // f[x][y]æ˜¯ä¸€ä¸ªé‚»æ¥çŸ©é˜µ
            f[x][y] = min(f[x][y], f[x][k] + f[k][y]);
        }
    }
}
~~~



## å¹¶æŸ¥é›†

å¹¶æŸ¥é›†æ˜¯ä¸€ç§ç”¨äºç®¡ç†å…ƒç´ æ‰€å±é›†åˆçš„æ•°æ®ç»“æ„ï¼Œå®ç°ä¸ºä¸€ä¸ªæ£®æ—ï¼Œå…¶ä¸­æ¯æ£µæ ‘è¡¨ç¤ºä¸€ä¸ªé›†åˆï¼Œæ ‘ä¸­çš„èŠ‚ç‚¹è¡¨ç¤ºå¯¹åº”é›†åˆä¸­çš„å…ƒç´ ã€‚

**å¯¹äºé›†åˆçš„åˆ’åˆ†æ˜¯å¹¶æŸ¥é›†é—®é¢˜çš„å…³é”®**ã€‚

æˆ‘ä»¬å°±å¯ä»¥å®šä¹‰ä¸€ä¸‹ã€Œå¹¶æŸ¥é›†ã€ç»“æ„æ‰€æ”¯æŒçš„æ“ä½œæ¥å£ï¼š

- åˆå¹¶ `union(x, y)`ï¼šå°†é›†åˆ ğ‘¥ å’Œé›†åˆ ğ‘¦ åˆå¹¶æˆä¸€ä¸ªé›†åˆã€‚
- æŸ¥æ‰¾ `find(x)`ï¼šæŸ¥æ‰¾å…ƒç´  ğ‘¥ å±äºå“ªä¸ªé›†åˆã€‚
- æŸ¥æ‰¾ `is_connected(x, y)`ï¼šæŸ¥è¯¢å…ƒç´  ğ‘¥ å’Œ ğ‘¦ æ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆä¸­ã€‚

 

### åˆå§‹åŒ–

~~~go
pa := make([]int, m)
for i, _ := range pa {
    pa[i] = i
}
~~~

### æŸ¥è¯¢

![image-20240718135252968](./assets/image-20240718135252968.png)

~~~c++
func find(int i) int {
    if pa[i] == i {
        return i
    } else {
        return find(pa[i])
    }
}
~~~

è·¯å¾„å‹ç¼©ï¼šæŸ¥è¯¢è¿‡ç¨‹ä¸­ç»è¿‡çš„æ¯ä¸ªå…ƒç´ éƒ½å±äºè¯¥é›†åˆï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶ç›´æ¥è¿åˆ°æ ¹èŠ‚ç‚¹ä»¥åŠ å¿«åç»­æŸ¥è¯¢ã€‚

~~~go
func find(i int) int {
    if pa[i] == i {
        return i
    } else {
        pa[i] = find(pa[i])
        return pa[i]
    }
}

// ç®€åŒ–
func find(i int) int {
    if pa[i] != i {
        pa[i] = find(pa[i])
    }
    return pa[i]
}
~~~

<img src="./assets/image-20240718162603951.png" alt="image-20240718162603951" style="zoom:50%;" />



### åˆå¹¶

![image-20240718135327413](./assets/image-20240718135327413.png)

~~~go
func union(x, y int) {
    pa[find(x)] = find(y)
}
~~~

åˆå¹¶æ—¶ï¼Œé€‰æ‹©å“ªæ£µæ ‘çš„æ ¹èŠ‚ç‚¹ä½œä¸ºæ–°æ ‘çš„æ ¹èŠ‚ç‚¹ä¼šå½±å“æœªæ¥æ“ä½œçš„å¤æ‚åº¦ã€‚æˆ‘ä»¬å¯ä»¥å°†èŠ‚ç‚¹è¾ƒå°‘æˆ–æ·±åº¦è¾ƒå°çš„æ ‘è¿åˆ°å¦ä¸€æ£µï¼Œä»¥å…å‘ç”Ÿé€€åŒ–ã€‚è¿™é‡Œæˆ‘ä»¬ä»¥èŠ‚ç‚¹æ•°é‡ä¸ºä¾æ®è¿›è¡Œåˆå¹¶ã€‚

~~~go
unite := func(x, y int) {
    x, y = find(x), find(y)
    if x == y {
        return
    }
    if y < x {
        x, y = y, x
    }
    pa[x] = y
    sz[y] += sz[x]
}
~~~

### ä¾‹é¢˜

å¯¹äºé›†åˆçš„åˆ’åˆ†æ˜¯å¹¶æŸ¥é›†é—®é¢˜çš„å…³é”®ï¼Œæˆ‘ä»¬ä»¥ä¸‹é¢è¿™äº›é¢˜ä¸ºä¾‹ï¼š

- [æœ€é•¿è¿ç»­åºåˆ—](https://leetcode.cn/problems/longest-consecutive-sequence/)ï¼šå¦‚æœå®ƒå‘¨å›´çš„æ•°å­˜åœ¨ï¼Œé‚£ä¹ˆå°±æ·»åŠ åˆ°é›†åˆä¸­
- [803. æ‰“ç –å—](https://leetcode.cn/problems/bricks-falling-when-hit/)ï¼šå¦‚æœå®ƒå‘¨å›´å­˜åœ¨æ–¹å—ï¼Œé‚£ä¹ˆå°±åŠ å…¥

æˆ‘ä»¬å¯ä»¥åœ¨æ¯ä¸ªé›†åˆä¸­ç»´æŠ¤ä¸€äº›å±æ€§ï¼Œä¾‹å¦‚é›†åˆå¤§å°ï¼Œè¿™äº›å±æ€§è¦åœ¨åˆå¹¶æ—¶æ­£ç¡®å¤„ç†ï¼Œä¸€èˆ¬æ˜¯æ ¹èŠ‚ç‚¹æŒæœ‰æ­£ç¡®çš„å±æ€§ã€‚

