# 树

[TOC]

## 概念

在线性结构中，元素之间都存在一个自然的线性次序。树则不然，其中的元素之间并不存在天然的直接后继或直接前驱关系。但是只要附加某种约束（比如中序遍历），也可以在树中的元素之间确定某种线性次序（全序关系）。树的结构可以表示一个具有最大元的偏序关系，因此且属于**半线性结构（semi-linear structure）**。

从图论的角度看，**树等价于连通n个顶点、n-1条边的无环图**。下面介绍下有关树的概念：

![image-20240717155449747](./assets/image-20240717155449747.png)

- **深度（depth）**：沿每个节点 v 到根 r 的唯一通路所经过边的数目，称作 v 的深度（depth），记作depth(v)。

  特别地，约定根节点的深度 depth(r) = 0

- 任一节点 v 在通往树根沿途所经过的每个节点都是其**祖先（ancestor）**，v 是它们的**后代（descendant）**。特别地，v 的祖先/后代包括其本身，而 v 本身以外的祖先后代称作**真祖先（proper ancestor）**/**真后代（proper descendant）**。

- 特别地，若节点 u 是 v 的祖先且恰好比 v 高出一层，则称 u 是 v 的**父亲（parent）**，v 是 u的**孩子（child）**。

- v 的孩子总数，称作其度数或**度（degree）**，记作deg(v)。无孩子的节点称作**叶节点（leaf）**，包括根在内的其余节点皆为**内部节点（internal node）**

- v 所有的后代及其之间的联边称作**子树（subtree）**，记作 subtree(v)。

- 树 T 中所有节点深度的最大值称作该**树的高度（height）**，记作 height(T)。特别地，仅含单个节点的树高度为0，空树高度为 -1。推而广之，任一节点 v 所对应子树 subtree(v) 的高度，亦称作该**节点的高度**，记作 height(v)。特别地，全树的高度亦即其根节点 r 的高度，$height(T) = height(r)$。

## 遍历

**通过中序遍历，可在二叉树各节点之间定义一个线性次序**。相应地，各节点之间也可定义前驱与后继关系。

而遍历需要一个全局次序，而二叉树本身并不具有天然的全局次序。故首先需要在各节点与其孩子之间约定某种局部次序，从而间接地定义出全局次序。而局部访问的次序有`VLR`、`LVR`和`LRV`三种选择，这三种策略也相应地分别称作先序遍历、中序遍历和后序遍历：

![image-20240717155612745](./assets/image-20240717155612745.png)

### 先序遍历

![image-20230822112337217](./assets/image-20230822112337217.png)

~~~java
public static <T extends Comparable<T>>
void travelPre(BinaryTreeNode<T> node, Consumer<T> consumer) {
    if (node == null) return;
    consumer.accept(node.data);
    travelPre(node.leftChild, consumer);
    travelPre(node.rightChild, consumer);
}
~~~

递归版遍历算法时间、空间复杂度的常系数，相对于迭代版更大。

~~~java
public static <T extends Comparable<T>>
void travelPreIteration1(BinaryTreeNode<T> node, Consumer<T> consumer) {
    Stack<BinaryTreeNode<T>> nodes = new Stack<>();
    if (node != null)
        nodes.push(node);
    while (!nodes.empty()) {
        BinaryTreeNode<T> x = nodes.pop();
        consumer.accept(x.data);
        if (hasRightChild(x))
            nodes.push(x.rightChild);
        if (hasLeftChild(x))
            nodes.push(x.leftChild);
    }
}
~~~

很遗憾，以上思路并不容易推广到非尾递归的场合，比如在中序或后序遍历中，至少有一个递归方向严格地不属于尾递归。此时，如下另一迭代式版本的实现思路，则更具参考价值，即模拟调用栈（While + Stack）。

![image-20230822114959641](./assets/image-20230822114959641.png)

~~~java
public static <T extends Comparable<T>>
void travelPreIteration2(BinaryTreeNode<T> node, Consumer<T> consumer) {
    Stack<BinaryTreeNode<T>> rightNodes = new Stack<>();
    while (true) {
        while (node != null) {
            consumer.accept(node.data);
            if (node.rightChild != null)
                rightNodes.push(node.rightChild);
            node = node.leftChild;
        }
        if (rightNodes.empty()) break;
        node = rightNodes.pop();
    }
}
~~~



### 中序遍历

![image-20230822112356019](./assets/image-20230822112356019.png)

~~~java
public static <T extends Comparable<T>>
void travelIn(BinaryTreeNode<T> node, Consumer<T> consumer) {
    if (node == null) return;
    travelIn(node.leftChild, consumer);
    consumer.accept(node.data);
    travelIn(node.rightChild, consumer);
}
~~~

![image-20230822115043504](./assets/image-20230822115043504.png)

~~~java
public static <T extends Comparable<T>>
void travelInIteration1(BinaryTreeNode<T> node, Consumer<T> consumer) {
    Stack<BinaryTreeNode<T>> leftNodes = new Stack<>();
    while (true) {
        while (node != null) {
            leftNodes.push(node);
            node = node.leftChild;
        }
        if (leftNodes.empty())
            break;
        node = leftNodes.pop();
        consumer.accept(node.data);
        node = node.rightChild;
    }
}
~~~



### 后序遍历

先序遍历序列与后序遍历序列并非简单的逆序关系。

![image-20230822112348831](./assets/image-20230822112348831.png)

~~~java
public static <T extends Comparable<T>>
void travelPost(BinaryTreeNode<T> node, Consumer<T> consumer) {
    if (node == null) return;
    travelPost(node.leftChild, consumer);
    travelPost(node.rightChild, consumer);
    consumer.accept(node.data);
}
~~~

如图所示，将树T画在二维平面上，并假设所有节点和边均不透明。于是从左侧水平向右看去，未被遮挡的最高叶节点v称作**最高左侧可见叶节点（HLVFL）**，**即为后序遍历首先访问的节点**。请注意，该节点既可能是左孩子，也可能是右孩子，故在图中以垂直边示意它与其父节点之间的联边。

![image-20230822115615077](./assets/image-20230822115615077.png)

~~~java
public static <T extends Comparable<T>>
void travelPostIteration(BinaryTreeNode<T> x, Consumer<T> consumer) {
    Stack<BinaryTreeNode<T>> nodes = new Stack<>();
    if (x != null) nodes.push(x);
    while (!nodes.empty()) {
        if (x.parent != nodes.top())		//只有当前节点的父亲不是下一个要访问的节点，此时要对右子树遍历入栈
            gotoHLVFL(nodes);
        x = nodes.pop();
        consumer.accept(x.data);
    }
}


private static <T extends Comparable<T>>
void gotoHLVFL(Stack<BinaryTreeNode<T>> stack) {
    BinaryTreeNode<T> node;
    while ((node = stack.top()) != null) {
        if (node.leftChild != null) {				//尽可能地走左边
            if (node.rightChild != null)			//如果有右孩子，优先入栈
                stack.push(node.rightChild);
            stack.push(node.leftChild);
        } else {
            stack.push(node.rightChild);
        }
    }
    stack.pop();        //弹出空节点
}
~~~

下面给出一个实例：

![image-20230822123822785](./assets/image-20230822123822785.png)

### 层次遍历

有根性和有序性是层次遍历序列得以明确定义的基础。正因为确定了树根，各节点方可拥有深度这一指标，并进而依此排序；有序性则保证孩子有左、右之别，并依此确定同深度节点之间的次序。

~~~java
public static <T extends Comparable<T>>
void travelLevel(BinaryTreeNode<T> node, Consumer<T> consumer) {
    Queue<BinaryTreeNode<T>> queue = new Queue<>();
    queue.enqueue(node);
    while (!queue.empty()) {
        node = queue.dequeue();
        consumer.accept(node.data);
        if (node.leftChild != null)
            queue.enqueue(node.leftChild);
        if (node.rightChild != null)
            queue.enqueue(node.rightChild);
    }
}
~~~

![image-20230822120332468](./assets/image-20230822120332468.png)