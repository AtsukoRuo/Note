# 图

[TOC]



## 概念

图可以表示一般的二元关系，因此从从数据结构的角度分类，它属于**非线性结构（non-linear structure）**。

**图（graph）**，可定义为G = (V, E)。其中，集合V中的元素称作**顶点（vertex）**；集合E中的元素分别对应于V中的某一对顶点(u, v)，表示它们之间存在某种关系，故亦称作**边（edge）**。从计算的需求出发，我们约定V和E均为有限集，通常将其规模分别记n = |V|和e = |E|。

若边(u, v)所对应顶点u和v的次序无所谓，则称作**无向边（undirected edge）**反之若u和v不对等，则称**(u, v)为有向边（directed edge）**。有向边(u, v)从u指向v，其中u称作该边的**起点（origin）**或尾顶点（tail），而v称作该边的**终点（destination）**或头顶点（head）。

若E中各边均无方向，则G称作**无向图（undirected graph，简称undigraph）**。若E中只含有向边，则G称作**有向图（directed graph，简称digraph）**。若E同时包含无向边和有向边，则G称作**混合图（mixed graph）**。相对而言，有向图的通用性更强，因为无向图和混合图都可转化为有向图。

![image-20230822152147758](assets/image-20230822152147758.png)

任何边e = (u, v)，称顶点u和v彼此**邻接（adjacent）**，互为邻居；而它们都与边e彼此**关联（incident）**。在无向图中，与顶点v关联的边数，称作v的**度数（degree）**，记作deg(v)。

对于有向边e = (u, v)，e称作u的**出边（outgoing edge）**、v的**入边（incoming edge）**。v的出边总数称作其**出度（out-degree）**，记作outdeg(v)；入边总数称作其**入度（in-degree）**，记作indeg(v)。

连接于同一顶点v之间的边(v, v)，称作**自环（self-loop）**，不含任何自环的图称作**简单图（simple graph）**，也是本书主要讨论的对象。



![image-20230822152332004](assets/image-20230822152332004.png)

所谓**路径**或**通路（path）**，就是由m + 1个顶点与m条边交替而成的一个序列：
$$
\pi = \{v_0, e_1, v_1, e_2, ..., e_m, v_m\} \quad \forall0 < i \leq m,e_i=(v_{i-1}, v_i)
$$
其中沿途边的总数$m$，亦称作通路的长度，记作$|\pi| = m$。也可以简化表述为
$$
\pi = \{v_0, v_1, ... ,v_m\}
$$
沿途顶点互异的通路，称作**简单通路（simple path）**。

对于长度$m \geq1$的通路$\pi$，若起止顶点相同（即$v_0 = v_m$），则称作**环路（cycle）**。若沿途除$v_0 = v_m$外所有顶点均互异，则称作**简单环路（simple cycle）**。

不含任何环路的有向图，称作**有向无环图（directed acyclic graph, DAG）**。

经过图中各边一次且恰好一次的环路，称作**欧拉环路（Eulerian tour）**。经过图中各顶点一次且恰好一次的环路，称作**哈密尔顿环路（Hamiltonian tour）**

可以为每一条边$e$指定一个权重$W(e)$​。各边均带有权重的图，称作**带权图（weighted graph）**或带权网络（weighted network），有时也简称**网络（network）**，记作$G(V, E, W)$。

## 数据结构

图算法的时间、空间性能，却与图结构的具体实现方式紧密相关。

~~~java
class Vertex<T> {
    T data;             //数据域
    int inDegree;       //入度
    int outDegree;      //出度
    VStatus status;     //遍历时的状态
    int dTime;          //时间戳
    int fTime;          //时间戳
    int parent;         //在遍历树中的父节点
    int priority;       //在遍历树中的优先级

    private void init() {
        status = VStatus.UNDISCOVERED;
        dTime = -1;
        fTime = -1;
        parent = -1;
        priority = Integer.MAX_VALUE;
    }
    Vertex(T data) {
        this.data = data;
        init();
    }
    Vertex() {
        init();
    }
}
~~~

~~~java
class Edge<T> {
    T data;             // 数据域
    int weight;     	// 权重
    EType type;         // 边的类型
    int v;              // 关联节点，用于邻接表中

    Edge(T data, int weight) {
        this.data = data;
        this.weight = weight;
        type = EType.UNDETERMINED;
    }

    Edge(T data, int weight, int v) {
        this(data, weight);
        this.v = v;
    }
}
~~~

~~~java
//顶点状态
enum VStatus {
    UNDISCOVERED,
    DISCOVERED,
    VISITED;
}

//边在遍历树中所属的类型
enum EType {
    UNDETERMINED,
    TREE,
    CROSS,
    FORWARD,
    BACKWARD;
}
~~~





### 邻接矩阵

**邻接矩阵（adjacency matrix）**是图ADT最基本的实现方式：使用方阵`A[n][n]`表示由n个顶点构成的图，其中每个单元，各自负责描述一对顶点之间可能存在的邻接关系

![image-20230822153620443](assets/image-20230822153620443.png)



~~~java
public class GraphMatrix<VertexType, EdgeType>
    extends Graph<VertexType, EdgeType> {
    
    Vector<Vertex<VertexType>> V;       		//顶点集（向量）
    Vector<Vector<Edge<EdgeType>>> E;         	//边集（邻接矩阵）

    public GraphMatrix() {
        V = new Vector<Vertex<VertexType>>();
        E = new Vector<Vector<Edge<EdgeType>>>();
    }
	
    //顶点的get、set方法
    @Override public VertexType vertex(int i) { return V.get(i).data; }
    @Override public int inDegree(int i) { return V.get(i).inDegree; }
    @Override public int outDegree(int i) { return V.get(i).outDegree; }
    @Override public VStatus status(int i) { return V.get(i).status; }
    @Override public void status(int i, VStatus status) {V.get(i).status = status;}
    @Override public int dTime(int i) { return V.get(i).dTime; }
    @Override public void dTime(int i, int time) { V.get(i).dTime = time;}
    @Override public int fTime(int i) { return V.get(i).fTime; }
    @Override public void fTime(int i, int time) { V.get(i).fTime = time;}
    @Override public int parent(int i) { return V.get(i).parent; }
    @Override public void parent(int i, int parent) {V.get(i).parent = parent;}
    @Override public int priority(int i) { return V.get(i).priority; }
    @Override public void priority(int i, int priority) { V.get(i).priority = priority;}

    @Override
    public Iterator<Integer> getIteratorOfNode(int i) {
        return new Iterator<Integer>() {
            int index = 0;
            @Override
            public boolean hasNext() {
                return index != n;
            }
            @Override
            public Integer next() {
                while (!exists(i, index)) index += 1;
                return index++;
            }
        };
    }



    @Override public boolean exists(int i, int j) {return E.get(i).get(j) != null;}
    //edge的set、get方法
    @Override public EType type(int i, int j) {return E.get(i).get(j).type;}
    @Override public void type(int i, int j, EType type) {E.get(i).get(j).type = type;}
    @Override public EdgeType edge(int i, int j) {return E.get(i).get(j).data;}
    @Override public int weight(int i, int j) {return E.get(i).get(j).weight;}

	//插入一个顶点
    @Override
    public int insert(VertexType data) {
        for (int j = 0; j < n; j++)
            E.get(j).insert(null);
        n++;
        E.insert(new Vector<Edge<EdgeType>>(n, n));
        return V.insert(new Vertex<VertexType>(data));
    }

	//删除一个顶点
    @Override
    public VertexType remove(int i) {
        //先删(j, i)边
        for (int j = 0; j < n; j++) {
            if (exists(j, i)) {
                E.get(j).remove(i);
                V.get(j).outDegree -= 1;
            }
        }

        //再删(i, j)边
        for (int j = 0; j < n; j++) {
            if (exists(i, j)) {
                V.get(j).inDegree -= 1;
            }
        }
        E.remove(i);
        n -= 1;            //节点规模减1
        return V.remove(i).data;
    }

	//插入一条边
    @Override
    public void insert(EdgeType edge, int w, int i, int j) {
        if (exists(i,j)) return;
        E.get(i).insert(new Edge<>(edge, w), j);

        //更新边计数与关联顶点的度数
        e++;
        V.get(i).outDegree += 1;
        V.get(j).inDegree += 1;
    }

	//删除一条边
    @Override
    public EdgeType remove(int i, int j) {
        if (!exists(i,j)) return null;
        EdgeType edge = E.get(i).get(j).data;
        E.get(i).set(null, i);
        //更新边计数与关联顶点的度数
        e--;
        V.get(i).outDegree--;
        V.get(j).inDegree--;
        return edge;
    }

}
~~~

得益于向量，边的静态和动态操作也仅需$O(1)$时间。但是，顶点的动态操作接口均十分耗时。为了插入新的顶点，顶点集向量V[]需要添加一个元素；边集向量E[][]也需要增加一行，且每行都需要添加一个元素。顶点删除操作，亦与此类似。同时空间总量渐进地不超过$O(n^2 )$。

### 邻接表

然而实际应用所处理的图，所含的边通常远远少于$O(n^2 )$。比如在的**稀疏图（sparse graph）**中，边数渐进地不超过$O(n)$，仅与顶点总数大致相当。由此可见，邻接矩阵的空间效率之所以低，是因为其中大量单元所对应的边，通常并未在图中出现。我们可以使用向量来代替列表来解决这利用率低的问题。



![image-20230822160604667](assets/image-20230822160604667.png)



## 搜索

## 图算法

### 主要思路

从“数据结构决定遍历次序”的观点出发，将所有遍历算法概括并统一为最佳优先遍历这一模式。

### Case1 ：拓扑排序

### Case2：双连通域分解



