# Flutter框架层原理

[TOC]

Flutter中，一切都是Widget，当UI要发生变化时，我们不去直接修改DOM，而是通过更新状态，让Flutter UI 框架来根据新的状态来重新构建UI。

从创建到渲染的大体流程是：根据Widget生成Element，然后创建相应的`RenderObject`并关联到`Element.renderObject`属性上，最后再通过`RenderObject`来完成布局排列和绘制。总结一下，我们可以认为Flutter的UI系统包含三棵树：Widget树、Element树、渲染树。他们的依赖关系是：Element树根据Widget树生成，而渲染树又依赖于Element树，如下图所示。

![图14-1](assets/14-1.bd5c2d9d.png)

## Widget

Flutter 中万物皆为Widget。**widget 的功能就是“描述一个UI元素的配置信息”**，下面我们先来看一下 Widget 类的声明：

~~~dart
@immutable // 不可变的
abstract class Widget extends DiagnosticableTree {
  const Widget({ this.key });

  final Key? key;

  @protected
  @factory
  Element createElement();

  @override
  String toStringShort() {
    final String type = objectRuntimeType(this, 'Widget');
    return key == null ? type : '$type-$key';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;
  }

  @override
  @nonVirtual
  bool operator ==(Object other) => super == other;

  @override
  @nonVirtual
  int get hashCode => super.hashCode;

  static bool canUpdate(Widget oldWidget, Widget newWidget) {
    return oldWidget.runtimeType == newWidget.runtimeType
        && oldWidget.key == newWidget.key;
  }
  ...
}
~~~

- `@immutable` 代表 Widget 是不可变的
- `widget`类继承自`DiagnosticableTree`，`DiagnosticableTree`即“诊断树”，主要作用是提供调试信息。



既然 Widget 只是描述一个UI元素的配置信息，那么真正的布局、绘制是由谁来完成的呢？Flutter 框架的处理流程是这样的：

1. 根据 Widget 树生成一个 Element 树，Element 树中的节点都继承自 `Element` 类。
2. 根据 Element 树生成 Render 树（渲染树），渲染树中的节点都继承自`RenderObject` 类。
3. 根据渲染树生成 Layer 树，然后上屏显示，Layer 树中的节点都继承自 `Layer` 类。

真正的布局和渲染逻辑在 Render 树中，Element 是 Widget 和 RenderObject 之间的桥梁。

![图2-2](assets/2-2.59d95f72.png)

`Widget`分为两种`StatelessWidget`与`StatefulWidget`。`StatelessWidget`用于不需要维护状态的场景。而`StatefulWidget`与之相反。

### StatelessWidget

`StatelessWidget`相对比较简单，它继承自`widget`类，重写了`createElement()`方法：

~~~dart
class MyCustomWidget extends StatelessWidget {
    @override
	StatelessElement createElement() => StatelessElement(this);
    
    @override
    Widgtet build(BuildContext context) {
        return Widget();
    }
}
~~~

### StatefulWidget

下面我们看看`StatefulWidget`的类定义：

~~~dart
abstract class StatefulWidget extends Widget {
  const StatefulWidget({ Key key }) : super(key: key);
    
  @override
  StatefulElement createElement() => StatefulElement(this);
    
  @protected
  State createState();
}
~~~

- `createState()` 用于创建和 StatefulWidget 相关的状态，它在StatefulWidget 的生命周期中可能会被多次调用。例如，当一个 StatefulWidget 同时插入到 widget 树的多个位置时，Flutter 框架就会调用该方法为每一个位置生成一个独立的State实例，其实，本质上就是一个`StatefulElement`对应一个State实例。这里多次插入的意思是：

  ~~~dart
  class CustomWidget extends StatelessWidget  {
    @override
    Widget build(BuildContext context) {
      StatefulWidget statefulWidget = new StatefulWidet();
        
      return Column(
      	children: [
              statefulWidget,			//多次插入，每一处插入都对应一个新的State实例
              statefulWidget,
              statefulWidget,
          ]
      )
    }
  }
  ~~~



一个 StatefulWidget 类会对应一个 State 类，State表示与其对应的 StatefulWidget 要维护的状态。State 中有两个常用属性：

1. `widget`，它表示与该 State 实例关联的 widget 实例。注意，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的 widget 实例在重新构建时可能会变化，如果 widget 被修改了，Flutter 框架会动态设置State. widget 为新的 widget 实例。
2. `context`。StatefulWidget对应的 BuildContext，作用同StatelessWidget 的BuildContext。



此外StatefulWidget中也可以保存状态，但是不推荐。因为多个State共享一个StatefulWidget的话，其中一个State调用setState来更新数据，而其他State却不能主动感知这一点，从而造成数据不一致问题。

~~~dart
class _MyAppState extends State<MyApp> {
  @override
  Widget build(BuildContext context) {
    StatefulWidget widget = CustomWidget();
    return Column(
      children: [widget,widget,widget,],
    );
  }
}

class CustomWidget extends StatefulWidget {
  CustomWidget({super.key});
  int _j = 10;
  @override
  State<CustomWidget> createState() => _CustomWidgetState();
}

class _CustomWidgetState extends State<CustomWidget> {
  int i = 10;
  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () {setState(() {i++; widget._j++;});},
      child: Container(
        width : 100, height: 100, color : Colors.red,
        child: Text("$i ${widget._j}"),
      )
    );
  }
}
~~~





### 生命周期

![Flutter 生命周期_生命周期](assets/resize,m_fixed,w_1184.webp)



State的生命周期大致分为三个阶段：初始化、状态变化、组件移除

- `createState`：构建一个 StatefulWidget 组件时，首先执行其**构造函数**，然后执行 **createState** 函数。相应State对象的构造函数就会被调用。

- `initState`：State对象首次插入到Element Tree时被调用。对于每一个State对象，Flutter 框架只会调用一次该回调。

  

  在此函数中不能调用 **BuildContext.dependOnInheritedWidgetOfExactType**。否则会抛出异常

  ~~~dart
  @override
  void initState() {
    super.initState();
    IconTheme iconTheme = context.dependOnInheritedWidgetOfExactType<IconTheme>();
  }
  ~~~

  解决方案：在didChangeDependencies中调用

  ~~~dart
  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    context.dependOnInheritedWidgetOfExactType<IconTheme>();
  }
  ~~~

  

  下面这段代码也会报异常

  ```dart
  @override
  void initState() {
    super.initState();
    showDialog(context: context,builder: (context){
      return AlertDialog();
    });
  }
  ```

  解决方案：

  ~~~dart
  @override
  void initState() {
    super.initState();
    //在该帧结束后，调用该回调函数
    WidgetsBinding.instance.addPostFrameCallback((timeStamp) {
      showDialog(context: context,builder: (context){
        return AlertDialog(title: Text('AlertDialog'),);
      });
    });
  }
  ~~~

  

- `didChangeDependencies()`：didChangeDependencies 方法在 initState 之后由 Framework 立即调用。另外，当此 **State** 对象的依赖项更改时被调用，比如其所依赖的 **InheritedWidget** 发生变化时， Framework 会调用此方法通知组件发生变化。典型的场景是当系统语言 Locale 或应用主题改变时，Flutter 框架会通知 widget 调用此回调。

  

  didChangeDependencies 方法调用后，组件的状态变为 **dirty**，立即调用 build 方法。

- `build()`：它主要是用于构建 widget 子树的，会在如下场景被调用：

  1. 调用 **initState** 方法后。
  2. 调用 **didUpdateWidget** 方法后。
  3. 收到对 **setState** 的调用后。
  4. 此 **State** 对象的依存关系发生更改后（例如，依赖的 **InheritedWidget** 发生了更改）。
  5. 调用 **deactivate** 之后，然后将 **State** 对象重新插入树的另一个位置。

  

- `reassemble()`：此回调是专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。

- `didUpdateWidget ()`：在 widget 重新构建时，Flutter 框架会调用`widget.canUpdate`来检测 widget 树中同一位置的新旧节点，然后决定是否需要更新，如果`widget.canUpdate`返回`true`则会调用此回调。

  Framework 调用完此方法后，会将组件设置为 **dirty** 状态，然后调用 **build** 方法

- `deactivate()`：当 State 对象从树中被移除时，会调用此回调。在一些场景下，Flutter 框架会将 State 对象重新插到树中，如包含此 State 对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey 来实现）。

- `dispose()`：当 State 对象从树中被永久移除时调用；通常在此回调中释放资源。



> **注意**：在继承`StatefulWidget`重写其方法时，对于包含`@mustCallSuper`标注的父类方法，都要在子类方法中调用父类方法。



`context`对象有一个`findAncestorStateOfType()`方法，该方法可以从当前节点沿着 widget 树向上查找指定类型的 StatefulWidget 对应的 State 对象。

~~~dart
ScaffoldState _state = context.findAncestorStateOfType<ScaffoldState>()!;
~~~

一般来说不应该直接获取StatefulWidget的状态，因为这些状态是私有的，不应该向外部暴露的。

在 Flutter 开发中便有了一个默认的约定：如果 StatefulWidget 的状态是希望暴露出的，应当在 StatefulWidget 中提供一个`of` 静态方法来获取其 State 对象，开发者便可直接通过该方法来获取；如果 State不希望暴露，则不提供`of`方法。

~~~dart
ScaffoldState _state = Scaffold.of(context);
~~~



GlobalKey 是 Flutter 提供的一种在整个 App 中引用 element 的机制。如果一个 widget 设置了`GlobalKey`，那么我们便可以通过`globalKey.currentWidget`获得该 widget 对象、`globalKey.currentElement`来获得 widget 对应的element对象，如果当前 widget 是`StatefulWidget`，则可以通过`globalKey.currentState`来获得该 widget 对应的state对象。

~~~dart
static GlobalKey<ScaffoldState> _globalKey= GlobalKey();

Scaffold(
    key: _globalKey , //设置key
    ...  
)
    
_globalKey.currentState.openDrawer() 		//获取Key
~~~



### context

实际上，`BuildContext`就是`widget`对应的`Element`，这样我们可以通过`context`在`StatelessWidget`和`StatefulWidget`的`build`方法中直接访问到`Element`对象。

它也可以看成当前 widget 在 widget 树中位置中执行”相关操作“的一个句柄（handle），比如它提供了从当前 widget 开始向上遍历 widget 树以及按照 widget 类型查找父级 widget 的方法，下面是在子树中获取父级 widget 的一个示例：

~~~dart
class ContextRoute extends StatelessWidget  {
  @override
  Widget build(BuildContext context) {
    return Container(
        child: Builder(builder: (context) {
          // 在 widget 树中向上查找最近的父级Scaffold  widget 
          Scaffold scaffold = context.findAncestorWidgetOfExactType<Scaffold>();
          return (scaffold.appBar as AppBar).title;
        }
      ),
    );
  }
}
~~~



### Element

Element就是Widget在UI树具体位置的一个实例化对象，Element的生命周期如下：

1. Framework 调用`Widget.createElement` 创建一个Element实例，记为`element`
2. Framework 调用 `element.mount(parentElement,newSlot)` ，mount方法中首先调用`element`所对应Widget的`createRenderObject`方法创建与`element`相关联的RenderObject对象，然后调用`element.attachRenderObject`方法将`element.renderObject`添加到渲染树中插槽指定的位置（这一步不是必须的，一般发生在Element树结构发生变化时才需要重新添加）。插入到渲染树后的`element`就处于“active”状态，处于“active”状态后就可以显示在屏幕上了（可以隐藏）。
3. 当有父Widget的配置数据改变时，同时其`State.build`返回的Widget结构与之前不同，此时就需要重新构建对应的Element树。为了进行Element复用，在Element重新构建前会先尝试是否可以复用旧树上相同位置的element，element节点在更新前都会调用其对应Widget的`canUpdate`方法，如果返回`true`，则复用旧Element，旧的Element会使用新Widget配置数据更新，反之则会创建一个新的Element。`Widget.canUpdate`主要是判断`newWidget`与`oldWidget`的`runtimeType`和`key`是否同时相等，如果同时相等就返回`true`，否则就会返回`false`。根据这个原理，当我们需要强制更新一个Widget时，可以通过指定不同的Key来避免复用。
4. 当有祖先Element决定要移除`element` 时（如Widget树结构发生了变化，导致`element`对应的Widget被移除），这时该祖先Element就会调用`deactivateChild` 方法来移除它，移除后`element.renderObject`也会被从渲染树中移除，然后Framework会调用`element.deactivate` 方法，这时`element`状态变为“inactive”状态。
5. “inactive”态的element将不会再显示到屏幕。为了避免在一次动画执行过程中反复创建、移除某个特定element，“inactive”态的element在当前动画最后一帧结束前都会保留，如果在动画执行结束后它还未能重新变成“active”状态，Framework就会调用其`unmount`方法将其彻底移除，这时element的状态为`defunct`,它将永远不会再被插入到树中。
6. 如果`element`要重新插入到Element树的其他位置，如`element`或`element`的祖先拥有一个GlobalKey（用于全局复用元素），那么Framework会先将element从现有位置移除，然后再调用其`activate`方法，并将其`renderObject`重新attach到渲染树。



大多数情况下只需要关注Widget树就行，Flutter框架已经将对Widget树的操作映射到了Element树上，这可以极大的降低复杂度，提高开发效率。



下面我们直接通过纯粹的Element来模拟一个StatefulWidget

~~~dart
class HomeView extends ComponentElement{
  HomeView(Widget widget) : super(widget);
  String text = "123456789";

  @override
  Widget build() {
    Color primary=Theme.of(this).primaryColor; //1
    return GestureDetector(
      child: Center(
        child: TextButton(
          child: Text(text, style: TextStyle(color: primary),),
          onPressed: () {
            var t = text.split("")..shuffle();
            text = t.join();
            markNeedsBuild(); //点击后将该Element标记为dirty，Element将会rebuild
          },
        ),
      ),
    );
  }
}
~~~

- 上面`build`方法不接收参数，这一点和在`StatelessWidget`和`StatefulWidget`中`build(BuildContext)`方法不同。代码中需要用到`BuildContext`的地方直接用`this`代替即可，因为当前对象本身`this`就是`Element`实例。
- 当`text`发生改变时，我们调用`markNeedsBuild()`方法将当前Element标记为dirty即可，标记为dirty的Element会在下一帧中重建。实际上，`State.setState()`在内部也是调用的`markNeedsBuild()`方法。



并且我们还需要提供一个适配器：

~~~dart
class CustomHome extends Widget {
  @override
  Element createElement() {
    return HomeView(this);
  }
}
~~~



现在我们可以知道：StatelessWidget与StatefulWidget都是封装了Widget中的createElement方法，使得创建Element更加方便。

### RenderObject

每个`Element`都对应一个`RenderObject`，我们可以通过`Element.renderObject` 来获取

## 硬件绘图基本原理

显示器（屏幕）是由一个个物理像素点组成的。每一个像素点可以发出多种颜色，1600万色的屏幕就是指一个像素点可以显示出1600万种颜色，而显示器颜色是有RGB三基色组成，所以1600万大约为2的24次方，即每个基本色（R、G、B）深度扩展至8 bit(位)

显示器会发出一个垂直同步信号（如vsync）， 60Hz的屏幕就会一秒内发出 60次这样的信号。CPU将计算好的显示内容提交给 GPU，GPU渲染后放入帧缓冲区，然后视频控制器按照同步信号从帧缓冲区取帧数据传递给显示器显示。



## RenderObject

Flutter 组件库中的很多基础组件都不是通过`StatelessWidget` 和 `StatefulWidget` 来实现的，比如 Text、Column、Align等，而是通过自定义 RenderObject 来实现的。

`RenderObject`就是渲染树中的一个对象，它主要的作用是『 Layout 』、『 Paint 』、『 Hit Testing 』。注意：build的执行过程由element负责。

`RenderObject`类本身实现了一套基础的布局和绘制协议，但是并没有定义子节点模型（子节点的数量）。 它也没有定义坐标系统（是在笛卡尔坐标中，还是极坐标）和具体的布局协议（是通过宽高，还是通过constraint），或者是否由父节点在子节点布局之前或之后设置子节点的大小和位置等。为此，Flutter框架提供了一个`RenderBox`和一个 `RenderSliver`类，它们都是继承自`RenderObject`，布局坐标系统采用笛卡尔坐标系，屏幕的(top, left)是原点。



每个`Element`都对应一个`RenderObject`，我们可以通过`Element.renderObject` 来获取。`RenderObject`拥有一个`parent`和一个`parentData` 属性，

- `parent`：指向渲染树中自己的父节点，
- `parentData`：在父组件的布局过程，会把布局信息保存到子组件的parentData属性中，然后在后续的绘制阶段被使用。

![img](assets/8d12fd36ce3a4e479210bb60c26ea511tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)



## 启动流程和渲染管线

一次绘制过程，我们称其为一**帧（frame）**。注意Flutter UI 框架的 frame 并不是每次屏幕刷新时都会重新绘制。如果应用状态改变需要刷新 UI，则需要通过调用`scheduleFrame()`去请求新的 frame，然后执行`drawFrame()`。



Flutter 应用执行过程简单来讲分为 idle 和 frame 两种状态。

当有新的 frame 到来时，就进入了frame状态，具体处理过程就是依次执行四个任务队列：`transientCallbacks`、`midFrameMicrotasks`、`persistentCallbacks`、`postFrameCallbacks`。当四个任务队列执行完毕后当前 frame 结束，然后切换到idle状态。

~~~dart
enum SchedulerPhase {
  idle,
  transientCallbacks,
  midFrameMicrotasks,
  persistentCallbacks,
  postFrameCallbacks,
}
~~~

- `idle`：空闲状态表示页面未发生变化，并不需要重新渲染。微任务、定时器回调或者用户事件回调
- `transientCallbacks`： 执行”临时“的回调任务，动画回调会在该阶段执行。
- `midFrameMicrotasks`：在执行临时任务时可能会产生一些新的微任务，比如在执行第一个临时任务时创建了一个Future，且这个 Future 在所有临时任务执行完毕前就已经 resolve 了，这中情况Future 的回调将在[midFrameMicrotasks]阶段执行
- `persistentCallbacks`：渲染管线
- `postFrameCallbacks`：执行一些清理工作



drawFrame方法在persistentCallbacks阶段执行

```dart
void drawFrame() {
  buildOwner!.buildScope(renderViewElement!); // 1.重新构建widget树
  //下面是 展开 super.drawFrame() 方法
  pipelineOwner.flushLayout(); 				// 2.更新布局
  pipelineOwner.flushCompositingBits(); 	// 3.更新“层合成”信息
  pipelineOwner.flushPaint(); 				// 4.重绘
  if (sendFramesToEngine) {
    renderView.compositeFrame(); 			// 5.上屏，会将绘制出的bit数据发送给GPU
    ...
  }
}
```

1. 重新构建widget树
2. 更新布局
3. 更新“层合成”信息
4. 重绘
5. 上屏：将绘制的产物显示在屏幕上

我们称上面的5步为` rendering pipeline`



![图14-4](assets/14-4.775d0196.png)

### setState流程

setState 调用后：

1. 首先调用当前 element 的 markNeedsBuild 方法，将当前 element标记为 dirty 。
2. 接着调用 scheduleBuildFor，将当前 element 添加到pipelineOwner的 dirtyElements 列表。
3. 最后请求一个新的 frame



## 布局

Layout（布局）过程主要是确定每一个组件的布局信息（大小和位置），Flutter 的布局过程如下：

1. 父节点向子节点传递约束（constraints）信息，限制子节点的最大和最小宽高。
2. 子节点根据约束信息确定自己的大小（size）。
3. 父节点根据特定布局规则（不同布局组件会有不同的布局算法）确定每一个子节点在父节点布局空间中的位置，用偏移 offset 表示。
4. 递归整个过程，确定出每一个节点的大小和位置。

可以看到，组件的大小是由自身决定的，而组件的位置是由父组件决定的。



### SingleChildRenderObjectWidget

~~~dart
class CustomCenter extends SingleChildRenderObjectWidget {
  const CustomCenter({super.key, required super.child});

  @override
  RenderObject createRenderObject(BuildContext context) {
    return RenderCustomCenter();
  }
}

//这里直接继承RenderShiftedBox，它会帮我们实现布局之外的一些功能，这样我们只需要重写performLayout。 而直接继承 RenderObject 会更接近底层一点，但这需要我们自己手动实现一些和布局无关的功能
class RenderCustomCenter extends RenderShiftedBox {
  RenderCustomCenter();

  @override
  void performLayout() {
    //1. 先对子组件进行layout
    child!.layout(
      constraints.loosen(),
      parentUsesSize: true,		//这里true说明组件依赖于子组件的大小
    );

    //2.根据子组件的大小确定自身的大小
    size = constraints.constrain(Size(
        constraints.maxWidth == double.infinity
            ? child!.size.width
            : double.infinity,
        constraints.maxHeight == double.infinity
            ? child!.size.height
            : double.infinity));

    //3.根据父节点子节点的大小，算出子节点在父节点中居中之后的偏移，然后将这个偏移保存在
    //  子节点的parentData中，在后续的绘制阶段会用到
    BoxParentData parentData = child!.parentData as BoxParentData;
    parentData.offset = ((size - child!.size) as Offset) / 2;
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    if (child != null) {
      //从child.parentData中取出子节点相对当前节点的偏移，加上当前节点在屏幕中的偏移，
      //便是子节点在屏幕中的偏移。
      final BoxParentData childParentData = child!.parentData! as BoxParentData;
      context.paintChild(child!, childParentData.offset + offset);
    }
  }
}

~~~

### MultiChildRenderObjectWidget

~~~dart
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';

class LeftRightBox extends MultiChildRenderObjectWidget {
  LeftRightBox({
    super.key,
    required List<Widget> children,
  }) : assert(children == 2);

  @override
  RenderObject createRenderObject(BuildContext context) {
    return RenderLeftRight();
  }
}

class LeftRightParentData extends ContainerBoxParentData<RenderBox> {}


//这两个 mixin 实现了通用的绘制和事件处理相关逻辑
class RenderLeftRight extends RenderBox
    with
        ContainerRenderObjectMixin<RenderBox, LeftRightParentData>,
        RenderBoxContainerDefaultsMixin<RenderBox, LeftRightParentData> {
  @override
  void setupParentData(covariant RenderObject child) {
    if (child.parentData is! LeftRightParentData) {
      child.parentData = LeftRightParentData();
    }
  }

  @override
  void performLayout() {
    final BoxConstraints constraints = this.constraints;
    RenderBox leftChild = firstChild!;

    LeftRightParentData childParentData =
        leftChild.parentData! as LeftRightParentData;

    RenderBox rightChild = childParentData.nextSibling!;

    //限制右孩子宽度不超过总宽度一半
    rightChild.layout(
      constraints.copyWith(maxWidth: constraints.maxWidth / 2),
      parentUsesSize: true,
    );

    //调整右子节点的offset
    childParentData = rightChild.parentData! as LeftRightParentData;
    childParentData.offset = Offset(
      constraints.maxWidth - rightChild.size.width,
      0,
    );

    leftChild.layout(
      //左侧剩余的最大宽度
      constraints.copyWith(
        maxWidth: constraints.maxWidth - rightChild.size.width,
      ),
      parentUsesSize: true,
    );

    //设置LeftRight组件自身的size
    size = Size(
      constraints.maxWidth,
      max(leftChild.size.height, rightChild.size.height),
    );
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    defaultPaint(context, offset);
  }

  @override
  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) {
    return defaultHitTestChildren(result, position: position);
  }
}

~~~



### 布局更新

每个组件的 renderObject 中都有一个 `_relayoutBoundary` 属性指向自身的布局边界节点，如果当前节点布局发生变化后，自身到其布局边界节点路径上的所有的节点都需要 relayout。

![图14-5](assets/14-5.2a5abf58.png)

在上张图中，Column2 就是 Text3 的 relayoutBoundary 



如果一个父组件满足以下四种情况之一，则它便是 relayoutBoundary ：

- 组件为根组件；Flutter 应用的根组件是 RenderView，它的默认大小是当前设备屏幕大小。
- 父组件传递给自身的约束是一个严格约束
- 组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。这种情况组件的 sizedByParent 属性必须为 true
- 父组件的大小不依赖当前组件大小时。parentUsesSize为false

对应的代码实现是：

~~~dart
// parent is! RenderObject 为 true 时则表示当前组件是根组件，因为只有根组件没有父组件。
if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) {
  _relayoutBoundary = this;
} else {
  _relayoutBoundary = (parent! as RenderObject)._relayoutBoundary;
}
~~~

总结来说就是：**组件自身的大小变化不会影响父组件**





**当组件布局发生变化时，它需要调用 `markNeedsLayout` 方法来更新布局**，它的功能主要有两个：

1. 将自身到其 relayoutBoundary 路径上的所有节点标记为 “需要布局” 。
2. 请求新的 frame；在新的 frame 中会对标记为“需要布局”的节点重新布局。

~~~dart
void markNeedsLayout() {
   _needsLayout = true;
  if (_relayoutBoundary != this) { // 如果不是布局边界节点
    markParentNeedsLayout(); // 递归调用前节点到其布局边界节点路径上所有节点的方法 markNeedsLayout
  } else {// 如果是布局边界节点 
    if (owner != null) {
      // 将布局边界节点加入到 pipelineOwner._nodesNeedingLayout 列表中
      owner!._nodesNeedingLayout.add(this); 
      // 该函数最终会请求新的 frame
      owner!.requestVisualUpdate();
    }
  }
}
~~~

新的 frame 到来时就会执行 `drawFrame` 方法（可以参考上一节）：

~~~dart
void drawFrame() {
  pipelineOwner.flushLayout(); //重新布局
  pipelineOwner.flushCompositingBits();
  pipelineOwner.flushPaint();
  ...
}
~~~

flushLayout() 中会对之前添加到 `_nodesNeedingLayout` 中的节点重新布局，我们看一下其核心源码：

~~~dart
void flushLayout() {
  while (_nodesNeedingLayout.isNotEmpty) {
    final List<RenderObject> dirtyNodes = _nodesNeedingLayout;
    _nodesNeedingLayout = <RenderObject>[]; 
    //按照节点在树中的深度从小到大排序后再重新layout
    for (final RenderObject node in dirtyNodes..sort((a,b) => a.depth - b.depth)) {
      if (node._needsLayout && node.owner == this)
        node._layoutWithoutResize(); //重新布局
    }
  }
}
~~~

看一下 `_layoutWithoutResize` 实现

~~~dart
void _layoutWithoutResize() {
  performLayout(); // 重新布局；会递归布局后代节点
  _needsLayout = false;
  markNeedsPaint(); //布局更新后，UI也是需要更新的
}
~~~

 performLayout 中需要调用子组件的 layout 方法先对子组件进行布局，我们看一下 layout 的核心流程：

~~~dart
void layout(Constraints constraints, { bool parentUsesSize = false }) {
  RenderObject? relayoutBoundary;
  // 先确定当前组件的布局边界
  if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) {
    relayoutBoundary = this;
  } else {
    relayoutBoundary = (parent! as RenderObject)._relayoutBoundary;
  }
    
  // _needsLayout 表示当前组件是否被标记为需要布局
  // _constraints 是上次布局时父组件传递给当前组件的约束
  // _relayoutBoundary 为上次布局时当前组件的布局边界
  // 所以，当当前组件没有被标记为需要重新布局，且父组件传递的约束没有发生变化，
  // 且布局边界也没有发生变化时则不需要重新布局，直接返回即可。
  if (!_needsLayout && constraints == _constraints && relayoutBoundary == _relayoutBoundary) {
    return;
  }
  // 如果需要布局，缓存约束和布局边界
  _constraints = constraints;
  _relayoutBoundary = relayoutBoundary;

  // 后面解释
  if (sizedByParent) {
    performResize();
  }
  // 执行布局
  performLayout();
  // 布局结束后将 _needsLayout 置为 false
  _needsLayout = false;
  // 将当前组件标记为需要重绘（因为布局发生变化后，需要重新绘制）
  markNeedsPaint();
}
~~~

performLayout 中确定当前组件的大小时通常会依赖子组件的大小，如果 sizedByParent 为 true，则当前组件的大小就不依赖子组件大小了。为了逻辑清晰，Flutter 框架中约定，当sizedByParent 为 true 时，确定当前组件大小的逻辑应抽离到 performResize() 中。这种情况下 performLayout 主要的任务便只有两个：对子组件进行布局、确定子组件在当前组件中的布局起始位置偏移。

## 绘制
