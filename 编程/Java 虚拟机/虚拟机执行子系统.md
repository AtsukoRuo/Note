# 虚拟机执行子系统
[TOC]

## 基石

代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。字节码是与机器指令集无关的、平台中立的格式。

Java虚拟机不与任何程序语言（包括Java）绑定，它只与“Class文件”关联。这就要求字节码指令集必须拥有足够强大的语法表达能力！

![image-20240130122052357](assets/image-20240130122052357.png)

Java技术能够一直保持着非常良好的向后兼容性，Class文件结构的稳定功不可没。尽管不同版本的《Java虚拟机规范》对Class文件格式进行了几次更新，但基本上只是在原有结构基础上新增内容、扩充功能，并未对已定义的内容做出修改。

虚拟机实现的方式主要有以下两种：

- 将输入的Java虚拟机代码在加载时或执行时翻译成另一种虚拟机的指令集；
- 将输入的Java虚拟机代码在加载时或执行时翻译成宿主机处理程序的本地指令集

## Class 文件格式

Class文件中的指令之间并没有分隔符，而是以8字节作为基本单位。Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：「无符号数」和「表」。

- 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数
- 表是由多个无符号数或者其他表作为数据项构成的复合数据类型



Class 文件具体由以下几个构成:

- 魔数
- 版本信息
- 常量池
- 访问标志
- 类索引、父类索引、接口索引集合
- 字段表集合
- 方法表集合
- 属性表集合



可以使用`javap -verbose`来打印Class文件的格式

### 魔数

魔数：Class 文件的头 4 个字节称为魔数（`0xCAFEBABE`），用于确定是否为Class文件。

### 版本信息

版本信息：紧接着魔数的4个字节是Class文件的版本号：第5和第6个字节是**次版本号（Minor Version）**，第7和第8个字节是**主版本号（Major Version）**。

高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件。

在Java12后，次版本号用于标识对「技术预览版」功能的支持。如果Class文件中使用了该版本JDK尚未列入正式特性清单中的预览功能，则必须把次版本号设置为65535，其余情况设置为0即可。

### 常量池

版本信息之后就是常量池，常量池中存放两种类型的常量：

- 字面值常量，例如在程序中定义的字符串、被 final 修饰的值。
- 符号引用，它主要包括：
  - 被模块导出的包名（Package）
  - 类和接口的全限定名（Fully Qualified Name）
  - 字段的名称和描述符（Descriptor）
  - 方法的名称和描述符
  - 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）
  - 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）

常量池的特点

- 常量池中常量数量不固定，因此常量池开头放置一个 u2 类型的无符号数，用来存储当前常量池的容量。注意，它是从1开始计数的，也就是说如果有$x$个常量，那么这个值就为$x+1$。而其他所有的容量计数是从0开始的
- 常量池的每一项常量都是一个表，表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量属于哪种常量类型。

| 类型                             | tag  | 描述                   |
| -------------------------------- | ---- | ---------------------- |
| CONSTANT_utf8_info               | 1    | UTF-8 编码的字符串     |
| CONSTANT_Integer_info            | 3    | 整型字面量             |
| CONSTANT_Float_info              | 4    | 浮点型字面量           |
| CONSTANT_Long_info               | 5    | 长整型字面量           |
| CONSTANT_Double_info             | 6    | 双精度浮点型字面量     |
| CONSTANT_Class_info              | 7    | 类或接口的符号引用     |
| CONSTANT_String_info             | 8    | 字符串类型字面量       |
| CONSTANT_Fieldref_info           | 9    | 字段的符号引用         |
| CONSTANT_Methodref_info          | 10   | 类中方法的符号引用     |
| CONSTANT_InterfaceMethodref_info | 11   | 接口中方法的符号引用   |
| CONSTANT_NameAndType_info        | 12   | 字段或方法的符号引用   |
| CONSTANT_MethodHandle_info       | 15   | 表示方法句柄           |
| CONSTANT_MethodType_info         | 16   | 标识方法类型           |
| CONSTANT_InvokeDynamic_info      | 18   | 表示一个动态方法调用点 |



CONSTANT_Class_info的结构：

| 类型 | 名称       | 数量 |
| ---- | ---------- | ---- |
| u1   | tag        | 1    |
| u2   | name_index | 1    |

- tag 是标志位，用于区分常量类型；

- name_index是常量池的索引值，它指向常量池中一个 CONSTANT_Utf8_info类型常量，此常量代表了这个类（或者接口）的全限定名

CONSTANT_Utf8_info 型常量的结构如下：

| 类型 | 名称   | 数量   |
| ---- | ------ | ------ |
| u1   | tag    | 1      |
| u2   | length | 1      |
| u1   | bytes  | length |

tag 是当前常量的类型；length 表示这个字符串的长度；bytes 是这个字符串的内容，以UTF-8缩略编码（不是普通的UTF-8编码）。由于u2类型能表达的最大值65535。所以超过64KB 英文字符的变量或方法名，是无法编译的。



![image-20240130130545478](assets/image-20240130130545478.png)

![image-20240130130556564](assets/image-20240130130556564.png)

![image-20240130130605651](assets/image-20240130130605651.png)

### 访问标志

说明Class文件所描述的类的访问信息。

![image-20240130130849452](assets/image-20240130130849452.png)

### 类索引、父类索引与接口索引集合

类索引（this_class）和父类索引（super_class）都是一个u2类数据，而接口索引集合 （interfaces）是一组u2数据的集合，Class文件中由这三项数据来确定该类型的继承关系。

类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。它们各自指向一个`CONSTANT_Class_info`类型的常量

对于接口索引集合，第一个u2数据为接口计数器（interfaces_count），表示实现接口的数量。

### 字段表集合

![image-20240130131828598](assets/image-20240130131828598.png)

字段修饰符放在`access_flags`中，

![image-20240130131854350](assets/image-20240130131854350.png)

`name_index`和`descriptor_index`。它们都是对常量池项的引用，分别代表着简单名称以及描述符。其中，描述符是用来说明字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。

![image-20240130132043358](assets/image-20240130132043358.png)

对于数组类型，每一维度使用一个前置的`[`字符来描述，如一个`java.lang.String`[][]类型的二维数组将被记录成`[[Ljava/lang/String`，一个整型数组`int[]`将被记录成`[I`。

对于方法，按照参数列表、返回值的顺序来描述。方法`java.lang.String toString()`的描述符 为`()Ljava/lang/String`，方法`int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target， int targetOffset，int targetCount，int fromIndex)`的描述符为`([CII[CIII)I`

`attributes_count、attributes`描述了属性表，我们会单独介绍的。

字段表集合中不列出从父类或者父接口中继承而来的字段。但是有可能会额外添加一些字段，例如内部类中为了保持对外部类的访问性，编译器会自动添加指向外部类实例的字段。

### 方法表集合

![image-20240130133003982](assets/image-20240130133003982.png)

![image-20240130133056792](assets/image-20240130133056792.png)

属性表中保存了方法的代码

### 属性表集合

任何编译器可以向属性表中写入自定义的信息。Java虚拟机运行时会忽略掉它不认识的属性。对于每一个属性，它的名称都要从常量池中引用一个`CONSTANT_Utf8_info`类型的常量来表示， 而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。

![image-20240130134121893](assets/image-20240130134121893.png)

`attribute_name_index`是一项指向`CONSTANT_Utf8_info`型常量的索引，代表了该属性的名称。`attribute_length`指示了属性表的长度（包括name_index、length）

虚拟机规范中的预定义属性。

![image-20240130133427863](assets/image-20240130133427863.png)

![image-20240130133458537](assets/image-20240130133458537.png)



Java方法的字节码指令存储在Code属性内。注意，接口中的方法声明或者抽象类中的抽象方法并不存在对应的Code属性。

![image-20240130134306745](assets/image-20240130134306745.png)

- `max_stack`代表了操作数栈（Operand Stack）的深度最大值。

- `max_locals`代表了局部变量表所需的存储空间，单位为变量槽（Slot）。为了节约槽的数量，Java虚拟机会根据作用域对其进行复用。（注意，this变量会在局部变量表中）

- code_length和code用来存储Java源程序编译后生成的字节码指令。code是一个u1数据，可以支持256条指令（x86指令集都有上千条指令）。

  此外，虽然code_length是u4数据，但是《Java虚拟机规范》中明确规定了一个方法不允许超过65535条字节码指令。

- exception_table_length与exception_table用于描述异常表的。

  ![image-20240130153426800](assets/image-20240130153426800.png)

  如果当字节码从第start_pc行到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。当 catch_type的值为0时，代表任意异常情况都需要转到handler_pc处进行处理。



Exceptions属性（不是异常表）列举出方法中可能抛出的受查异常（Checked Excepitons）

![image-20240130155136994](assets/image-20240130155136994.png)

`exception_index_table`是一个指向常量池中 `CONSTANT_Class_info `型常量的索引，代表了该受查异常的类型。



`LineNumberTable`属性用于描述Java源码行号与对应字节码所处的行号之间的映射关系。在Javac中使用`-g：none`或`-g：lines`选项，来决定是否保存这种映射关系。

![image-20240130155407961](assets/image-20240130155407961.png)

`line_number_info`表包含`start_pc`和`line_number`两个u2类型的数据项，前者是字节码行号，后者是Java源码行号。





LocalVariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的映射关系。在Javac中使用`-g：none`或`-g：vars`选项，来决定是否保存这种映射关系。如果不保存，IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名。

![image-20240130160459220](assets/image-20240130160459220.png)

![image-20240130160507393](assets/image-20240130160507393.png)

`start_pc`和`length`属性分别代表了这个局部变量的生命周期开始的字节码偏移量，及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。

name_index 和 descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引，分别代表了局部变量的名称以及局部变量的描述符。 index是局部变量的在栈帧中变量槽的初始位置。

在引入泛型之后，由于描述符中参数化类型会被擦除掉，因此出现了LocalVariableTypeTable属性，使用字段的特征签名来完成对泛型的描述。



SourceFile属性用于记录生成这个Class文件的源码文件名称

![image-20240130160955429](assets/image-20240130160955429.png)



SourceDebugExtension属性用于存储额外的代码调试信息。

![image-20240130161116222](assets/image-20240130161116222.png)



ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有静态变量才可以使用这项属性。

对实例变量的赋值是在实例构造器()方法中进行的；而对类变量（Static字段）的赋值，有两种方式可以选择：

- 在类构造器()方法中
- 使用ConstantValue属性

目前Oracle公司实现的Javac编译器的选择是，对于final static 基本类型/String 变量使用ConstantValue方式

![image-20240130161557572](assets/image-20240130161557572.png)

constantvalue_index数据项代表了常量池中一个字面量常量的引用，根据字段类型的不同，字面 量可以是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、 CONSTANT_Integer_info和CONSTANT_String_info常量中的一种。



InnerClasses属性用于记录内部类与宿主类之间的关联。

![image-20240130161656915](assets/image-20240130161656915.png)

![image-20240130161800760](assets/image-20240130161800760.png)

- `inner_class_info_index`和`outer_class_info_index`都是指向常量池中CONSTANT_Class_info型常量的索引，分别代表了内部类和宿主类的符号引用。
- `inner_name_index`是指向常量池中CONSTANT_Utf8_info型常量的索引，代表这个内部类的名称， 如果是匿名内部类，这项值为0。
- `inner_class_access_flags`是内部类的访问标志

  ![image-20240130162230068](assets/image-20240130162230068.png)



Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通 过代码中使用“@deprecated”注解进行设置。

Synthetic属性代表此字段或者方法并不是由Java源码编译而来的，而是由编译器自行添加的（例如，生成枚举类的一些方法）

![image-20240130162449075](assets/image-20240130162449075.png)

其中attribute_length数据项的值必须为0x00000000，因为它们是布尔属性。



其他的属性：

- StackMapTable属性会在虚拟机类加载的字节码验证阶段被Type Checker使用。
- Signature属性会记录泛型签名信息，这样反射API就能够获取的泛型类型。
- BootstrapMethods属性与invokedynamic指令相关，被用于实现Java的动态类型语言支持，例如Lambda表达式。
- MethodParameters主要用于存储方法参数的额外信息
- 模块描述文件（module-info.java）最终是要编译成一个独立的Class文件来存储的，所以，Class文件格式也扩展了Module、ModulePackages和 ModuleMainClass三个属性，用于支持Java模块化相关功能。
- 为了存储源码中注解信息，Class文件支持RuntimeVisibleAnnotations、 RuntimeInvisibleAnnotations、RuntimeVisibleParameterAnnotations和RuntimeInvisibleParameterAnnotations四个属性

## 字节码指令

由于Java虚拟机采用「面向操作数栈」而不是「面向寄存器」的架构，大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。

放弃了操作数长度对齐，以及一个字节来代表操作码，是为了尽可能获得短小精干的编译代码，追求尽可能小数据量、高传输效率，这与Java语言面向网络和智能家电的设计初衷是相契合的。

### 数据类型

![image-20240130182242457](assets/image-20240130182242457.png)

![image-20240130182252113](assets/image-20240130182252113.png)

编译器会将byte和short符号扩展（Sign-Extend）为int，将boolean和char零位扩展（Zero-Extend）为int。

### 加载和存储指令

加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括：

- 将一个局部变量加载到操作栈：`iload`等
- 将一个数值从操作数栈存储到局部变量表：`istore`等
- 将一个常量加载到操作数栈：`bipush`等
- 扩充局部变量表的访问索引：`wide`

### 运算指令

算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶

- 加法指令：iadd、ladd、fadd、dadd 
- 减法指令：isub、lsub、fsub、dsub 
- 乘法指令：imul、lmul、fmul、dmul 
- 除法指令：idiv、ldiv、fdiv、ddiv 
- 求余指令：irem、lrem、frem、drem 
- 取反指令：ineg、lneg、fneg、dneg 
- 位移指令：ishl、ishr、iushr、lshl、lshr、lushr 
- 按位或指令：ior、lor 
- 按位与指令：iand、land 
- 按位异或指令：ixor、lxor 
- 局部变量自增指令：iinc 
- 比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp

《Java虚拟机规范》要求虚拟机实现在处理浮点数时，必须严格遵循IEEE 754规范

### 类型转换指令

Java虚拟机直接支持以下数值类型的宽化类型转换（Widening Numeric Conversion，即小范围类型向大范围类型的安全转换）：

- int类型到long、float或者double类型
- long类型到float、double类型
- float类型到double类型

与之相对的，处理窄化类型转换（Narrowing Numeric Conversion）时，就必须显式地使用转换指 令来完成，这些转换指令包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。

- 如果浮点值是NaN，那转换结果就是int或long类型的0。
- 如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整
- 从double类型到float类型做窄化转换的过程与IEEE 754中定义的一致

尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是《Java虚拟机规 范》中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。

### 对象创建与访问指令

- 创建类实例的指令：new
- 创建数组的指令：newarray、anewarray、multianewarray
- 访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic
- 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、 daload、aaload
- 将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、 dastore、aastore
- 取数组长度的指令：arraylength
- 检查类实例类型的指令：instanceof、checkcast

### 操作数栈管理指令

- 将操作数栈的栈顶一个或两个元素出栈：pop、pop2
- 将栈最顶端的两个数值互换：swap
- 复制栈顶一个或两个数值，并将复制值重新压入栈顶：dup、dup2、dup_x1、 dup2_x1、dup_x2、dup2_x2

### 控制转移指令

- 条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、 if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne
- 复合条件分支：tableswitch、lookupswitch
- 无条件分支：goto、goto_w、jsr、jsr_w、ret

### 方法调用和返回指令

- invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）
- invokestatic指令：用于调用类静态方法（static方法）
- invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。
- invokeinterface指令：用于调用接口方法
- invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法



方法返回指令包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一 条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用。

### 异常处理指令

在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现。

而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的，而是采用异常表来完成。

### 同步指令

Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义。

## 虚拟机类加载机制

Java虚拟机把描述类的Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终构建出可被虚拟机直接使用的Java类型，这个过程被称作「虚拟机的类加载机制」。

在Java语言里面，类型的加载、链接和初始化过程都是在程序运行期间完成的。虽然增加了性能开销，但是却拥有了动态扩展的语言特性。



一个类型的生命周期如下：加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading）七个阶段

![image-20240130205609823](assets/image-20240130205609823.png)

注意，解析阶段可能在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。

对于何时开始加载阶段，《Java虚拟机规范》并未作出规定。但是对于初始化阶段，做出了严格规定：

- 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时
- 使用java.lang.reflect包的方法对类型进行反射调用的时候
- 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先 初始化这个主类。
- 如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
- 当一个接口中定义了默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。



下面给出一个例子：

~~~java
class SuperClass {
    static {
        System.out.println("SuperClass init!");
    }
    public static int value = 123;
}

class SubClass extends SuperClass {
    static {
        System.out.println("SubClass init!");
    }
}


class NotInitialization {
    public static void main(String[] args) {
        // 只会触发父类的初始化，而不会触发子类的初始化
        System.out.println(SubClass.value);
    }
}
/**
 SuperClass init!
 123
*/
~~~

对于HotSpot虚拟机来说，可通过`-XX： +TraceClassLoading`参数观察到，此操作是会导致子类加载的。

另一个例子：

~~~java
public class NotInitialization {
    public static void main(String[] args) {
        SuperClass[] sca = new SuperClass[10];
    }
}
// 无输出
~~~

最后一个例子：

~~~java
public class ConstClass {
    static {
    	System.out.println("ConstClass init!");
    }
	public static final String HELLOWORLD = "hello world";
}

public class NotInitialization {
    public static void main(String[] args) {
    	System.out.println(ConstClass.HELLOWORLD);
    }
}
// 无输出
~~~

常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会执行初始化操作。

## 类加载过程

### 加载

在加载阶段，Java虚拟机需要完成以下三件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。可以从网络、Jar、动态生成、其他文件中获取。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象。JVM在做类加载的时候会把Class文件的各个部分分别解析（parse）为JVM的内部数据结构

对于非数组类型，用户可以通过自定义的类加载器来完成加载，期间可以做很多事情。但对于数组类型，它是由Java虚拟机直接在内存中动态构造出来的，对数组能做的事情很少。



### 验证

由于Class文件的加载方式多种多样，我们完全可以以其他方式构建出Class文件，绕过编译器的语法检查，从而执行一些恶意代码。因此，验证字节码是一项必要的措施。

1. 验证字节流是否符合Class文件格式的规范，这一阶段包括的验证点有：
   - 是否以魔数0xCAFEBABE开头。
   - 主、次版本号是否在当前Java虚拟机接受范围之内。
   - 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）
   - CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。
   - ...
2. 对字节码描述的信息进行语义分析，这一阶段包括的验证点有：
   - 这个类的父类是否继承了不允许被继承的类（被final修饰的类）
   - 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）
   - ...
3. 通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。
   - 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。
   - 保证方法体中的类型转换总是有效的
   - ...
4. 符号引用验证可以看作是对类自身以外（常量池中的各种符号 引用）的各类信息进行匹配性校验
   - 符号引用中通过字符串描述的全限定名是否能找到对应的类。
   - 符号引用中的类、字段、方法的可访问性（private、protected、public）是否可被当前类访问。
   - ...

由于数据流分析和控制流分析的高度复杂性，Java虚拟机的设计团队为了避免过多的执行时间消 耗在字节码验证阶段中，在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化，把尽可能 多的校验辅助措施放在Javac编译器里进行。具体做法是给方法体Code属性的属性表中新增加了一项名 为“StackMapTable”的新属性。

根据停机问题，即不能通过程序判断出程序是否能在有限的时间之内结束运行，因此不可能用程序来准确判定一段程序是否存在Bug，校验无法做到绝对准确的。



### 准备阶段

准备阶段是正式为类的静态变量分配存储空间，并初始化为零值

![image-20240130220246275](assets/image-20240130220246275.png)

但是，如果静态变量是ConstantValue属性，那么初始化为在ConstantValue中设定的值。



### 符号解析

解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程

- 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机的内存布局无关
- 直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机的布局相关的

《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行ane-warray、 checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、 invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个字节码指令之前，先对它们所使用的符号引用进行解析。

对同一个符号引用进行多次解析请求是很常见的事情，除invokedynamic指令以外（动态的），虚拟机实现可以对第一次解析的结果进行缓存。如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直能够成功；同样地，如果第一次解析失败了，其他指令对这个符号的解析请求也应该收到相同的异常，哪怕这个请求的符号在后来已成功加载进Java虚拟机内存之中。

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7 类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、 CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、 CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dynamic_info和 CONSTANT_InvokeDynamic_info 8种常量类型

下面我们分析前四种符号引用的解析。

假设当前代码所处的类为D，如果要把一个从未解析过的符号引用，N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：

- 如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个 类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作
- 如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类 似“[Ljava/lang/Integer”的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象。
- 如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了， 但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限， 将抛出java.lang.IllegalAccessError异常。



要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项所索引的CONSTANT_Class_info符号引用进行解析。如果解析成功完成，那把这个字段所属的类或接口用C表示，然后

1. 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引 用，查找结束。
2. 否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口， 如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找 结束。
3. 否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
4. 否则，查找失败，抛出java.lang.NoSuchFieldError异常。

如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权 限，将抛出java.lang.IllegalAccessError异常。



方法解析的第一个步骤与字段解析一样，也是需要先解析出方法表的class_index项所索引的CONSTANT_Class_info符号引用进行解析。如果解析成功完成，那把这个字段所属的类或接口用C表示，然后：

1. 如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则 返回这个方法的直接引用，查找结束。
2. 否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返 回这个方法的直接引用，查找结束。
3. 否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标 相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出 java.lang.AbstractMethodError异常。
4. 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。

如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此 方法的访问权限，将抛出java.lang.IllegalAccessError异常。



接口方法解析的第一个步骤与字段解析一样，也是需要先解析出接口方法表的class_index项所索引的CONSTANT_Class_info符号引用进行解析。如果解析成功完成，那把这个字段所属的类或接口用C表示，然后：

1. 在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方 法的直接引用，查找结束。
2. 否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括 Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方 法的直接引用，查找结束。
3. 对于规则3，由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符 都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，《Java虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法。不同发行商实现的Javac编译器有可能会按照更严格的约束拒绝编译这种代码，以避免不确定性。
4. 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。



### 初始化

初始化阶段就是执行类构造器`<clinit>()`方法的过程。`<clinit>()`并不是程序员在Java代码中直接编写的方法，它是Javac编译器自动生成的产物。

`<clinit>()`是由编译器自动收集类中的所有静态变量的赋值语句和静态语句块（static{}块）中的 语句合并产生的

编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，可以赋值，但是不能访问

~~~java
public class Test {
	static {
		i = 0; // 给变量复制可以正常编译通过
		System.out.print(i); // 这句编译器会提示“非法向前引用”
	}
	static int i = 1;
}

~~~

Java虚拟机会保证在子类的`<clinit>()`方法执行前，父类的`<clinit>()`方法已经执行完毕。

但接口与类不同的是，执行接口的`<clinit>()`方法不需要先执行父接口的`<clinit>()`方法， 因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时，也一样不会执行接口的`<clinit>()`方法。

Java虚拟机必须保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁同步。

## 类加载器

对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。

比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则必定是不相等的。这里所指的“相等”，包括equals()方法、isAssignableFrom()方法、isInstance() 方法

### 双亲委派模型

Java曾经保持着三层类加载器、双亲委派的类加载架构

三层类加载器是指：

- 启动类加载器（Bootstrap Class Loader）负责加载存放在`<JAVA_HOME>\lib`目录，或者`-Xbootclasspath`参数所指定的路径下的类库
- 扩展类加载器（Extension Class Loader）：这个类加载器是在以Java实现的`sun.misc.Launcher$ExtClassLoader`类中的。它负责加载`<JAVA_HOME>\lib\ext`目录，或者`java.ext.dirs`系统变量所指定的路径下的类库。
- 应用程序类加载器（Application Class Loader）：这个类加载器由 `sun.misc.Launcher$AppClassLoader`来实现。它负责加载ClassPath上的类库
- 此外，用户还可以加入自定义的类加载器来进行拓展

![image-20240131003112923](assets/image-20240131003112923.png)

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加 载这个类，而是把这个请求委派给父类加载器去完成。只有当父加载器反馈自己无法完成这个加载请 求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

一个显而易见的好处就是类随着它的类加载器一起具备一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一 个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。

双亲委派模型并不是一个具有强制性约束的模型。有时候出于技术原因不得不对该模型进行破坏。例如，支持动态热部署（Hot Deployment）功能的一个框架OSGi，它不再使用双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。

Java9引入的模块化对该模型造成了又一次破坏，在这里就不再细谈了。

## 虚拟机字节码执行引擎

物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系。

## 栈帧

栈帧的内存布局在编译期就已经计算出来。

![image-20240201214156831](assets/image-20240201214156831.png)

局部变量表（Local Variables Table）是方法参数和局部变量的存储空间。Code属性中的`max_locals`数据项就确定了该方法所需分配的局部变量表的最大容量。

局部变量表的容量以**变量槽（Variable Slot）**为最小单位，《Java虚拟机规范》中并没有明确地指出一个变量槽应占用的内存大小，而是强烈暗示每个变量槽都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据。

对于两个相邻的、用于存放64位数据的变量槽。虚拟机不允许采用任何方式单独访问其中的某一个。《Java虚拟机规范》中明确要求如果遇到执行这种操作的字节码序列，虚拟机就应该在类加载的校验阶段中抛出异常。

Java虚拟机的数据类型有boolean、byte、char、short、int、float、reference和returnAddress。前6种按Java语言的基本类型来理解即可（注意，Java虚拟机中的基本类型和Java语言的有着本质区别）。而reference类型表示对一个对象实例的引用。returnAddress类型是为字节码指令jsr、jsr_w和ret而服务的，保存一条字节码指令的地址

当一个方法被调用时，虚拟机会使用局部变量表来完成实参到形参的传递。

为了尽可能节省栈帧所耗用的内存空间，虚拟机会根据作用域来复用变量槽。这种复用机制给垃圾回收带来了一定的复杂性，下面请看一个例子：

~~~java
public static void main(String[] args)() {
	byte[] placeholder = new byte[64 * 1024 * 1024];
	System.gc();		// placeholder被回收
}
~~~

~~~java
public static void main(String[] args)() {
	{
		byte[] placeholder = new byte[64 * 1024 * 1024];
	}
    // 没有被回收，因为placeholder原本所占用的变量槽还没有被其他变量复用
	System.gc();
}
~~~

~~~java
public static void main(String[] args)() {
	{
		byte[] placeholder = new byte[64 * 1024 * 1024];
	}
	int a = 0;
    // 被回收
	System.gc();
}
~~~

「手动将不使用的对象赋值为null」看似是最优的解决方案，实则不然。因为这仅仅是从概念模型上考虑的，实际上编译优化技术会正确地处理这种行为，我们无需担心太多。

### 操作数栈

操作数栈是寄存器的代替方案。

操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在校验阶段的数据流分析中还要验证这一点。

在大多虚拟机的实现里，都会对进行一些优化处理，令两个栈帧出现一部分重叠，即操作数栈和局部变量表栈之间的重叠。除了节约空间外，它可以在调用函数时，无需进行额外地参数复制了。

![image-20240201221149293](assets/image-20240201221149293.png)

Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”，里面的“栈”就是操作数栈

### 栈帧信息

栈帧信息包括

- 动态链接：每个栈帧为了支持动态链接（Dynamic Linking），都持有一个该栈帧在常量池中对应的方法符号引用的引用

  我们知道，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数，这些一部分符号引用会在类加载阶段转化为直接引用，这种转化被称为**静态解析**。而另一部分将在每一个调用时转换为直接引用，这种转换被称为**动态解析**。

- 方法调用：

  方法的返回有两种方式：

  - 正常返回，返回地址由调用点处的PC值来决定的
  - 异常返回，根据异常处理器表来确定的

- 额外信息：Java虚拟机规范允许额外添增信息到栈帧中，例如与性能相关的信息。



## 方法调用

方法调用阶段唯一的任务就是确定被调用方法的版本 （即调用哪一个方法），而并不是执行方法。

Class文件的编译过程中不包含传统程序语言编译的链接步骤，一切方法调用在Class文件里面存储的都只是符号引用。这个特性给Java带来了更强大的动态扩展能力，但也引入了复杂的机制。

### 解析

静态解析要求在运行时，方法的调用版本是不可改变的，主要包括：

- 私有方法
- 静态方法
- 实例构造器
- final方法
- 父类方法

它们在语法层面就不支持覆写，因此适合在类加载阶段进行静态解析。

在Java虚拟机支持以下5条方法调用字节码指令，分别是：

- `invokestatic`。用于调用静态方法
- `invokespecial`。用于调用实例构造器()方法、私有方法和父类中的方法
- `invokevirtual`。用于调用所有的虚方法
- `invokeinterface`。用于调用接口方法，会在运行时再确定一个实现该接口的对象。
- `invokedynamic`。先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。

只要能被`invokestatic`和`invokespecial`指令调用的方法，都可以在解析阶段中确定唯一的调用版本， Java语言里符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法4种。再加上被final 修饰的方法（尽管它使用`invokevirtual`指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“非虚方法”（Non-Virtual Method），与之相反，其他方法就被称为“虚方法”（Virtual Method）。

### 分派

Dispatch这一词在规范里为Method Overload Resolution。它的类型有

- 静态单分派
- 静态多分派
- 动态单分派
- 动态多分派

### 静态分派

我们来先看一个例子：

~~~java
public class StaticDispatch {
    static abstract class Human { }
    static class Man extends Human { }
    static class Woman extends Human { }
    
    public void sayHello(Human guy) {
    	System.out.println("hello,guy!");
    }
    
    public void sayHello(Man guy) {
    	System.out.println("hello,gentleman!");
    }
    
    public void sayHello(Woman guy) {
    	System.out.println("hello,lady!");
    }
    
    public static void main(String[] args) {
    	Human man = new Man();
    	Human woman = new Woman();
    	StaticDispatch sr = new StaticDispatch();
    	sr.sayHello(man);
    	sr.sayHello(woman);
    }
}
/**
 hello, guy!
 hello, guy!
 */
~~~

为了解释为何输出该结果，我们先通过一个例子来明确两个概念：

~~~java
Human man = Man();
~~~

我们把上面代码中的“Human”称为变量的“静态类型”（Static Type），或者叫“外观类型”（Apparent Type），后面的“Man”则被称为变量的“实际类型”（Actual Type）或者叫“运行时类型”（Runtime Type）.

在重载时，是通过参数的静态类型而不是实际类型来判断的。

所有依赖静态类型来决定方法调用版本的分派动作，都称为静态分派。静态分派的最典型应用就是方法重载。而且静态分派发生在编译阶段。

下面我们来看一个重载决议的例子：

~~~java
package org.fenixsoft.polymorphic;
public class Overload {
    public static void sayHello(Object arg) {
    	System.out.println("hello Object");
    }
    public static void sayHello(int arg) {
   		System.out.println("hello int");
    }
    public static void sayHello(long arg) {
    	System.out.println("hello long");
    }
    public static void sayHello(Character arg) {
    	System.out.println("hello Character");
    }
    public static void sayHello(char arg) {
    	System.out.println("hello char");
    }
    public static void sayHello(char... arg) {
    	System.out.println("hello char ...");
    }
    public static void sayHello(Serializable arg) {
    	System.out.println("hello Serializable");
    }
    public static void main(String[] args) {
    	sayHello('a');
    }
}
~~~

该例子中的适配规则：char -> int -> long -> float -> double -> Character -> Serializable(Comparable) -> Object -> char...

这里有几点需要说明：

- Character -> Serializable 是因为Serializable是Character的接口。
- 对于null，该适配规则也成立，不过会同时匹配到Character与char...

编译器无法确定要自动转型为哪种类型，会提示**“类型模糊”（Type Ambiguous）**，并拒绝编译。程序必须在调用时显式地指定字面量的静态类型。

### 动态分派

~~~java
public class DynamicDispatch {
    static abstract class Human {
    	protected abstract void sayHello();
    }
    
    static class Man extends Human {
    	@Override
    	protected void sayHello() {
    		System.out.println("man say hello");
    	}
    }
    
    static class Woman extends Human {
    	@Override
    	protected void sayHello() {
    		System.out.println("woman say hello");
    	}
    }
    
    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
        woman.sayHello();
        man = new Woman();
        man.sayHello();
    }
}
/**
man say hello
woman say hello
woman say hello
*/
~~~

这个结果很明显。我们把它的字节码打印出来看看：

~~~java
public static void main(java.lang.String[]);
	Code:
        Stack=2, Locals=3, Args_size=1
        0: new #16; //class org/fenixsoft/polymorphic/DynamicDispatch$Man
        3: dup
        4: invokespecial #18; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Man."<init>":()V
        7: astore_1
        8: new #19; //class org/fenixsoft/polymorphic/DynamicDispatch$Woman
        11: dup
        12: invokespecial #21; //Method org/fenixsoft/polymorphic/DynamicDispatch$Woman."<init>":()V
        15: astore_2
        16: aload_1
        17: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V
        20: aload_2
        21: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V
        24: new #19; //class org/fenixsoft/polymorphic/DynamicDispatch$Woman
        27: dup
        28: invokespecial #21; //Method org/fenixsoft/polymorphic/DynamicDispatch$Woman."<init>":()V
        31: astore_1
        32: aload_1
        33: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V
        36: return
~~~

man、woman这两个引用存放在局部变量表里的第1、2个的变量槽中。

16 - 21是关键部分，aload_1、aload2将刚刚创建的两个对象的引用压到操作数栈顶。而根据《Java虚拟机规范》， `invokevirtual`指令的运行时解析过程大致分为以下几步：

- 找到操作数栈的栈顶元素所指向的对象的实际类型，记作C
- 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回`java.lang.IllegalAccessError`异常。
- 否则，按照继承关系从下往上依次对C的各个父类进行验证。
- 如果始终没有找到合适的方法，则抛出`java.lang.AbstractMethodError`异常。

我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。

显然字段是无法分派的。下面我们来看一个相关的例子：

~~~java
public class FieldHasNoPolymorphic {
    static class Father {
        public int money = 1;
        
        public Father() {
        	money = 2;
        	showMeTheMoney();
    	}
         
   	 	public void showMeTheMoney() {
    		System.out.println("I am Father, i have $" + money);
        }
	}
    
    static class Son extends Father {
    	public int money = 3;
        
    	public Son() {
    		money = 4;
            showMeTheMoney();
		}
        
        @Override
		public void showMeTheMoney() {
			System.out.println("I am Son, i have $" + money);
		}
    }
    
    public static void main(String[] args) {
		Father gay = new Son();
        System.out.println("This gay has $" + gay.money);
    }
}
/**
I am Son, i have $0
I am Son, i have $4
This gay has $2
*/
~~~

在创建Son时，会隐式调用Father构造函数，而Father构造函数中对showMeTheMoney()的调用是一次虚方法调用，实际执行的版本是 Son::showMeTheMoney()方法，所以输出的是“I am Son”。此时虽然父类的money字段已经被初始化成2了，但Son::showMeTheMoney()方法中访问的却是Son的money字段，这时候还未初始化，结果自然还是0。

### 单分派与多分派

方法的接收者与方法的参数统称为方法的宗量。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。

Java语言是一门静态多分派、动态单分派的语言。我们可以通过一个例子来认识这一点。

~~~java
public class Dispatch {
	static class QQ {}
    static class _360 {}
    
    public static class Father {
        public void hardChoice(QQ arg) {
            System.out.println("father choose qq");
        }
        
       	public void hardChoice(_360 arg) {
        	System.out.println("father choose 360");
        }
    }
    
    public static class Son extends Father {
        public void hardChoice(QQ arg) {
        	System.out.println("son choose qq");
        }
        public void hardChoice(_360 arg) {
        	System.out.println("son choose 360");
        }
    }
    
    public static void main(String[] args) {
    	Father father = new Father();
    	Father son = new Son();
    	father.hardChoice(new _360());
    	son.hardChoice(new QQ());
    }
}





/**
father choose 360
son choose qq
*/
~~~

在静态解析阶段，选择目标方法依据两点：

1. 接收者的静态类型Father和Son。这次选择结果的最终产物是产生了两条invokevirtual指令，两条指令的参数分别为常量池中指向Father: hardChoice(360)以及Father:hardChoice(QQ)方法的符号引用
2. 方法参数QQ和_360

在动态阶段，仅需考虑接收者的动态类型。



### 动态分派的实现

Java虚拟机实现基于性能的考虑，真正运行时一般不会频繁地去反复搜索类型元数据来执行动态分派。一种优化手段就是建立一个**虚方法表（Virtual Method Table）**。

![img](assets/v2-dfe4aefdee7e06cf3151b57492ed42a2_720w.webp)

除了使用虚方法表之外，Java虚拟机还会使用类型继承关系分析（Class Hierarchy Analysis，CHA）、守护内联（Guarded Inlining）、内联缓存（Inline Cache）等多种非稳定的激进优化来争取更大的性能空间。



## 动态语言支持

动态类型语言的一个核心特点就是「动态类型系统」。例如

~~~java
obj.println("hello world");
~~~

这个代码在Java语言中，那么在编译期间已将println(String)方法完整的符号引用（本例中为一项CONSTANT_InterfaceMethodref_info常量）生成出来

~~~java
invokevirtual #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
~~~

这个符号引用包含了该方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息。而在ECMAScript语言中，由于没有类型约束，所以在编译时仅仅会确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型。

JDK 7时新加入的java.lang.invoke包，提供一种新的动态确定目标方法的机制——“方法句柄”（Method Handle），这类似于C/C++中的函数指针。

~~~java
public class MethodHandleTest {
	static class ClassA {
		public void println(String s) {
			System.out.println(s);	
		}
	}
    
	public static void main(String[] args) throws Throwable {
		Object obj = System.currentTimeMillis() % 2 == 0 ? System.out : new ClassA();
		// 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。
		getPrintlnMH(obj).invokeExact("icyfenix");
	}
    
    // 方法getPrintlnMH()中实际上是模拟了invokevirtual指令的执行过程
	private static MethodHandle getPrintlnMH(Object reveiver) throws Throwable {
		// MethodType：代表“方法类型”，包含了方法的返回值（methodType()的第一个参数）和具体参数（methodType()第二个及以后的参数）。
		MethodType mt = MethodType.methodType(void.class, String.class);
        
		// lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。
   	 	// 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，也即this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情。
        return lookup()
            .findVirtual(
            	reveiver.getClass(), 
            	"println", 
            	mt)
            .bindTo(reveiver);
	}
}
~~~

- Reflection和MethodHandle机制本质上都是在模拟方法调用，但是Reflection是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用。

- Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的 java.lang.invoke.MethodHandle对象所包含的信息来得多。前者是方法在Java端的全面映像，包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式，还包含执行权限等的运行期信息。而后者仅包含执行该方法的相关信息。用开发人员通俗的话来讲，Reflection是重量级，而MethodHandle 是轻量级。
- MethodHandle可以支持一些优化操作，而Reflection不可以



invokedynamic指令与MethodHandle机制的作用是一样的，都是为了解决原有4 条“invoke*”指令方法分派规则完全固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机 转嫁到具体用户代码之中，让用户（包含其他程序语言的设计者）有更高的自由度。

每一处含有invokedynamic指令的位置都被称作「动态调用点」（Dynamically-Computed Call Site），对应的常量为的CONSTANT_InvokeDynamic_info，从这个新常量中可以得到3项信息：

- 引导方法 （Bootstrap Method，该方法存放在新增的BootstrapMethods属性中）。引导方法有着固定的参数，并且返回值是java.lang.invoke.CallSite对象，这个对象代表了真 正要执行的目标方法调用。
- 方法类型（MethodType）
- 名称

根据`CONSTANT_InvokeDynamic_info`常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个`CallSite`对象，最终调用到要执行的目标方法上。

## 执行引擎

![image-20240203115407503](assets/image-20240203115407503.png)



基于栈的指令集与基于寄存器的指令集有什么不同？ 下面通过1+1的例子来说明：

~~~java
iconst_1
iconst_1
iadd
istore_0	 # 把栈顶的值放到局部变量表的第0个变量槽中
~~~

~~~
mov eax, 1
add eax, 1

~~~

基于栈的指令集可以屏蔽掉不同体系架构上的寄存器文件组织，方便移植。但是它涉及大量的出栈入栈操作，而且栈是在内存中实现的，因此性能不及寄存器架构的。但是虚拟机可以采取栈顶缓存的优化方法，把最常用的栈元素映射到寄存器中避免直接内存访问。



## 案例

用户可以自定义字节码生成与类加载器这两部分

### Tomcat：正统的类加载器架构

Web Server自定义类加载器的必要性

- 部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离。这是最基本的需求，两个不同的应用程序可能会依赖同一个第三方类库的不同版本
- 部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享，例如共享Spring框架的类库
- ...



各种Web服务器都提供了好几个ClassPath路径供用户存放第三方类库，这些路径一般会以“lib”或“classes”命名。通常每一个目录都会有一个相应的自定义类加载器，去加载放置在里面的Java类库

在Tomcat目录结构中：

- /common：类库可被Tomcat和所有的Web应用程序共同使用
- /server：类库可被Tomcat使用，对所有的Web应用程序都不可见
- /shared：类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见
- WebApp/WEB-INF：类库仅仅可以被该Web应用程序使用，对Tomcat和其他Web应用程序都不可见

为了支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat自定义了多个类加载器， 这些类加载器按照经典的双亲委派模型来实现。

![image-20240203132451225](assets/image-20240203132451225.png)

在Tomcat 6及之后的版本简化了默认的目录结构，只有指定了tomcat/conf/catalina.properties配置文件的server.loader和share.loader项后，才会真正建立Catalina类加载器和Shared类加载器的实例，否则会用到这两个类加载器的地方都会用 Common类加载器的实例代替。因此也顺理成章地把/common、/server和/shared这3个目录默认合并到一起变成1个/lib目录，这个目录相当于以前/common目录，



### OSGi：灵活的类加载器架构

OSGi （Open Service Gateway Initiative）是一个基于Java语言的动态模块化规范。

OSGi中的每个模块（称为Bundle）与普通的Java类库区别并不太大，两者一般都以JAR格式进行封装，并且内部存储的都是Java的Package和Class。但是一个Bundle可以声明它所依赖的Package（通 过`Import-Package`描述），也可以声明它允许导出发布的Package（通过`Export-Package`描述）。在OSGi 里面，Bundle之间的依赖关系从传统的上层模块依赖底层模块转变为平级模块之间的依赖，而且类库的可见性能得到非常精确的控制。

下面举个例子：

- Bundle A：声明发布了packageA，依赖了java.*的包； 
- Bundle B：声明依赖了packageA和packageC，同时也依赖了java.*的包；
- Bundle C：声明发布了packageC，依赖了packageA。

![image-20240203133418873](assets/image-20240203133418873.png)

也就是说，在OSGi中，加载器之间的关系不再是双亲委派模型的树形结构，而是已 经进一步发展成一种更为复杂的、运行时才能确定的网状结构。

### 字节码生成技术与动态代理的实现

javac就是所有字节码生成技术的鼻祖。
