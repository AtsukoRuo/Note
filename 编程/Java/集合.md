# Java 集合

[TOC]

![img](assets/v2-2f459861d963c59dddd56d7466da4381_b.jpg)



## 集合类

Java集合类库是用来“持有对象”的，而且从设计上讲，它可以分为两个不同的概念，表示以下两个基本接口。

- `Collection`：Collection接口就是序列概念的一般化。它是由多个元素组成的序列，而且这些元素要符合一条或多条规则。
	- `List`必须按照元素插入顺序来保存它们；例如`ArrayList`
	- `Set`中不能存在重复元素；
	- 而`Queue`则要按照排队规则来输出元素。
- `Map`：一组键值对象对，使用键来查找值。数组就是使用一个数值来查找某个对象，所以在**某种意义上**它将数值与对象关联在了一起。而Map使用另一个对象来查找某个对象。它也被称作**关联数组**（或者被称作**字典**），因为它将对象与其他对象关联在了一起；



在Java中，几乎所有的容器类都是**持有对象的引用**。当你向一个容器中添加一个对象时，实际上是将这个对象的引用添加到容器中（浅复制），而不是对象本身（深复制）。因此，如果你修改了这个对象，这些修改也会反映存储在容器中的引用所指向的对象上。

~~~Java
class A {
    int i = 0;
    A(int i) { this.i = i;}
}

A a = new A(1);
A a1 = new A(2);
A a2= new A(3);

List<A> list = new ArrayList<>(Arrays.asList(a, a1, a2));
aa1.i = 10;
System.out.println(list);

list = List.of(a, a1, a2);
a1.i = 1000;
System.out.println(list);
/*
[1, 10, 3]
[1, 1000, 3]
*/
~~~



### Collection接口

~~~java
public interface Collection<E> extends Iterable<E> {
    int size();
    boolean isEmpty();
    boolean contains(Object o);
    Iterator<E> iterator();
    Object[] toArray();
    <T> T[] toArray(T[] a);
    boolean add(E e);
    boolean remove(Object o);
    boolean containsAll(Collection<?> c);
    boolean addAll(Collection<? extends E> c);
    boolean removeAll(Collection<?> c);
    boolean retainAll(Collection<?> c);
    void clear();
    boolean equals(Object o);
    int hashCode();
    default Stream<E> stream() { //... }
}
~~~






## Set

- **HashSet**：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。

- **TreeSet**：如果存储顺序非常重要，可以使用TreeSet，它会以升序保存对象；底层使用红黑树来实现的，支持有序性操作

- **LinkedHashSet**。具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。

- **ConcurrentSkipListSet**

- **CopyOnWriteArraySet**

- **SortedSet**（接口）

	

`Set`接口继承了`Collection`接口，并没有添加什么特殊的方法

## Map

- **HashMap**：键和值在HashMap之中的存储顺序不同于插入顺序，这是因为HashMap使用了一种非常快速的算法，而该算法会控制顺序。

- **TreeMap**：TreeMap会按照键的升序来排序。

- **LinkedHashMap**：LinkedHashMap则按照插入顺序来保存键，同时保留了HashMap的查找速度。



**对象作为 Map 的 key 时，需重写 equals() 和 hashCode() 方法**

~~~java
HashMap:

HashMap() 		//构造一个空的HashMap,默认初始容量为16,负载因子为0.75
HashMap(int initialCapacity) //构造一个指定初始容量的空HashMap
HashMap(int initialCapacity, float loadFactor) //构造一个指定初始容量和负载因子的空HashMap
HashMap(Map<? extends K, ? extends V> m) //构造一个包含指定Map的数据的新HashMap
~~~



~~~java
Map<String, Pet> petMap = new HashMap<>();

//一个不可变的map对象，而且参数最多支持十个键值对
petMap.of("My Hamster", new Hamster("bosco")
         ,"My Dog", new Dog()
         ,"My Cat", new Cat());		

//插入键值对。If the map previously contained a mapping for the key, the old value is replaced by the specified value
petMap.put("My Hamster", new Hamster("Bosco"));
petMap.put("My Hamster", new Hamster("Molly"));	

petMap.containsKey("My Hamster");			//判断键是否在map中
petMap.containsValue("Bosco");				//判断值是否在map中
System.out.println(petMap.get("My Hamster"));//根据键获取值，若未查找到键则返回null
System.out.println(petMap.values());		//返回所有的value
System.out.println(petMap.keySet());		//返回所有的key
~~~



~~~java
if (map.containsKey(words[i])) {
    map.put(words[i], map.get(words[i]) + 1);
} else {
    map.put(words[i], 1);
}
~~~

可以优化为

~~~java
map.put(words[i], map.getOrDefault(words[i], 0) + 1);
~~~



### ConcurrentHashMap

![Java8 ConcurrentHashMap 存储结构](assets/java8_concurrenthashmap.png)

ConcurrentHashMap 使用了锁分段技术，它在内部创建了N（默认值为16）个锁实例。

![image-20240207153012721](assets/image-20240207153012721.png)

## List

有两种类型的List：

- **ArrayList**：擅长随机访问元素，但是在List的中间插入或删除元素比较慢。
- **LinkedList**：供了理想的顺序访问性能，在List的中间插入和删除元素的成本都比较低。LinkedList随机访问性能相对较差

### 接口

~~~java
public interface List<E> extends Collection<E> {
    E get(int index);
    E set(int index, E element);    // return the element previously at the specified position
    void add(int index, E element);
    E remove(int index);
    int indexOf(Object o);
    int lastIndexOf(Object o);
    List<E> subList(int fromIndex, int toIndex);	//注意返回List的引用，而不是创建一个新List
    static <E> List<E> of(E... elements);		//创建一个List
    
}
~~~



### ArrayList

`ArrayList`是**线程不安全**的 

ArrayList的构造器如下：

~~~java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    
    public ArrayList(int initialCapacity)    		// 初始容量
    public ArrayList()							 	//创建一个默认初始容量(10)空 ArrayList。
    public ArrayList(Collection<? extends E> c)    // 浅拷贝
        
}
~~~

可以用第三种初始化方法返回列表的浅拷贝

~~~java
Integer[] array = {1, 2, 3, 4, 5};
List<Integer> list = Arrays.asList(array);
System.out.println(list);
List<Integer> list2= new ArrayList<>(list);
list.set(2, 100);
System.out.println(list);

/*
[1, 2, 3, 4, 5]
[1, 2, 100, 4, 5]
*/
~~~



ArrayList的set方法要满足(index < 0 || index >= size())，否则抛出异常`IndexOutOfBoundsException` – if the index is out of range 



另外,从 Java 9 开始,还提供了几个工厂方法来创建不可变的 ArrayList:

- List.of()
- List.copyOf()

这些方法创建的 ArrayList 在添加和删除时会抛出异常。

### LinkedList

`LinkedList` 底层数据结构是链表。需要用到 `LinkedList` 的场景几乎都可以使用 `ArrayList` 来代替，并且，性能通常会更好！就连 `LinkedList` 的作者Josh Bloch自己都说从来不会使用 `LinkedList` 。

![img](assets/redisimage-20220412110853807.png)



### Stack、Vector

`Vector` 和 `Stack` 两者都是线程安全的，都是使用 `synchronized` 关键字进行同步处理

Java 1.0就提供了Stack类，结果这个类的设计非常糟糕。不过因为要向后兼容，所以我们永远也无法摆脱Java过去的设计错误了。

Java 6加入了ArrayDeque，用于代替栈

~~~java
public class ArrayDeque<E> 
    extends AbstractCollection<E> 
    implements Deque<E>, Cloneable, Serializable {
    
}
~~~



~~~java
Deque<String> stack = new ArrayDeque<>();
for (String str : "Hello World".split(" ")) {
    stack.push(str);
}
while (!stack.isEmpty()) {
    System.out.println(stack.peek());
    System.out.println(stack.pop());
}
~~~

- `push()`将元素压栈
- `peek()`获取栈顶元素，并不把它从栈顶移走，
- `pop()`移除并返回顶端元素。

ArrayDeque还有一些功能是Stack使用不到的。在使用中可能会误用这些方法，而违背栈的使用语义。

## Queue

### Queue接口

~~~java
public interface Queue<E> extends Collection<E> {
    boolean add(E e);
    boolean offer(E e);
    E remove();
    E poll();
    E element();
    E peek();
}
~~~

在操作失败后，有两种处理策略，它们分别是抛出异常与返回特殊值。

| `Queue` 接口 | 抛出异常  | 返回特殊值 |
| ------------ | --------- | ---------- |
| 插入队尾     | add(E e)  | offer(E e) |
| 删除队首     | remove()  | poll()     |
| 查询队首元素 | element() | peek()     |

### Deque接口

`Deque`接口继承了`Queue`接口

~~~java
public interface Deque<E> extends Queue<E> {
    void addFirst(E e);
    void addLast(E e);
    boolean offerFirst(E e);
    boolean offerLast(E e);
    E removeFirst();
    E removeLast();
    E pollFirst();
    E pollLast();
    E getFirst();
    E getLast();
    E peekFirst();
    boolean removeFirstOccurrence(Object o);
    boolean removeLastOccurrence(Object o);
    boolean add(E e);
    boolean offer(E e);
    E remove();
    E poll();
    E element();
    E peek();
    boolean addAll(Collection<? extends E> c);
    void push(E e);
    E pop();
    boolean remove(Object o);
    boolean contains(Object o);
    int size();
    Iterator<E> iterator();
    Iterator<E> descendingIterator();

}

~~~

| `Deque` 接口 | 抛出异常      | 返回特殊值      |
| ------------ | ------------- | --------------- |
| 插入队首     | addFirst(E e) | offerFirst(E e) |
| 插入队尾     | addLast(E e)  | offerLast(E e)  |
| 删除队首     | removeFirst() | pollFirst()     |
| 删除队尾     | removeLast()  | pollLast()      |
| 查询队首元素 | getFirst()    | peekFirst()     |
| 查询队尾元素 | getLast()     | peekLast()      |

事实上，`Deque` 还提供有 `push()` 和 `pop()` 等其他方法，可用于模拟栈

### 队列

可以使用`ArrayDeque`类来创建队列。

### 优先队列

~~~java
public class PriorityQueue<E> extends AbstractQueue<E> 
        implements java.io.Serializable {

    public PriorityQueue();
    public PriorityQueue(int initialCapacity);  // 不传入 Comparator 则会使用类的默认比较方法
    public PriorityQueue(Comparator<? super E> comparator);
    public PriorityQueue(int initialCapacity,
                         Comparator<? super E> comparator);
    public PriorityQueue(Collection<? extends E> c);
    public PriorityQueue(PriorityQueue<? extends E> c);
    public PriorityQueue(SortedSet<? extends E> c);
}

~~~



在构造方法中可以指定一个**比较器（comparator）**

~~~java
PriorityQueue<String> queue = new PriorityQueue<>(Collection.reverseOrder());
~~~

### BlockingQueue

~~~java
public interface BlockingQueue<E> extends Queue<E> {
  // ...
}
~~~

`BlockingQueue` 常用于生产者-消费者模型中

![BlockingQueue](assets/blocking-queue.png)

BlockingQueue 的实现类有

- `ArrayBlockingQueue`：ArrayBlockingQueue的缺点是其内部在实现 put、take 操作的时候使用的是同一个锁
- `LinkedBlockingQueue`：LinkedBlockingQueue 的优点 是其内部在实现 put、take操作的时候分别使用了两个显式锁(putLock 和 takeLock)。由于是基于链表实现的，它可能增加垃圾回收的负担
- `SynchronousQueue`：它一个不存储元素的队列。每一个`put`操作必须等待一个`take`操作，反之亦然
- `DelayQueue`
- `PriorityBlockingQueue`

BlockingQueue 接口定义的 offer(E)和 poll()分别相当于 put(E) 和 take() 的非阻塞版。

## 工具类 

~~~java
public static <T> java.util.List<T> asList(@NotNull  T... a )
~~~

返回一个固定大小的`List`。推荐使用`List.of`方法，但他也返回一个不可变的`List`。

~~~java
List<Integer> list1 = List.of(1, 2, 3);、
list1.set(1, 2);	//Error
list1.add(5);		//Error

List<Integer> list2 = Arrays.asList(1, 2, 3);
list2.set(1, 2);	//Error
list2.add(5);		//Ok
~~~





## 迭代器 Iterator

迭代器（也是一种设计模式）是一个对象，它可以在序列中移动，并用来选择该序列中的每个对象。能够**将序列的遍历操作与序列的底层结构分离**。因此，我们有时候会说，**迭代器统一了对集合的访问**。



`Iterator`接口（迭代器）中的方法有：

- `next()`方法获得序列中的下一个对象。
- `hasNext()`方法检查序列中是否还有更多对象。
- `remove()`方法删除该迭代器最近返回的元素。这暗含着调用`remove()`之前必须调用`next()`。



`Iteratable`接口（可迭代对象）中的方法有

- `iterator()`方法让`Collection`返回一个`Iterator`。这个迭代器将准备好返回序列中的第一个元素。

### List Iterator

`ListIterator`是`Iterator`的一种更为强大的子类型。它是`List`对象特有的迭代器。

- `hasPrevious`
- `privious`
- `listIterator(int)`，返回一个`Iterator`对象。第一次`next`返回索引为`n`的元素。

### for-in与Iterator

`for-in`强制要求接受一个数组，或者`java.lang.Iterable`对象。

对于已经实现`Iterable`的对象，`for-in`会自动调用它的`iterator()`方法获取`Iterator`，然后开始迭代。

~~~java
public class ForEachAndIetrator {
    public static void main(String[] args) {
        for (String s : new T()) {
            System.out.print(s + " ");
        }
        System.out.println();
        for (String s : new T().reversedIterator()) {
            System.out.print(s + " ");
        }
    }
}

class T implements Iterable<String> {
    protected String[] words = ("And that is how we know the Earth to be banana-shaped.").split(" ");
    
    @Override
    public Iterator<String> iterator() {
        return new Iterator<String>() {
            private int index = 0;
            @Override public boolean hasNext() {
                return index < words.length;
            }
            @Override public String next() {
                return words[index++];
            }
            @Override public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }
    
    //适配器
    public Iterable<String> reversedIterator() {
        return new Iterable<String>() {
            @Override public Iterator<String> iterator() {
                return new Iterator<String>() {
                    private int index = words.length;
                    
                    @Override public boolean hasNext() {return index > 0; }
                    @Override public String next() { return words[--index];}
                    @Override public void remove() {throw new UnsupportedOperationException();}
                };
            }
        };
    }
}
/*
And that is how we know the Earth to be banana-shaped. 
banana-shaped. be to Earth the know we how is that And 
*/
~~~



## record类型

`record`定义了**数据传输对象**（也叫数据载体）。当使用record关键字时，编译器会自动生成：

- 不可变的实例字段，默认`private final`实例字段。
- 一个规范的构造器
- 每个元素都有的访问器方法。Java的设计者们**没有**继续使用过时的JavaBean中的实践，例如把访问器叫作`getName()`和`getId()`，而是`name()`和`id()`。
- `equals()`
- `hashCode()`
- `toString()`

只能在record的头部定义实例字段，不允许在类中定义实例字段。可以在类中添加方法、静态字段。



我们不能继承record，因为它隐含为final的。此外，record也不能继承其他类。然而，record可以实现interface：

~~~java
interface Star {
    double brightness();
    double density();
}

record RedDwarf(double brightness) implements Star {
    @Override public double density() { return 100.0; }
    //注意record为brightness字段生成的brightness方法会覆写Star中的brightness方法。
}
~~~



`record`类型可以嵌套`record`类型

~~~java
record Employee(String name, int id) {}
record Company(Employee[] e) {}
~~~



嵌套和局部`record`隐式是静态的：

~~~java
public class NextedLocalRecords {
    int i = 10;
    static int j = 10;
    record Nested(String s) {
        void f() {
            i = 10;	//Error
            j = 10; //OK
        }
    }
    
    void method() {
        record Local(String s) {}
    }
}
~~~



**紧凑构造器（compact constructor）**用来添加构造器行为，但它没有构造列表。紧凑构造器通常用于验证参数。也可以修改字段的初始化值：

~~~java
record Point(int x, int y) {
    Point {
        x = 10; //OK
    }
    void f() {
        x = 10;	//Error
    }
}
~~~

我们也可以用普通构造器来替换规范构造器：

~~~java
record Point(int x, int y) {
    Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
~~~

注意：

- 普通构造器与紧凑构造器必须二选一

- 普通构造器中的签名必须和规范构造器一样，而且参数名不允许改变。这暗示着不能声明其他构造器。

- 必须在普通构造中对每个实例字段进行初始化，否则编译器会报错。紧凑构造器就没有此限制。

  

