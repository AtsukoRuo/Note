# Java 反射

[TOC]

## 概述

反射可以在程序运行时获取对象的类型信息，使我们摆脱了只能在编译时执行面向类型操作的限制。



下面我们看一个最基本的反射：在运行时确定对象的类型，检查所有的类型转换是否正确。

~~~java
abstract class Shape {}
class Circle extends Shape {}

Circle c = new Circle();
Shape a = (Shape)c		// 反射 + 多态
~~~



程序中的每一个类类型都有一个对应的Class对象。而这个特殊的Class对象保存了运行时的类型信息。每次编译时，都会给每一个类类型生成对应的Class对象（存储在同名的.class文件中）。Java虚拟机（JVM）使用被称为**类加载器（class loader）**的子系统，来生成这个Class对象。

类加载器子系统实际上可以包含一条类加载器链，但里面只会有一个原始类加载器，它是JVM实现的一部分。原始类加载器通常从本地磁盘加载所谓的可信类，包括Java API类。通常来说我们不需要加载器链中的额外加载器，但对于特殊需要（例如以某种方式加载类以支持Web服务器应用程序，或通过网络来下载类），你可以引入额外的类加载器来实现。

当程序第一次引用该类的静态成员（注：构造器是类的一个静态方法）时，就会加载该类型的Class对象。在加载过程中时，Class对象的二进制数据会被验证，以确保没有被损坏并且不包含恶意的代码。一旦该类型的Class对象加载到内存中（实例化），它就会用于创建该类型的所有对象。

所以，Java程序在运行前并不会被完全加载，而是在必要时加载对应的部分。这与许多传统语言不同。这种动态加载能力使得Java可以支持很多行为，而它们在静态加载语言（如 C++）中很难复制，或根本不可能复制。



## 获取Class对象

Class对象的类型为Class类。可以通过以下三种方法来获取到类型的Class对象

- forName()：可以通过`Class.forName()`方法获取到指定的Class对象：

  ~~~java
  try {
  	Class.forName("reflection.toys.Gum");
  } catch(ClassNotFoundException e) {
      
  }
  ~~~

  注意：传递给forName()的字符串参数必须是类的完全限定名称。

- getClass()：如果你已经拥有了一个对象，那么可以通过getClass()方法来获取对应的Class对象，这个方法属于Object根类：

  ~~~java
  Fruit fruit = new Apple();
  Class c1 = fruit.getClass();		//实际上为Apple
  ~~~

- class字面值：

  ~~~java
  FancyToy.class
  ~~~

  每个值类型的包装类都有一个名为TYPE的标准字段。TYPE字段表示一个指向和基本类型对应的Class对象的引用。

  ~~~java
  public static final Class<Integer>  TYPE = (Class<Integer>) Class.getPrimitiveClass("int");
  ~~~

  `int.class`等价于`Integer.TYPE`，`void.class`等价于`Void.TYPE`。其他基本类型类似。

  

使用.class语法来获取对Class对象的引用不会导致对应类型的初始化。而Class.forName()会立即初始化类。而且对于.class语法来说，如果一个static final字段的值是“编译时常量”，访问它并不会导致类的初始化。下面给出一个例子说明这一点：

~~~java
class Initable {
  static final int STATIC_FINAL = 47;
  static final int STATIC_FINAL2 =
    ClassInitialization.rand.nextInt(1000);			//不是编译期常量
  static {
    System.out.println("Initializing Initable");
  }
}

class Initable2 {
  static int staticNonFinal = 147;
  static {
    System.out.println("Initializing Initable2");
  }
}

class Initable3 {
  static int staticNonFinal = 74;
  static {
    System.out.println("Initializing Initable3");
  }
}

public class ClassInitialization {
  public static Random rand = new Random(47);
  public static void
  main(String[] args) throws Exception {
    Class initable = Initable.class;
    System.out.println("After creating Initable ref");
    // Does not trigger initialization:
    System.out.println(Initable.STATIC_FINAL);
    // Triggers initialization:
    System.out.println(Initable.STATIC_FINAL2);
    // Triggers initialization:
    System.out.println(Initable2.staticNonFinal);
    Class initable3 = Class.forName("Initable3");
    System.out.println("After creating Initable3 ref");
    System.out.println(Initable3.staticNonFinal);
  }
}
/* Output:
After creating Initable ref
47
Initializing Initable
258
Initializing Initable2
147
Initializing Initable3
After creating Initable3 ref
74
*/
~~~



## Class对象的方法

Class对象具有以下方法

- Class<?>[] getInterfaces()：获取所有的直接接口

- Class<? super T> getSuperclass()：获取直接基类

- Class的newInstance()：调用类的无参构造器。现已被弃用，推荐使用Constructor.newInstance()来代替。若无参构造不存在，则会抛出`java.lang.InstantiationException`异常

- getSimpleName()：返回类名

- getCanonicalName()：返回完全限定名

- Field[] getFields()：返回类中public属性，不包括父类属性，但包括静态字段

- Field getField()：返回指定的public属性

- Field[] getDeclaredFields()：返回类中的所有属性，不包括父类属性，但包括静态字段

- Method[] getDeclaredMethods()：返回类中所有的实例方法

- Constructor<?>[] getDeclaredConstructors()：返回类中所有的构造方法

  



## Class对象与泛型

你可以使用泛型语法来限制Class引用的类型：

~~~java
Class intClass = int.class;
intClass = double.class;
Class<Integer> genericIntClass = int.class;
genericIntClass = Integer.class; // Same thing
// genericIntClass = double.class; // Illegal


Class<Number> genericNumberClass = int.class //(1) Error
~~~

Integer继承了Number，所以（1）看似是正确的。但是要考虑泛型本身的类型，`Class<Number>`与`Class<Integer>`之间并不存在继承关系。可以通过通配符`<? extends Number>`来解决这个问题。



下面我们看一个例子：

~~~java
Class<FancyToy> ftc = FancyToy.class;
Class<? super FancyToy> up = ftc.getSuperclass();

Class<Toy> up2 = ftc.getSuperclass();
// This won't compile:	Required type:Class<Toy>    Provided:Class<? super FancyToy>
// because  public native Class<? super T> getSuperclass();
~~~



## instanceof关键字

关键字instanceof，它返回一个boolean值，表明一个对象是否是特定类型的实例：

~~~java
Animal x = new Dog();
x instanceof Dog		//true
x instanceof Animal		//true
~~~

**它对根据对象实际运行类型来判断的，而不是静态类型**

`Class.isInstance()`方法提供另一种**动态验证**对象类型的方式。



## 运行时的类信息

Class类和java.lang.reflect库一起支持了反射，这个库里包含Field、Method以及Constructor类（每个都实现了Member接口）。





### Field

代表对象的**一个属性**



- String getName()：返回属性名
- void set(Object obj, Object value)：设置属性值
- Object get(Object obj)：读取属性值
- Class<?> getType()：返回属性的类型
- int getModifiers()：获取属性的修饰符列表，配合着Modifier类的toString(int x)方法使用



通过调用Field对象的void setAccessible(boolean flag)方法，可以让set/get访问到私有属性（flag参数设置为true）。



~~~java
class DummyBase {
    public int fi;
    public static int fsi;
    public void ffoo() {}
}

public class Dummy extends DummyBase {
    public int i;
    protected int j;
    private int k;
    static int si;

    public void foo() {}
    private void bar() {}
    public static void tar() {}
}
~~~



~~~java
public class ReflectDemo01 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
        StringBuilder s = new StringBuilder();

        Class dummyClass = Class.forName("org.example.Dummy");
        Field[] fields = dummyClass.getDeclaredFields();
        for (Field f : fields) {
            String out  = FMT."""
            \{Modifier.toString(f.getModifiers())} \{f.getType().getSimpleName()} \{f.getName()}
            """;
            System.out.printf(out);
        }

        Dummy dummy = new Dummy();
        Field field = dummyClass.getField("i");
        field.set(dummy, 20);
        System.out.println(dummy.i);

        Field private_field = dummyClass.getDeclaredField("k");
        private_field.setAccessible(true);
        private_field.set(dummy, 100);
        System.out.println(private_field.get(dummy));
    }
}

/**
 public int i
 protected int j
 private int k
 static int si
 20
 100
*/
~~~



### Method

表示一个对象的方法

-  Object invoke(Object obj, Object... args)
  - obj：被调用的对象。
  - args：参数列表
-  String getName()：返回方法名
-   int getModifiers()：获取方法的修饰符列表，配合着Modifier类的toString(int x)方法使用
-  Class<?> getReturnType()：获取返回类型的Class对象
-  Class<?>[] getParameterTypes()：获取所有参数对应的Class对象

### Constructor

表示一个对象的构造器

- T newInstance(Object … initargs)：用于创建对象
- String getName()：获取构造器的名字
-  int getModifiers()：获取构造器的修饰符列表，配合着Modifier类的toString(int x)方法使用
- Class<?>[] getParameterTypes()：获取所有参数对应的Class对象
