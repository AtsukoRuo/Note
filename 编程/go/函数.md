# 函数

[TOC]



~~~go
func name(parameter-list) (result-list) {
    body
}
~~~

参数以及返回值都是最外部的局部变量。

~~~go
func f(i, j, k int, s, t string)                 { /* ... */ }
func f(i int, j int, k int,  s string, t string) { /* ... */ }
~~~



语法要点：

- Go语言中的函数签名包括：函数参数列表以及返回值列表，但是并不考虑参数或者返回值的命名。

- Go语言不支持默认函数以及命名调用的语法特性

- 实参通过值的方式传递



多返回值的例子：

~~~go
func findLinks(url string) ([]string, error) {		// 这里的error是一个类型
    if err != nil {
        return nil, err
    }
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("getting %s: %s", url, resp.Status)
    }
    return visit(nil, doc), nil
}

func Size(rect image.Rectangle) (width, height int)
func Split(path string) (dir, file string)
func HourMinSec(t time.Time) (hour, minute, second int)
~~~

函数的多返回值可以出现在期望特定参数数量的地方

~~~go
log.Println(findLinks(url))

// 等价
links, err := findLinks(url)
log.Println(links, err)
~~~

如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数。这称为`bare return`。

~~~go
// CountWordsAndImages does an HTTP GET request for the HTML
// document url and returns the number of words and images in it.
func CountWordsAndImages(url string) (words, images int, err error) {
    resp, err := http.Get(url)
    if err != nil {
        return
    }
    doc, err := html.Parse(resp.Body)
    resp.Body.Close()
    if err != nil {
        err = fmt.Errorf("parsing HTML: %s", err)
        return
    }
    words, images = countWordsAndImages(doc)
    return
    // 等价于 return words, images, err
}

func countWordsAndImages(n *html.Node) (words, images int) { /* ... */ }
~~~



按照惯例，最后一个返回值说明函数是否执行成功，一般为 `ok bool`或者`err error`。

错误的处理策略有：

- **传播错误**：

  ~~~go
  resp, err := http.Get(url)
  if err != nil{
      return nil, err
  }
  ~~~

- **重试**

- **输出错误信息并结束程序（可选）**

  ~~~go
  // (In function main.)
  if err := WaitForServer(url); err != nil {
      fmt.Fprintf(os.Stderr, "Site is down: %v\n", err)
      os.Exit(1)
  }
  ~~~

- **直接忽略掉错误**



文件结尾错误（EOF）：

~~~go
in := bufio.NewReader(os.Stdin)
for {
    r, _, err := in.ReadRune()
    if err == io.EOF {
        break // finished reading
    }
    if err != nil {
        return fmt.Errorf("read failed:%v", err)
    }
    // ...use r…
}
~~~



在Go中，函数被看作「first-class values」，也就是说函数有类型，可以赋值给其他变量

~~~go
var f func(int) int
f(3) // 此处f的值为nil, 会引起panic错误

var g func(var1 int) int
g(3)
~~~

函数之间是不可比较的，但可以和`nil`比较。



匿名函数（Lambda表达式、函数字面量）的使用

~~~go
// squares返回一个匿名函数。
// 该匿名函数每次被调用时都会返回下一个数的平方的函数
func squares() func() int {
    var x int
    return func() int {
        x++
        return x * x
    }
}
func main() {
    f := squares()
    // 支持闭包特性，捕获局部变量
    fmt.Println(f()()) // "1"
    fmt.Println(f()()) // "4"
    fmt.Println(f()()) // "9"
    fmt.Println(f()()) // "16"
}
~~~

一定要注意所捕获的变量的生命周期问题，例如：

~~~go
var rmdirs []func()
for _, dir := range tempDirs() {
    os.MkdirAll(dir, 0755)
    rmdirs = append(rmdirs, func() {
        os.RemoveAll(dir) // NOTE: incorrect!
    })
}

for _, rmdir := range rmdirs {
    rmdir() // clean up
}
~~~

这段代码是错误的，因为dir的作用域，所以每个rmdir都捕获着同一个变量实例dir。可以通过引入一个局部变量来解决这个问题，这样每次循环时，都捕获不同的变量实例

~~~go
for _, dir := range tempDirs() {
    dir := d // NOTE: necessary!
    os.MkdirAll(dir, 0755)
    //... 
}
~~~



可变参数

~~~go
func sum(vals ...int) int {
    int res = 0;
    for i := 0; i < len(vals); i++ {
        res += vals[i];
    }
    return res;
}

sum()				// 0
sum(1, 2, 3, 4)		// 10


values := []int{1, 2, 3, 4}
sum(values...) 		// 10
~~~



Deferred函数