## 基本命令

### go build

### go run

### go install



### 包

Go语言中的包和其他语言的库或模块的概念类似，通常一个包所在目录路径的后缀是包的导入路径；例如包`helloworld`对应的目录路径是`$GOPATH/src/helloworld` 或者`$PROJECT_PATH/helloworld`。

**在Java中，强制要求包名要与包路径是同名的。而在Go中，包路径和包名是分离的。**

每个源文件的第一条语句（除注释）都必须是包声明语句`package`，用于指明包名。在Go语言中，包名的最佳实践是**包路径的最后一部分**。包名可以不同于目录名，然而并不推荐这种做法。

一个代码包与一个目录（不包括子目录）是一一对应的：

- 一个代码包可以由若干Go源文件组成，一个代码包的源文件须都处于同一个目录下。
- 一个目录下的所有源文件必须都处于同一个代码包中，亦即这些源文件开头的`package pkgname`语句必须一致。

对于Go官方工具链来说，一个引入路径中包含有`internal`目录名的代码包被视为一个特殊的代码包。该代码包仅对子包以及直接父包可见。

每个 Go 应用程序都包含一个名为main的包，而且在main包中必须有且仅有一个main方法。执行 `go install <package>` 命令后，系统会尝试在指定的包目录里寻找带有 `main` 包声明的文件，然后将main方法作为程序的入口。

每个包都对应一个独立的名字空间。例如，在image包中的Decode函数和在unicode/utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问。



在每个源文件的包声明前紧跟着的注释是包注释。一个包通常只有一个源文件有包注释（译注：如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释）。如果包注释很大，通常会放到一个独立的doc.go文件中。



包的初始化过程：

1. 在一个程序启动时，每个包中总是在它所有依赖的包都加载完成之后才开始加载。而且每个被用到的包会被而且仅会被加载一次。Go不支持循环依赖

2. 在加载一个代码包的过程中，所有的声明在此包中的`init`函数将被串行调用并且仅调用执行一次。

   - 在同一个源文件中声明的`init`函数，将按从上到下的声明顺序被调用执行。
   - 在同一个包中的两个不同源文件中的`init`函数，Go语言白皮书推荐（但不强求）按照它们所处于的源文件的名称的词典序列来调用

   **这个init只能由编译器在初始化时调用，程序员不得调用**

   ~~~go
   package main
   
   import "fmt"
   
   func init() {
   	fmt.Println("hi,", bob)
   }
   
   func main() {
   	fmt.Println("bye")
   }
   
   func init() {
   	fmt.Println("hello,", smith)
   }
   ~~~

   

3. 同时Go编译器会解决包级变量的初始化顺序问题

   ```go
   var a = b + c // a 第三个初始化, 为 3
   var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
   var c = 1     // c 第一个初始化, 为 1
   
   func f() int { return c + 1 }
   ```



一个引入声明语句的完整形式为：

~~~go
import importname "path_to_package"
~~~

- `importname`是可选的，它的默认值为被引入的包名（不是目录名）。如果为`.`，那么在使用的时候，可以省略包名
- `path_to_package`是包所在的路径，并不是包名。