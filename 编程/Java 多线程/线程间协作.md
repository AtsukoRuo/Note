

# 协作

[TOC]

## 等待与通知

- `Object.wait()`：当前线程被暂停，并释放持有的内部锁。被唤醒后尝试获取内部锁
- `Object.wait(long)`：与`wait()`方法基本一致，但是超时后会被JVM唤醒。
- `Object.notify()`：唤醒一个任意被暂停的线程，但并不会释放内部锁。
- `Object.notifyAll()`：唤醒全部被暂停的线程

注意，只有在持有对象内部锁的情况下，才能调用`wait/notify`方法，否则抛出`IllegalMonitorStateException`



`Object.wait()`的伪代码：

~~~java
public void wait() {
    if (!Thread.holdsLock(this)) {
        throws new IllegalMonitorStateException();
    }
    
    // 注意和入口集区分
    if (当前对象不在等待集中) {
        addToWaitSet(Thread.currentThread());
    }
    
    atomic {
        // 释放当前对象的内部锁
        releaseLock(this);
        
        //暂停当前线程
        block(Thread.currentThread());// 语句①
	}
    
    // 再次申请内部锁 
    acquireLock(this)
    // 将当前线程从等待集中移除
	removeFromWaitSet(Thread.currentThread());
	return;
}
~~~



一般的业务逻辑代码：

~~~java
public void bar() {
    synchronized(object) {
        while (条件不成立) {
            object.wait();
        }
    }
}

public void foo() {
    synchronized(object) {
        更新条件
        object.notify();
    }
}
~~~

## 条件变量

条件变量就是wait/notify方法的显式锁版本。

通过显式锁对象的`newCondition()`方法获取一个条件变量，它的方法有

- `await()`
- `awaitUntil(Date deadline)`
- `signal()`
- `signalAll()`

与wait方法一样，必须持有该锁才能调用await/signal方法



使用示例：

~~~java
lock.lock();
try {
    while (条件不成立) {
        condition.await();
    }
} finally {
    lock.unlock();
}
~~~

## CountDownLatch

`CountDownLatch`内部维护一个计数器，它的构造方法如下：

~~~java
public CountDownLatch(int count)		// 设置计数器的初值
~~~

使用示例：

- 当计数器值不为 0 时，执行`CountDownLatch.await()`的线程会被暂停。`CountDownLatch.await(long, TimeUnit)`允许指定一个超时时间

- `CountDownLatch.countDown()`方法使计数器值减少1。减少到0时，就会唤醒所有被暂停的线程，并且之后计数器的值就不再发生变化。

  

## CyclicBarrier

`CyclicBarrier`内部维护一个计数器，它的构造方法如下：

```cpp
public CyclicBarrier(int parties)		// 设置计数器的初值
```

`CyclicBarrier`的构造函数还允许我们设置一个任务，当最后一个到达的线程执行 `CyclicBarrier.await()`方法后，该任务就会被调用。任务完成后，再唤醒其他等待线程。

~~~java
public CyclicBarrier(int parties, Runnable barrierAction) {}
~~~

使用示例：

- 调用`await()`方法会暂停当前线程，并将计数器减一。如果计数器为0，那么唤醒所有被暂停的线程。注意，最后一个到达的线程并不会被阻塞。

- `CountDownLatch`计数器只能使用一次，而`CyclicBarrier`的计数器可以调用 `reset()` 方法来重置

  

## 信号量

- 指定初始份额：

  ~~~java
  public Semaphore(int permits) 
  ~~~

- `release()`：返还配额

- `acquire()`：申请配额。如果当前可用配额不足，那么就会暂停等待，直到配额满足。注意，Semaphore 采用的是非公平性调度策略。

- `acquire(int permits)`

- `release(int permits)`

## 管道

`PipedOutputStream` 和 `PipedInputStream` 适合在单生产者一单消费者模式中使用。

~~~java
PipedInputStream in = new PipedInputStream();

PipedOutputStream out = new PipedOutputStream(in);
~~~

在`PipedInputstream.read()`阻塞期间，若`PipedOutputStream.close()`，则`read()`直接返回`-1`。

如果`PipedOutputStream.close()`后，`PipedInputStream`仍然`write()`，那么`java.io.IOException: Pipe closed`

## 中断机制

每个线程都会维护一个中断标记，

~~~java
/* Interrupt state of the thread - read/written directly by JVM */
private volatile boolean interrupted;
~~~

- 通过`Thread.currentThread).isInterrupted()`方法可以获取该线程的中断标记值。
- `Thread.interrupted()`将中断标志设置为`false`，并且返回设置之前的标志
- `Thread.interrupt()`将中断标志设置为`true`



~~~java
public static boolean interrupted() {
    Thread t = currentThread();
    boolean interrupted = t.interrupted;
    // We may have been interrupted the moment after we read the field, so only clear the field if we saw that it was set and will return true; otherwise we could lose an interrupt.
    if (interrupted) {
        t.interrupted = false;
        clearInterruptEvent();
    }
    return interrupted;
}

public void interrupt() {
	// ...
    interrupted = true;
    // inform VM of interrupt
    interrupt0();
}
~~~



中断机制的实现

- Java标准库中，有些阻塞方法/操作无法响应中断，例如 `InputStream. read()`、`Lock.lock()`以及内部锁的申请。

- Java标准库中大部分方法都可以响应中断

  - 在调用方法时，会对标志进行检查，检查失败则抛出`InterruptedException`。

  - 因 `CyclicBarrier.await()`、`ReentrantLock.lockInterruptibly()`等阻塞方法而被暂停的线程，对其调用`interrput()`方法后，JVM会唤醒这些线程，并抛出`InterruptedException`。

  注意，这里有个约定，即抛出`InterruptedException`之前，需要将中断标志设置为`false`

- 对于应用层代码，只能通过捕获 InterruptedException 等异常来处理中断

  - 不捕获 InterruptedException
  
  - 捕获 InterruptedException 后，重新将该异常抛出
  
  - 捕获 InterruptedException 后，中断当前线程
  
    ~~~java
    try {
    	Thread.sleep(sleepTime);
    } catch(InterruptedException e) {
        //保留线程中断标记
    	Thread.currentThread().interrupt();
    }
    ~~~
  





