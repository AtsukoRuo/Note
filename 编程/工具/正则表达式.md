# 正则表达式

### 与

 `\d` 只能匹配到一个数字，而`\d\d` 就匹配到两个连续的数字。

`reg{m,n}` 内容连续匹配 `reg` 规则 至少 m 次，至多 n 次。

![image-20240412012712393](./assets/image-20240412012712393.png)



### 或

`reg1|reg2|reg3` 表示，内容符合 `reg1`、`reg2`、`reg3` 之一即可立即匹配。但是要注意或操作，具有短路效应，即如果前者匹配了，就被忽略后续字符的匹配。

`(\d+\.\d+)|(\d+)`，通过 `()` 来确保将两部分视为独立正则表达式。



`c1|c2|c3|...|cn`可以简写为`[c1c2c3c4...cn]`，其中`c1`等都是单字符。`[a-f]`表示`[abcdef]`，即`a|b|c|d|e|f`



`^[ap]`表示匹配除 `a` 或 `p` 字符以外的所有字符

![image-20240412012814166](./assets/image-20240412012814166.png)

`\d+\.\d+`匹配小数，注意`.`为正则语法的特殊字符，必须加上`\`表示转义。

### 贪婪模式

默认情况下会匹配尽可能多的字符。

![image-20240412012829814](./assets/image-20240412012829814.png)

如果希望匹配尽可能少的字符，可以在量词的后面添加`?`。

例如，对于正则表达式 `a.*b`（贪婪模式），它会匹配字符串中从第一个 'a' 到最后一个 'b' 之间的所有字符。

对于正则表达式 `a.*?b`（非贪婪模式），它会匹配字符串中从第一个 'a' 到接下来最近的一个 'b' 之间的字符。

以下是其他的一些非贪婪的例子：

- `*?`：匹配前面的子表达式 0 次或多次，但尽可能少重复。
- `+?`：匹配前面的子表达式 1 次或多次，但尽可能少重复。
- `??`：匹配前面的子表达式 0 次或 1 次，但尽可能少重复。
- `{n,m}?`：匹配前面的子表达式至少 n 次，但不超过 m 次，尽可能少重复。

注意：`a?`表示 'a' 字符出现 0 次或 1 次，`a??`也表示 'a' 字符出现 0 次或 1 次，它们的结果是一样的。



`?`的三种含义

- 量词：`reg?`，即匹配至少一次 reg
- 位置匹配：`(?=regExp)`
- 懒惰模式：紧跟在量词的后面

### 位置匹配



**位置匹配**的特点是：匹配的内容为空字符，包括以下三类：

- 行

  - 行首`^`，从行首开始匹配，如果未开启多行模式，那么只会考虑第一行。`^abc`会匹配所有以`abc`开始的字符串。
  - 行尾`$`。`abc$` 将会匹配任何以 `abc` 结尾的字符串。

- 单词

  - 单词边界`\b`：在我们汉语中，并没有单词的概念，所以 `\b` 是无法匹配的。
  - 非单词边界`\B`：在所有位置中去除单词边界后所剩的位置

- 正则位置

  - `?=`：符合reg的前方位置

    `h(?=o)`：匹配在`o`字符前方的`h`字符

    ![image-20240412012909357](./assets/image-20240412012909357.png)

  - `?<=`：符合 reg 的后方位置，`(?<=a)r`匹配`a`字符后面的`r`字符

  - `?!`：不符合reg的前方位置

    ![image-20240412013013199](./assets/image-20240412013013199.png)

    `h(?!o)`：匹配不在`o`字符前方的`h`字符

    ![image-20240412013022281](./assets/image-20240412013022281.png)
  
  - `?<!`：不符合 reg 的后方位置



### 分组

`()` 可以创建分组，分组可以方便获取到局部正则匹配的内容。

`a[vm]`就没有分组，在获取匹配结果后，只能通过`group(0)`获取到`av`。而`a([vm])`就有一个分组，在获取匹配结果后，可以通过`group(0)`获取到整个匹配结果`av`，也可以通过`group(1)`获取到局部匹配结果`v`



我们可以从匹配结果中，提取出我们想要的结果，例如提取书名：

~~~dart
void main() {
  String src = '鲁迅创作了《狂人日记》，是中国现代文学史第一篇白话文小说。'
      '《诗经》是中国古代诗歌开端，最早的一部诗歌总集。';
  RegExp exp = RegExp(r'《(.*?)》');
  Iterable<RegExpMatch> allMatches = exp.allMatches(src);

  for (RegExpMatch match in allMatches) {
    print("match:${match.group(1)}");
  }
}
~~~



根据 `md` 的规则可以很轻松地通过 `!\[.*\](\(.*?\))` 正则匹配到图片链接内容。



多个括号嵌套时，分组规则为：从左到右数 左括号 ，是第几个，就是第几组

![image.png](./assets/aa8b5c9c772b4366b2ad23ff7fd0428dtplv-k3u1fbpfcp-jj-mark1890000q75.webp)



我们可以通过`(?<name>reg)`正则语法，为分组起名字。

~~~dart
const reg = r'(\d{1,4})年(?<月份>\d{1,2})月(\d{1,2})';
RegExp exp = RegExp(reg);
Iterable<RegExpMatch> allMatches = exp.allMatches(src);
for (RegExpMatch match in allMatches) {
    String? month = match.namedGroup("月份");
    print("====match:$month");
    print("====groupNames:${match.groupNames}");
}

~~~



有时候，我们需要基于前面匹配的内容，对后面的匹配进行限制。也就是说，后续的匹配规则需要依赖于前面匹配的内容。比如，匹配前后一致的标签`<h1></h1>`。我们可以使用**反向引用**语法来完成上述需求

 如下，通过`\1` 就可以引用第一组的匹配结果

![image-20240412014105044](./assets/image-20240412014105044.png)

反向引用也支持命名的方式：`\k<name>`

![image-20240412014112423](./assets/image-20240412014112423.png)



有时候我们加括号只是为了表示独立，并不想把它视为 **组**，这时可以使用特定的语法 `(?:reg)` 表示不捕获组。例如，`'a(?:[vm])'`

