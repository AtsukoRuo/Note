# 结构型模式

结构型模式主要总结了一些类或对象组合在一起的经典结构，以组合优于继承的思想为指导。

[TOC]

代理、桥接、装饰器、适配器，这4种模式是比较常用的结构型设计模式。它们都可以称为Wrapper模式，也就是通过Wrapper类二次封装原始类。它们的代码结构非常相似，但设计意图完全不同：

- **代理模式：**代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。

- **桥接模式：**桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。

- **装饰器模式：**装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。

- **适配器模式：**适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。



## 代理模式

**代理模式**（Proxy Design Pattern）在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。

我们通过一个例子来解释这个概念。在开发性能计数器时，我们设计了MetricsCollector类，用来收集接口请求的原始数据，它的使用方式如下：

~~~java
public class UserController {
  //...省略其他属性和方法...
  private MetricsCollector metricsCollector; // 依赖注入

  public UserVo login(String telephone, String password) {
    long startTimestamp = System.currentTimeMillis();

    // ... 省略login逻辑...

    long endTimeStamp = System.currentTimeMillis();
    long responseTime = endTimeStamp - startTimestamp;
    RequestInfo requestInfo = new RequestInfo("login", responseTime, startTimestamp);
   	//收集信息
    metricsCollector.recordRequest(requestInfo);

    //...返回UserVo数据...
  }
}

~~~

上面的写法有两个问题：

- 性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。
- 收集接口请求的代码跟业务代码无关。业务类最好职责更加单一，只聚焦业务处理。



为了将框架代码和业务代码解耦，我们设计代理类UserControllerProxy和原始类UserController实现相同的接口IUserController。UserController类只负责业务功能。代理类UserControllerProxy负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。

~~~java
public interface IUserController {
  UserVo login(String telephone, String password);
  UserVo register(String telephone, String password);
}

public class UserController implements IUserController {
  //...省略其他属性和方法...

  @Override
  public UserVo login(String telephone, String password) {
    //...省略login逻辑...
    //...返回UserVo数据...
  }

  @Override
  public UserVo register(String telephone, String password) {
    //...省略register逻辑...
    //...返回UserVo数据...
  }
}

public class UserControllerProxy implements IUserController {
  private MetricsCollector metricsCollector;
  private UserController userController;

  public UserControllerProxy(UserController userController) {
    this.userController = userController;
    this.metricsCollector = new MetricsCollector();
  }

  @Override
  public UserVo login(String telephone, String password) {
    //调用前的逻辑
    long startTimestamp = System.currentTimeMillis();

    // 委托
    UserVo userVo = userController.login(telephone, password);
	
    //调用后的逻辑
    long endTimeStamp = System.currentTimeMillis();
    long responseTime = endTimeStamp - startTimestamp;
    RequestInfo requestInfo = new RequestInfo("login", responseTime, startTimestamp);
    metricsCollector.recordRequest(requestInfo);

    return userVo;
  }

  @Override
  public UserVo register(String telephone, String password) {
    long startTimestamp = System.currentTimeMillis();

    UserVo userVo = userController.register(telephone, password);

    long endTimeStamp = System.currentTimeMillis();
    long responseTime = endTimeStamp - startTimestamp;
    RequestInfo requestInfo = new RequestInfo("register", responseTime, startTimestamp);
    metricsCollector.recordRequest(requestInfo);

    return userVo;
  }
}

//UserControllerProxy使用举例
//因为原始类和代理类实现相同的接口，是基于接口而非实现编程
//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码
IUserController userController = new UserControllerProxy(new UserController());

~~~

但是，如果原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），那么我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，我们该如何实现代理模式呢？

对于这种外部类的扩展，我们一般都是采用继承的方式（我更喜欢这种方式）。

~~~java
public class UserControllerProxy extends UserController {
  private MetricsCollector metricsCollector;

  public UserControllerProxy() {
    this.metricsCollector = new MetricsCollector();
  }

  public UserVo login(String telephone, String password) {
    long startTimestamp = System.currentTimeMillis();

    UserVo userVo = super.login(telephone, password);

    long endTimeStamp = System.currentTimeMillis();
    long responseTime = endTimeStamp - startTimestamp;
    RequestInfo requestInfo = new RequestInfo("login", responseTime, startTimestamp);
    metricsCollector.recordRequest(requestInfo);

    return userVo;
  }

  public UserVo register(String telephone, String password) {
    long startTimestamp = System.currentTimeMillis();

    UserVo userVo = super.register(telephone, password);

    long endTimeStamp = System.currentTimeMillis();
    long responseTime = endTimeStamp - startTimestamp;
    RequestInfo requestInfo = new RequestInfo("register", responseTime, startTimestamp);
    metricsCollector.recordRequest(requestInfo);

    return userVo;
  }
}
//UserControllerProxy使用举例
UserController userController = new UserControllerProxy();
~~~

### 动态代理

不过，刚刚的代码实现还是有点问题的：

- 我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。
- 如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。

我们可以使用**动态代理（Dynamic Proxy）**来解决这个问题。我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

在Java的动态代理对象上执行的所有调用，都会被重定向到一个**调用处理器（invocation handler）**上。这个调用处理器的工作就是发现这是什么调用，然后决定如何处理它。

~~~java
public class MetricsCollectorProxy {
  private MetricsCollector metricsCollector;

  public MetricsCollectorProxy() {
    this.metricsCollector = new MetricsCollector();
  }

  // 通过这个方法来创建动态代理对象
  public Object createProxy(Object proxiedObject) {
      
    // 获取被代理对象的所有直接接口
    Class<?>[] interfaces = proxiedObject.getClass().getInterfaces();
    DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject);
      
    return Proxy.newProxyInstance(
        proxiedObject.getClass().getClassLoader(), 			// 被代理对象的类加载器
        interfaces, 									 // 代理对象要实现的接口列表
        handler											//  调用处理器，一个实现InvocationHandler接口的对象
    );
  }

  // 调用处理器
  private class DynamicProxyHandler implements InvocationHandler {
    private Object proxiedObject;

    public DynamicProxyHandler(Object proxiedObject) {
      this.proxiedObject = proxiedObject;
    }

    // 关键方法
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
       //proxy 代理的对象
       //method 当前调用的方法
       //args 方法参数
      long startTimestamp = System.currentTimeMillis();
        
      //从这里调用原对象的方法
      Object result = method.invoke(proxiedObject, args);
        
      long endTimeStamp = System.currentTimeMillis();
      long responseTime = endTimeStamp - startTimestamp;
      String apiName = proxiedObject.getClass().getName() + ":" + method.getName();
      RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp);
      metricsCollector.recordRequest(requestInfo);
      return result;
    }
  }
}

//MetricsCollectorProxy使用举例
MetricsCollectorProxy proxy = new MetricsCollectorProxy();
IUserController userController = (IUserController) proxy.createProxy(new UserController());

~~~



Spring AOP底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring为这些类创建动态代理对象，并在JVM中替代原始类对象。







### 应用场景

代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志、缓存。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。



**实际上，RPC框架也可以看作一种代理模式**，GoF的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。

> https://github.com/wangzheng0822/codedesign/tree/master/com/xzg/cd/rpc
>
> 这是一个简易的RPC框架，回来有时间看看。



## 桥接模式

**桥接模式**，也叫作**桥梁模式**（Bridge Design Pattern）。它是最难理解的、最少应用的设计模式，了解即可。

对于这个模式有两种不同的理解方式:

- **Decouple an abstraction from its implementation so that the two can vary independently**

  **将抽象和实现解耦，让它们可以独立变化**

  理解该定义的关键是，弄懂“抽象”和“实现”两个概念。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系，组装在一起。

- **一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。**

  类似“组合优于继承”设计原则，通过组合关系来替代继承关系，避免继承层次的指数级爆炸。



我们通过JDBC驱动的例子，来解释一下GoF的理解方式：

~~~java
Class.forName("com.mysql.jdbc.Driver");//加载及注册JDBC驱动程序
String url = "jdbc:mysql://localhost:3306/sample_db?user=root&password=your_password";

Connection con = DriverManager.getConnection(url);		//建立与数据库的连接
Statement stmt = con.createStatement()；				    //创建语句对象
String query = "select * from test";					//指定要执行的语句
ResultSet rs = stmt.executeQuery(query);				//开始执行，并获取结果
~~~

如果我们想要把MySQL数据库换成Oracle数据库，只需要把第一行代码中的`com.mysql.jdbc.Driver`换成`oracle.jdbc.driver.OracleDriver`就可以了。那如此简洁的数据库切换是如何实现的呢？我们先从`com.mysql.jdbc.Driver`这个类的代码看起

~~~java
package com.mysql.jdbc;
import java.sql.SQLException;

public class Driver extends NonRegisteringDriver implements java.sql.Driver {
	static {
		try {
            // MySQL Driver注册到DriverManager类中。
			java.sql.DriverManager.registerDriver(new Driver());
		} catch (SQLException E) {
			throw new RuntimeException("Can't register driver!");
		}
	}

	public Driver() throws SQLException {
		// Required for Class.forName().newInstance()
	}
}

~~~

我们再来看一下，`DriverManager`类有什么用
~~~java
public class DriverManager {
  private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = new CopyOnWriteArrayList<DriverInfo>();

  //...
  static {
    loadInitialDrivers();
    println("JDBC DriverManager initialized");
  }
  //...

  public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException {
    if (driver != null) {
      registeredDrivers.addIfAbsent(new DriverInfo(driver));
    } else {
      throw new NullPointerException();
    }
  }

  public static Connection getConnection(String url, String user, String password) throws SQLException {
    java.util.Properties info = new java.util.Properties();
    if (user != null) {
      info.put("user", user);
    }
    if (password != null) {
      info.put("password", password);
    }
    return (getConnection(url, info, Reflection.getCallerClass()));
  }
  //...
}

~~~

当我们把具体的Driver实现类（比如，com.mysql.jdbc.Driver）注册到DriverManager之后，后续所有对JDBC接口的调用，都会委派到对具体的Driver实现类来执行。而Driver实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换Driver的原因。

桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那在JDBC这个例子中，什么是“抽象”？什么是“实现”呢？实际上，JDBC本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC和Driver独立开发，通过对象之间的组合关系，组装在一起。JDBC的所有逻辑操作，最终都委托给Driver来执行。

![](assets/812234b0717043a67c2d62ea8e783b40.jpg)

### 例子

API接口监控告警的例子：根据不同的告警规则，触发不同类型的告警。我们先来看最简单、最直接的一种实现方式。

~~~java
//通知的紧急程度
//SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）
public enum NotificationEmergencyLevel {
  SEVERE, URGENCY, NORMAL, TRIVIAL
}

public class Notification {
  private List<String> emailAddresses;
  private List<String> telephones;
  private List<String> wechatIds;

  public Notification() {}

  public void setEmailAddress(List<String> emailAddress) {
    this.emailAddresses = emailAddress;
  }

  public void setTelephones(List<String> telephones) {
    this.telephones = telephones;
  }

  public void setWechatIds(List<String> wechatIds) {
    this.wechatIds = wechatIds;
  }

  public void notify(NotificationEmergencyLevel level, String message) {
    if (level.equals(NotificationEmergencyLevel.SEVERE)) {
      //...自动语音电话
    } else if (level.equals(NotificationEmergencyLevel.URGENCY)) {
      //...发微信
    } else if (level.equals(NotificationEmergencyLevel.NORMAL)) {
      //...发邮件
    } else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) {
      //...发邮件
    }
  }
}

//在API监控告警的例子中，我们如下方式来使用Notification类：
public class ErrorAlertHandler extends AlertHandler {
  public ErrorAlertHandler(AlertRule rule, Notification notification){
    super(rule, notification);
  }


  @Override
  public void check(ApiStatInfo apiStatInfo) {
    if (apiStatInfo.getErrorCount() > rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {
      notification.notify(NotificationEmergencyLevel.SEVERE, "...");
    }
  }
}

~~~

Notification类的代码实现有一个最明显的问题，那就是有很多if-else分支逻辑。实际上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多if-else分支判断），那这样的设计问题并不大。不过，Notification的代码显然不符合这个条件，因为每个if-else分支中的代码逻辑都比较复杂。我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender相关类）。其中，Notification类相当于抽象，MsgSender类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：

~~~java
public interface MsgSender {
  void send(String message);
}

public class TelephoneMsgSender implements MsgSender {
  private List<String> telephones;

  public TelephoneMsgSender(List<String> telephones) {
    this.telephones = telephones;
  }

  @Override
  public void send(String message) {
    //...
  }

}

public class EmailMsgSender implements MsgSender {
  // 与TelephoneMsgSender代码结构类似，所以省略...
}

public class WechatMsgSender implements MsgSender {
  // 与TelephoneMsgSender代码结构类似，所以省略...
}

public abstract class Notification {
  protected MsgSender msgSender;

  public Notification(MsgSender msgSender) {
    this.msgSender = msgSender;
  }

  public abstract void notify(String message);
}

public class SevereNotification extends Notification {
  public SevereNotification(MsgSender msgSender) {
    super(msgSender);
  }

  @Override
  public void notify(String message) {
    msgSender.send(message);
  }
}

public class UrgencyNotification extends Notification {
  // 与SevereNotification代码结构类似，所以省略...
}
public class NormalNotification extends Notification {
  // 与SevereNotification代码结构类似，所以省略...
}
public class TrivialNotification extends Notification {
  // 与SevereNotification代码结构类似，所以省略...
}
~~~

## 装饰器模式

假设我们有一个Stream类，现在我们要支持从File、Network、Memory中获取流，那么我们就会派生出FileStream、NetworkStream、MemoryStream等类。如果我们还要支持缓存、加密的功能，那就要继续派生出BufferedFileStream、CryptoFileStream、CryptoStreamBufferedFile....。并且我们假定加密、缓存的逻辑对于FileStream、NetworkStream、MemoryStream来说都是一样的。

![image-20231025001407460](assets/image-20231025001407460.png)

很明显就存在以下两个问题：

- 功能的实现逻辑是一样的，代码冗余
- 如果我们需要附加更多的增强功能，此时组合爆炸，导致类继承结构变得无比复杂

**注意装饰器模式应用的前提：增强功能的逻辑对于所有类来说是相同的。**



针对这个问题，我们可以将继承关系改为组合关系来解决，下面我们看看Java IO库中是如何应用装饰器模式的。

~~~java
public abstract class InputStream {
  //...
  public int read(byte b[]) throws IOException {
    return read(b, 0, b.length);
  }
  
  public int read(byte b[], int off, int len) throws IOException {
    //...
  }
  
  public long skip(long n) throws IOException {
    //...
  }

  public int available() throws IOException {
    return 0;
  }
  
  public void close() throws IOException {}

  public synchronized void mark(int readlimit) {}
    
  public synchronized void reset() throws IOException {
    throw new IOException("mark/reset not supported");
  }

  public boolean markSupported() {
    return false;
  }
}

public class BufferedInputStream extends InputStream {
  protected volatile InputStream in;

  protected BufferedInputStream(InputStream in) {
    this.in = in;
  }
  
  //...实现基于缓存的读数据接口...  
}

public class DataInputStream extends InputStream {
  protected volatile InputStream in;

  protected DataInputStream(InputStream in) {
    this.in = in;
  }
  
  //...实现读取基本类型数据的接口
}

~~~

装饰器模式相对于简单的组合关系，有两个差异：

- 装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类

- 装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。在代理模式中，代理类附加的是跟原始类无关的功能

  ~~~java
  // 代理模式的代码结构(下面的接口也可以替换成抽象类)
  public interface IA {
    void f();
  }
  
  public class A impelements IA {
    public void f() { //... }
  }
      
  public class AProxy implements IA {
    private IA a;
    public AProxy(IA a) {
      this.a = a;
    }
    
    public void f() {
      // 新添加的代理逻辑
      a.f();
      // 新添加的代理逻辑
    }
  }
  
  // 装饰器模式的代码结构(下面的接口也可以替换成抽象类)
  public interface IA {
    void f();
  }
      
  public class A implements IA {
    public void f() { //... }
  }
      
  public class ADecorator implements IA {
    private IA a;
    public ADecorator(IA a) {
      this.a = a;
    }
    
    public void f() {
      // 功能增强代码
      a.f();
      // 功能增强代码
    }
  }
  ~~~



实际上，BufferedInputStream、DataInputStream继承FilterInputStream的类。为什么BufferedInputStream不直接继承InputStream呢？我们假设它是继承自InputStream，那么代码如下：

~~~java
public class BufferedInputStream extends InputStream {
  protected volatile InputStream in;

  protected BufferedInputStream(InputStream in) {
    this.in = in;
  }
  
  // f()函数不需要增强，只是重新调用一下InputStream in对象的f()
  public void f() {
    in.f();
  }  
}
~~~

问题就在于，即使BufferedInputStream不需要对in的f()方法进行加强，也必须重写f()方法来调用in的f()。如果只有一个增强类还好说。但是还有多个增强类，那么不得不重复写这些模板代码。因此为了避免代码冗余，单独抽象出一个父类，来一次性编写这些模板代码。

~~~java
public class FilterInputStream extends InputStream {
  protected volatile InputStream in;

  protected FilterInputStream(InputStream in) {
    this.in = in;
  }

  public int read() throws IOException {
    return in.read();
  }

  public int read(byte b[]) throws IOException {
    return read(b, 0, b.length);
  }
   
  public int read(byte b[], int off, int len) throws IOException {
    return in.read(b, off, len);
  }

  public long skip(long n) throws IOException {
    return in.skip(n);
  }

  public int available() throws IOException {
    return in.available();
  }

  public void close() throws IOException {
    in.close();
  }

  public synchronized void mark(int readlimit) {
    in.mark(readlimit);
  }

  public synchronized void reset() throws IOException {
    in.reset();
  }

  public boolean markSupported() {
    return in.markSupported();
  }
}

~~~





## 适配器模式

**适配器模式（Adapter Design Pattern）**将不兼容的接口转换为可兼容的接口。两种实现方式有两种：

- **类适配器**：通过继承实现
- **对象适配器**：通过组合实现

~~~java
//Adaptor将Adaptee转化成一组符合ITarget接口定义的接口。

// 类适配器: 基于继承
public interface ITarget {
  void f1();
  void f2();
  void fc();
}

public class Adaptee {
  public void fa() { //... }
  public void fb() { //... }
  public void fc() { //... }
}

public class Adaptor extends Adaptee implements ITarget {
  public void f1() {
    super.fa();
  }
  
  public void f2() {
    //...重新实现f2()...
  }
  
  // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点
}

      
      
// 对象适配器：基于组合
public interface ITarget {
  void f1();
  void f2();
  void fc();
}

public class Adaptee {
  public void fa() { //... }
  public void fb() { //... }
  public void fc() { //... }
}

public class Adaptor implements ITarget {
  private Adaptee adaptee;
  
  public Adaptor(Adaptee adaptee) {
    this.adaptee = adaptee;
  }
  
  public void f1() {
    adaptee.fa(); //委托给Adaptee
  }
  
  public void f2() {
    //...重新实现f2()...
  }
  
  public void fc() {
    adaptee.fc();
  }
}
~~~

在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个：

- Adaptee接口的个数
- Adaptee和ITarget的契合程度

如果Adaptee接口并不多，那两种实现方式都可以。如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都相同，推荐使用类适配器，否则使用对象适配器。



### 适配器模式的应用场景

- **封装有缺陷的接口设计**：假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，这个时候就可以使用适配器模式了。

  ~~~java
  public class CD { //这个类来自外部sdk，我们无权修改它的代码
    //...
    public static void staticFunction1() { //... }
    
    public void uglyNamingFunction2() { //... }
  
    public void tooManyParamsFunction3(int paramA, int paramB, ...) { //... }
    
     public void lowPerformanceFunction4() { //... }
  }
  
  // 使用适配器模式进行重构
  public class ITarget {
    void function1();
    void function2();
    void fucntion3(ParamsWrapperDefinition paramsWrapper);
    void function4();
    //...
  }
  
  public class CDAdaptor extends CD implements ITarget {
    //...
    public void function1() {
       super.staticFunction1();
    }
    
    public void function2() {
      super.uglyNamingFucntion2();
    }
    
    public void function3(ParamsWrapperDefinition paramsWrapper) {
       super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);
    }
    
    public void function4() {
      //...reimplement it...
    }
  }
  ~~~

- **统一多个类的接口设计**：某个功能的实现依赖要多个外部系统（或者说类），通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。

  举个例子来解释一下：假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。

  ~~~java
  public class ASensitiveWordsFilter { // A敏感词过滤系统提供的接口
    //text是原始文本，返回用***替换敏感词之后的文本
    public String filterSexyWords(String text) {
      // ...
    }
    
    public String filterPoliticalWords(String text) {
      // ...
    } 
  }
  
  public class BSensitiveWordsFilter  { // B敏感词过滤系统提供的接口
    public String filter(String text) {
      //...
    }
  }
  
  public class CSensitiveWordsFilter { // C敏感词过滤系统提供的接口
    public String filter(String text, String mask) {
      //...
    }
  }
  
  // 未使用适配器模式之前的代码：代码的可测试性、扩展性不好
  public class RiskManagement {
    private ASensitiveWordsFilter aFilter = new ASensitiveWordsFilter();
    private BSensitiveWordsFilter bFilter = new BSensitiveWordsFilter();
    private CSensitiveWordsFilter cFilter = new CSensitiveWordsFilter();
    
    public String filterSensitiveWords(String text) {
      String maskedText = aFilter.filterSexyWords(text);
      maskedText = aFilter.filterPoliticalWords(maskedText);
      maskedText = bFilter.filter(maskedText);
      maskedText = cFilter.filter(maskedText, "***");
      return maskedText;
    }
  }
  
  // 使用适配器模式进行改造
  public interface ISensitiveWordsFilter { // 统一接口定义
    String filter(String text);
  }
  
  // 对象适配器：基于组合
  public class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter {
    private ASensitiveWordsFilter aFilter;			//组合
    public String filter(String text) {
      String maskedText = aFilter.filterSexyWords(text);
      maskedText = aFilter.filterPoliticalWords(maskedText);
      return maskedText;
    }
  }
  //...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...
  
  // 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，
  // 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。
  // 这个其实就是一个职责链模式
  public class RiskManagement { 
    private List<ISensitiveWordsFilter> filters = new ArrayList<>();
   
    public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) {
      filters.add(filter);
    }
    
    public String filterSensitiveWords(String text) {
      String maskedText = text;
      for (ISensitiveWordsFilter filter : filters) {
        maskedText = filter.filter(maskedText);
      }
      return maskedText;
    }
  }
  
  ~~~

  

- **替换依赖的外部系统**：当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。具体的代码示例如下所示：

  ~~~java
  // 外部系统A
  public interface IA {
    //...
    void fa();
  }
  
  public class A implements IA {
    //...
    public void fa() { //... }
  }
      
  // 在我们的项目中，外部系统A的使用示例
  public class Demo {
    private IA a;
    public Demo(IA a) {
      this.a = a;
    }
    //...
  }
  Demo d = new Demo(new A());
  
  // 将外部系统A替换成外部系统B
  public class BAdaptor implemnts IA {
    private B b;
    public BAdaptor(B b) {
      this.b= b;
    }
    public void fa() {
      //...
      b.fb();
    }
  }
      
   
  // 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，
  // 只需要将BAdaptor如下注入到Demo即可。
  Demo d = new Demo(new BAdaptor(new B()));
  
  ~~~

- **兼容老版本接口**：在做版本升级的时候，对于一些要废弃的接口，我们不直接删除它，而是将它标注为deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，给修改代码留下一定时间。

  例如，我们将Enumeration类重构为Iterator类

  ~~~java
  public class Collections {
    public static Emueration emumeration(final Collection c) {
      对象适配器：基于组合
      return new Enumeration() {
        Iterator i = c.iterator();
        
        public boolean hasMoreElments() {
          return i.hashNext();
        }
        
        public Object nextElement() {
          return i.next():
        }
      }
    }
  }
  ~~~

  

- **适配不同格式的数据**：Java中的Arrays.asList()也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型

  ~~~java
  List<String> stooges = Arrays.asList("Larry", "Moe", "Curly");
  ~~~

### 案例：适配器模式在Java日志中的应用

Slf4j是日志框架的统一接口规范，类似JDBC规范。log4j、logback等是Slf4j的具体实现。但是Slf4j的出现晚于JUL、JCL、log4j等日志框架。这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合Slf4j接口规范。Slf4j也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。

~~~java
// slf4j统一的接口定义
package org.slf4j;
public interface Logger {
  public boolean isTraceEnabled();
  public void trace(String msg);
  public void trace(String format, Object arg);
  public void trace(String format, Object arg1, Object arg2);
  public void trace(String format, Object[] argArray);
  public void trace(String msg, Throwable t);
 
  public boolean isDebugEnabled();
  public void debug(String msg);
  public void debug(String format, Object arg);
  public void debug(String format, Object arg1, Object arg2)
  public void debug(String format, Object[] argArray)
  public void debug(String msg, Throwable t);

  //...省略info、warn、error等一堆接口
}

// log4j日志框架的适配器
// Log4jLoggerAdapter实现了LocationAwareLogger接口，
// 其中LocationAwareLogger继承自Logger接口，
package org.slf4j.impl;
public final class Log4jLoggerAdapter extends MarkerIgnoringBase
  implements LocationAwareLogger, Serializable {
  final transient org.apache.log4j.Logger logger; // log4j
 
  public boolean isDebugEnabled() {
    return logger.isDebugEnabled();
  }
 
  public void debug(String msg) {
    logger.log(FQCN, Level.DEBUG, msg, null);
  }
 
  public void debug(String format, Object arg) {
    if (logger.isDebugEnabled()) {
      FormattingTuple ft = MessageFormatter.format(format, arg);
      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());
    }
  }
 
  public void debug(String format, Object arg1, Object arg2) {
    if (logger.isDebugEnabled()) {
      FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);
      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());
    }
  }
 
  public void debug(String format, Object[] argArray) {
    if (logger.isDebugEnabled()) {
      FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);
      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());
    }
  }
 
  public void debug(String msg, Throwable t) {
    logger.log(FQCN, Level.DEBUG, msg, t);
  }
  //...省略一堆接口的实现...
}

~~~



实际上，Slf4j不仅仅提供了从其他日志框架到Slf4j的适配器，还提供了反向适配器，也就是从Slf4j到其他日志框架的适配。这样经过两次适配器的转换，我们可以切换到不同的日志框架上



## 门面模式

> Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.
>
> 面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。

假设有一个系统A，提供了a、b、c、d四个接口。系统B完成某个业务功能，需要调用A系统的a、b、d接口。利用门面模式，我们提供一个包裹a、b、d接口调用的门面接口x，给系统B直接使用。

### 应用场景

- 易用性问题：它解决了可复用性与易用性之间的冲突。如果一个接口的粒度太细，那么它职责更单一（复用性），但是需要调用更多的接口来实现一个业务功能（易用性）。此时我们可以用门面模式将多个细粒度的接口包裹成一个粗粒度的接口，供调用者使用。
- 性能问题：假设系统B需要通过RPC技术，依次调用系统A的a、b、d三个接口。我们可以提供一个包裹a、b、d接口调用的门面接口x，给系统B直接使用。这样我们可以将网络通信的次数从3次减少到1次（网络流量是不变的）。
- 分布式事务问题：要支持两个接口调用在一个事务中执行，是比较难实现的。最简单的解决方案是，利用数据库事务或者Spring框架提供的事务，再设计一个包裹这两个操作的新接口，让新接口在事务中执行这两个接口。

## 组合模式



> Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.
>
> 将一组对象组织（Compose）成树形结构，以表示一种“部分-整体”的层次结构。组合让客户端可以统一单个对象和组合对象的处理逻辑。

这个组合模式更偏向于数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。



举个例子来给解释一下定义，假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：

*   动态地添加、删除某个目录下的子目录或文件
*   统计指定目录下的文件个数
*   统计指定目录下的文件总大小

~~~java
// 文件和目录统一用FileSystemNode类来表示
public class FileSystemNode {
  private String path;
  private boolean isFile;
  private List<FileSystemNode> subNodes = new ArrayList<>();

  public FileSystemNode(String path, boolean isFile) {
    this.path = path;
    this.isFile = isFile;
  }

  public int countNumOfFiles() {
    // TODO:...
  }

  public long countSizeOfFiles() {
    // TODO:...
  }

  public String getPath() {
    return path;
  }

  public void addSubNode(FileSystemNode fileOrDir) {
    subNodes.add(fileOrDir);
  }

  public void removeSubNode(FileSystemNode fileOrDir) {
    int size = subNodes.size();
    int i = 0;
    for (; i < size; ++i) {
      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {
        break;
      }
    }
    if (i < size) {
      subNodes.remove(i);
    }
  }
}

~~~

单纯从功能实现角度来说，上面的代码没有问题。但是扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性的角度来说，我们最好对文件和目录进行区分设计，定义为File和Directory两个类。

~~~java
public abstract class FileSystemNode {
  protected String path;

  public FileSystemNode(String path) {
    this.path = path;
  }

  public abstract int countNumOfFiles();
  public abstract long countSizeOfFiles();

  public String getPath() {
    return path;
  }
}

public class File extends FileSystemNode {
  public File(String path) {
    super(path);
  }

  @Override
  public int countNumOfFiles() {
    return 1;
  }

  @Override
  public long countSizeOfFiles() {
    java.io.File file = new java.io.File(path);
    if (!file.exists()) return 0;
    return file.length();
  }
}

public class Directory extends FileSystemNode {
  private List<FileSystemNode> subNodes = new ArrayList<>();

  public Directory(String path) {
    super(path);
  }

  @Override
  public int countNumOfFiles() {
    int numOfFiles = 0;
    for (FileSystemNode fileOrDir : subNodes) {
      numOfFiles += fileOrDir.countNumOfFiles();
    }
    return numOfFiles;
  }

  @Override
  public long countSizeOfFiles() {
    long sizeofFiles = 0;
    for (FileSystemNode fileOrDir : subNodes) {
      sizeofFiles += fileOrDir.countSizeOfFiles();
    }
    return sizeofFiles;
  }

  public void addSubNode(FileSystemNode fileOrDir) {
    subNodes.add(fileOrDir);
  }

  public void removeSubNode(FileSystemNode fileOrDir) {
    int size = subNodes.size();
    int i = 0;
    for (; i < size; ++i) {
      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {
        break;
      }
    }
    if (i < size) {
      subNodes.remove(i);
    }
  }
}

~~~

接下来，我们用它们来表示一个文件系统中的目录树结构。

~~~java
public class Demo {
  public static void main(String[] args) {
    /**
     * /
     * /wz/
     * /wz/a.txt
     * /wz/b.txt
     * /wz/movies/
     * /wz/movies/c.avi
     * /xzg/
     * /xzg/docs/
     * /xzg/docs/d.txt
     */
    Directory fileSystemTree = new Directory("/");
    Directory node_wz = new Directory("/wz/");
    Directory node_xzg = new Directory("/xzg/");
    fileSystemTree.addSubNode(node_wz);
    fileSystemTree.addSubNode(node_xzg);

    File node_wz_a = new File("/wz/a.txt");
    File node_wz_b = new File("/wz/b.txt");
    Directory node_wz_movies = new Directory("/wz/movies/");
    node_wz.addSubNode(node_wz_a);
    node_wz.addSubNode(node_wz_b);
    node_wz.addSubNode(node_wz_movies);

    File node_wz_movies_c = new File("/wz/movies/c.avi");
    node_wz_movies.addSubNode(node_wz_movies_c);

    Directory node_xzg_docs = new Directory("/xzg/docs/");
    node_xzg.addSubNode(node_xzg_docs);

    File node_xzg_docs_d = new File("/xzg/docs/d.txt");
    node_xzg_docs.addSubNode(node_xzg_docs_d);

    System.out.println("/ files num:" + fileSystemTree.countNumOfFiles());
    System.out.println("/wz/ files num:" + node_wz.countNumOfFiles());
  }
}

~~~

从上述例子中，我们可以得出组合模式的代码结构：



![动图](assets/v2-44c5f1708c950ea16871b8d91315d0ea_b-1698198264916-5.webp)



## 享元模式

享元模式可以复用对象，节省内存。但使用前提是，享元对象是不可变对象。“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态就不会再被修改了。

实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。

享元模式对JVM的垃圾回收并不友好。因为享元工厂类一直保存了对享元对象的引用，这就导致享元对象在没有任何代码使用的情况下，也并不会被JVM垃圾回收机制自动回收掉。

### 例子

下面通过一个象棋的例子，来解释一下享元模式。

假设我们在开发象棋游戏，一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。

~~~java
public class ChessPiece {//棋子
  private int id;
  private String text;
  private Color color;
  private int positionX;
  private int positionY;

  public ChessPiece(int id, String text, Color color, int positionX, int positionY) {
    this.id = id;
    this.text = text;
    this.color = color;
    this.positionX = positionX;
    this.positionY = positionX;
  }

  public static enum Color {
    RED, BLACK
  }

  // ...省略其他属性和getter/setter方法...
}

public class ChessBoard {//棋局
  private Map<Integer, ChessPiece> chessPieces = new HashMap<>();

  public ChessBoard() {
    init();
  }

  private void init() {
    chessPieces.put(1, new ChessPiece(1, "車", ChessPiece.Color.BLACK, 0, 0));
    chessPieces.put(2, new ChessPiece(2,"馬", ChessPiece.Color.BLACK, 0, 1));
    //...省略摆放其他棋子的代码...
  }

  public void move(int chessPieceId, int toPositionX, int toPositionY) {
    //...省略...
  }
}

~~~

我们将棋子作为享元供多个棋盘复用，重构代码如下：

~~~java
// 享元类
public class ChessPieceUnit {
  private int id;
  private String text;
  private Color color;

  public ChessPieceUnit(int id, String text, Color color) {
    this.id = id;
    this.text = text;
    this.color = color;
  }

  public static enum Color {
    RED, BLACK
  }

  // ...省略其他属性和getter方法...
}

// 我们利用工厂类来缓存ChessPieceUnit信息
public class ChessPieceUnitFactory {
  private static final Map<Integer, ChessPieceUnit> pieces = new HashMap<>();

  static {
    pieces.put(1, new ChessPieceUnit(1, "車", ChessPieceUnit.Color.BLACK));
    pieces.put(2, new ChessPieceUnit(2,"馬", ChessPieceUnit.Color.BLACK));
    //...省略摆放其他棋子的代码...
  }

  public static ChessPieceUnit getChessPiece(int chessPieceId) {
    return pieces.get(chessPieceId);
  }
}

public class ChessPiece {
  private ChessPieceUnit chessPieceUnit;
  private int positionX;
  private int positionY;

  public ChessPiece(ChessPieceUnit unit, int positionX, int positionY) {
    this.chessPieceUnit = unit;
    this.positionX = positionX;
    this.positionY = positionY;
  }
  // 省略getter、setter方法
}

public class ChessBoard {
  private Map<Integer, ChessPiece> chessPieces = new HashMap<>();

  public ChessBoard() {
    init();
  }

  private void init() {
    chessPieces.put(1, new ChessPiece(
            ChessPieceUnitFactory.getChessPiece(1), 0,0));
    chessPieces.put(1, new ChessPiece(
            ChessPieceUnitFactory.getChessPiece(2), 1,0));
    //...省略摆放其他棋子的代码...
  }

  public void move(int chessPieceId, int toPositionX, int toPositionY) {
    //...省略...
  }
}

~~~



我们再来看看，如何利用享元模式来优化文本编辑器的内存占用。

我们把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息。具体的代码示例如下所示：

~~~java
public class Character {//文字
  private char c;

  private Font font;
  private int size;
  private int colorRGB;

  public Character(char c, Font font, int size, int colorRGB) {
    this.c = c;
    this.font = font;
    this.size = size;
    this.colorRGB = colorRGB;
  }
}

public class Editor {
  private List<Character> chars = new ArrayList<>();

  public void appendCharacter(char c, Font font, int size, int colorRGB) {
    Character character = new Character(c, font, size, colorRGB);
    chars.add(character);
  }
}
~~~

对于字体格式，我们可以将它设计成享元，让不同的文字共享使用。

~~~java
public class CharacterStyle {
  private Font font;
  private int size;
  private int colorRGB;

  public CharacterStyle(Font font, int size, int colorRGB) {
    this.font = font;
    this.size = size;
    this.colorRGB = colorRGB;
  }

  @Override
  public boolean equals(Object o) {
    CharacterStyle otherStyle = (CharacterStyle) o;
    return font.equals(otherStyle.font)
            && size == otherStyle.size
            && colorRGB == otherStyle.colorRGB;
  }
}

public class CharacterStyleFactory {
  private static final List<CharacterStyle> styles = new ArrayList<>();

  public static CharacterStyle getStyle(Font font, int size, int colorRGB) {
    CharacterStyle newStyle = new CharacterStyle(font, size, colorRGB);
    for (CharacterStyle style : styles) {
      if (style.equals(newStyle)) {
        return style;
      }
    }
    styles.add(newStyle);
    return newStyle;
  }
}

public class Character {
  private char c;
  private CharacterStyle style;

  public Character(char c, CharacterStyle style) {
    this.c = c;
    this.style = style;
  }
}

public class Editor {
  private List<Character> chars = new ArrayList<>();

  public void appendCharacter(char c, Font font, int size, int colorRGB) {
    Character character = new Character(c, CharacterStyleFactory.getStyle(font, size, colorRGB));
    chars.add(character);
  }
}

~~~



### 享元模式vs单例、缓存、对象池

- **跟多例的区别**：应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。
- **跟缓存的区别**：缓存，主要是为了提高访问效率，而非复用。
- **跟资源池的区别**：池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间。

### 在Java Integer、String中的应用

我们看看下面代码会输出什么

~~~Java
Integer i1 = 56;
Integer i2 = 56;
Integer i3 = 129;
Integer i4 = 129;
System.out.println(i1 == i2);			//true
System.out.println(i3 == i4);			//false
~~~

这是为什么呢？答案就在valueOf方法中

~~~java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
~~~

而IntegerCache的代码如下：

~~~java
/**
 * Cache to support the object identity semantics of autoboxing for values between
 * -128 and 127 (inclusive) as required by JLS.
 *
 * The cache is initialized on first usage.  The size of the cache
 * may be controlled by the {@code -XX:AutoBoxCacheMax=<size>} option.
 * During VM initialization, java.lang.Integer.IntegerCache.high property
 * may be set and saved in the private system properties in the
 * sun.misc.VM class.
 */
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];

    static {
        // high value may be configured by property
        int h = 127;
        String integerCacheHighPropValue =
            sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
        if (integerCacheHighPropValue != null) {
            try {
                int i = parseInt(integerCacheHighPropValue);
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
            } catch( NumberFormatException nfe) {
                // If the property cannot be parsed into an int, ignore it.
            }
        }
        high = h;

        cache = new Integer[(high - low) + 1];
        int j = low;
        for(int k = 0; k < cache.length; k++)
            cache[k] = new Integer(j++);

        // range [-128, 127] must be interned (JLS7 5.1.7)
        assert IntegerCache.high >= 127;
    }

    private IntegerCache() {}
}

~~~

看得出来，IntegerCache相当于生成享元对象的工厂类。

可以通过JVM参数来设置这个缓存的范围：

~~~java
//方法一：
-Djava.lang.Integer.IntegerCache.high=255
    
//方法二：
-XX:AutoBoxCacheMax=255
~~~

其他包装器类型比如Long、Short、Byte等，也都利用了享元模式来缓存-128到127之间的数据。

注意，下面第一种创建方式并不会使用到IntegerCache，而后面两种创建方法可以利用IntegerCache缓存，

~~~java
Integer a = new Integer(123);
Integer a = 123;
Integer a = Integer.valueOf(123);
~~~

### 

我们再来看看下面代码会输出什么

~~~java
String s1 = "小争哥";
String s2 = "小争哥";
String s3 = new String("小争哥");

System.out.println(s1 == s2);			//true
System.out.println(s1 == s3);			//false
~~~

![](assets/2dfc18575c22efccca191c566b24a22d.jpg)

String类的享元模式的设计，跟Integer类稍微有些不同。它并非在编译期时创建好需要共享的对象，而是在程序的运行期间，根据需要来创建和缓存字符串常量。
