# 面向对象

[TOC]



## 理论

我们不要过于学院派，非得给以下术语下个死定义，这样在工程上做毫无意义。

- **面向对象编程（Object Oriented Programming）**：面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。

- **面向对象编程语言（Object Oriented Programming Language）**：面向对象编程语言利用其语法机制，实现理论中的类、对象、封装、继承、多态。

  > **如何判定一个编程语言是否是面向对象编程语言？**：如果按照严格的的定义，需要有现成的语法支持类、对象、四大特性才能叫作面向对象编程语言。如果放宽要求的话，只要某种编程语言支持类、对象语法机制，那基本上就可以说这种编程语言是面向对象编程语言了，不一定非得要求具有所有的四大特性（例如，Javascript）。

- **面向对象分析（Object Oriented Analysis）**：指通过对问题控件进行抽象，建立对象模型。它解决要做什么的问题（What）

- **面向对象设计（Object Oriented Design）**：在面向对象分析的基础上进一步细化和完善对象模型。它解决要怎么做的问题（How）

分析和设计两个阶段最终的产出是类的设计，包括有哪些类，每个类有哪些属性方法，类与类之间的关系以及如何进行交互等等。

在分析设计阶段，经常使用**UML（Unified Model Language）**，统一建模语言，来画图表达面向对象的设计思路。在本笔记中，为了兼顾学习成本，并没有完全遵守UML的规范标准。

面向对象编程的一个核心思想是：**用数据成员处理状态的变化，用多态处理行为的变化**。



### 封装（Encapsulation）

**封装**也叫作**信息隐藏**或者**数据访问保护**。类通过暴露访问接口，授权外部仅能通过类提供的方式来访问内部属性。对于封装这个特性，编程语言本身提供一定的语法机制来支持。这个语法机制就是**访问权限控制。**

如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性。虽然这样更加灵活，但从另一方面来说，这种灵活性也意味着不可控。属性可以随意被以各种预料外的方式修改，可能违反一些不变式。并且修改逻辑散落在代码各处，势必影响代码的可维护性。

此外，如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对细节有足够的了解，这无疑增加了调用者的心智负担。因此，封装可以将调用者的关注点放在公有方法上，而不是在那些私有方法、属性上。最后，封装将实现与接口解耦。

总而言之，封装具有以下两个作用：

- 隔离关注点
- 隔离稳定的接口和易变的实现。



### 抽象（Abstraction）

> 有些人并不认为抽象属于面向对象的特性之一

事实上，抽象这一概念在计算机学科中，甚至整个人类生产活动中都被广泛使用。抽象的意思是从一个事物中提取出其共同的特征和特性，忽略其具体的细节。它是人类处理复杂性的有效手段。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的细节，关注系统的核心特征。

在编程中，函数、抽象类、接口都是抽象思维的具体体现。例如：

~~~java
public interface IPictureStorage {
  void savePicture(Picture picture);
  Image getPicture(String pictureId);
  void deletePicture(String pictureId);
  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
}

public class PictureStorage implements IPictureStorage {
  // ...省略其他属性...
  @Override
  public void savePicture(Picture picture) { ... }
  @Override
  public Image getPicture(String pictureId) { ... }
  @Override
  public void deletePicture(String pictureId) { ... }
  @Override
  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
}
~~~

调用者在使用图片存储功能的时候，只需要了解IPictureStorage这个接口类暴露了哪些方法就可以了，不需要去查看PictureStorage类里的具体实现逻辑。

### 继承（Inheritance）

继承是用来表示类之间的`is-a`关系。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如Java使用extends关键字来实现继承，C++使用冒号（class B : public A），Python使用parentheses ()。但是Java只支持单继承，即一个子类只允许继承一个父类。而C++、Python支持多继承，即一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。

继承最大的一个好处就是代码复用。此外，继承可以很自然地表达`is-a`的关系，符合人的普遍认知。

### 多态（Polymorphism）

封装将实现与接口解耦。而多态（也称动态绑定、后期绑定或运行时绑定）实现类型之间的解耦，即让一段代码同等地适用于所有这些不同的类型，同时在行为上又有所不同（**差异化**）。这改善了代码的组织结构和可读性，并且还能创建**可扩展**的程序。多态是“将变化的事物与不变的事物分离”的一项重要技术。因此大部分面向对象的设计模式依赖于多态机制！

多态这种特性也需要编程语言提供特殊的语法机制来实现，其中一种实现方法为“继承加方法重写”，它要求编程语言：

- 支持父类对象可以引用子类对象（对于静态语言来说）
- 支持继承
- 支持子类可以重写（override）父类中的方法



对于多态特性的实现方式，除了利用“继承加方法重写”这种实现方式之外，我们还有其他两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用duck-typing语法。

我们先来看如何利用接口类来实现多态特性：

~~~java
public interface Iterator {
  boolean hasNext();
  String next();
  String remove();
}

public class Array implements Iterator {
  private String[] data;
  
  public boolean hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法...
}

public class LinkedList implements Iterator {
  private LinkedListNode head;
  
  public boolean hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法... 
}
~~~

我们再来看下，如何用duck-typing来实现多态特性：

~~~python
class Logger:
    def record(self):
        print(“I write a log into file.”)
        
class DB:
    def record(self):
        print(“I insert data into db. ”)
        
def test(recorder):
    recorder.record()

def demo():
    logger = Logger()
    db = DB()
    test(logger)
    test(db)
~~~

`duck-typing`实现多态的方式非常灵活。Logger和DB两个类没有任何关系，既不是继承关系，也不是接口和实现的关系，但是只要它们都有定义了record()方法，就可以被传递到test()方法中，在实际运行的时候，执行对应的record()方法。也就是说，**只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系**。它是一些动态语言所特有的语法机制

### 面向对象与面向过程的比较

- 面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。
- 面向过程编程也是一种编程范式或编程风格。它以过程（函数）作为组织代码的基本单元。其主要的特点就是数据与方法相分离。

面向对象与面向过程的对比如下：

- 但对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线。如果把整个程序的处理流程画出来的话，会是一个网状结构。如果我们再用面向过程编程这种流程化、线性的思维方式（这是我们最熟悉的思考流程），去翻译这个网状结构，就会比较吃力。这个时候，面向对象的编程风格的优势就比较明显了。在进行面向对象编程的时候，先去思考如何给业务建模，将需求翻译为类，然后按照流程给类之间建立交互关系，便自然而然地翻译出网状结构了。

  汇编语言、面向过程编程语言的思维方式是偏硬件底层的。即如何设计一组指令，告诉机器去执行这组指令，操作某些数据，帮我们完成某个任务。而面向对象编程的思维方式是如何将真实的世界映射为类或者对象。这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。

- 除此之外，像C语言这种面向过程的编程语言，可以按照功能的不同，把函数和数据结构放到不同的文件里，从而实现模块化。但面向对象编程还提供了一种**更加清晰的**代码组织方式来实现模块化——类。

- 面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。例如，如果两个类有一些相同的属性和方法，我们就可以将这些相同的代码，抽取到父类中，让两个子类继承父类。这样两个子类也就可以重用父类中的代码，避免了代码重复写多遍，提高了代码的复用性。

  > 实际上，利用面向过程的编程语言（例如C语言）也可以实现多态、继承等特性，写出面向对象风格的代码，只不过要付出的代价异常地高。



看起来，面向对象比面向过程更”高级“，但是在与硬件打交道时，还是面向过程更具有优势。而且对于以算法为主、数据为辅的任务，用面向过程开发更合适。仔细想想，类中每个方法的实现逻辑，不正是面向过程风格的代码吗？

每种编程范式都有着自己擅长处理的问题领域。脱离实际问题背景去比较哪种编程范式更好，是毫无意义的。

### 伪面向对象代码

为什么我们容易写出面向过程风格的代码？因为当你去完成一个任务时，一般都会思考应该先做什么、后做什么。面向过程编程风格又恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。这所要考虑的东西要比面向过程多得多，而很多工程师在开发的过程，更倾向于用不太需要动脑子的方式去实现需求，也就不由自主地就将代码写成面向过程风格的了。

#### 滥用getter、setter方法

有些程序员在定义类时，会给每个属性定义相应的getter、setter方法。实际上，这样的做法是非常不推荐的，它违反了面向对象编程的封装特性。下面通过一个例子来说明：

~~~java
// 简化后的购物车类
public class ShoppingCart {
  private int itemsCount;
  private double totalPrice;
  private List<ShoppingCartItem> items = new ArrayList<>();
  
  public int getItemsCount() {
    return this.itemsCount;
  }
  
  public void setItemsCount(int itemsCount) {
    this.itemsCount = itemsCount;
  }
  
  public double getTotalPrice() {
    return this.totalPrice;
  }
  
  public void setTotalPrice(double totalPrice) {
    this.totalPrice = totalPrice;
  }

  public List<ShoppingCartItem> getItems() {
    return this.items;
  }
  
  public void addItem(ShoppingCartItem item) {
    items.add(item);
    itemsCount++;
    totalPrice += item.getPrice();
  }
  // ...省略其他方法...
}
~~~

我们为itemsCount和totalPrice这两个属性定义了getter、setter方法，这跟将这两个属性定义为public公有属性，没有什么两样了。外部可以通过setter方法随意地修改这两个属性的值，这可能会造成itemsCount和items.size()不相等，从而违反了不变式。

造成这个问题的根本原因是**setter的语义太宽泛**，解决方案很简单，**setter方法要结合具体语境来命名**

~~~java
public Item {
    double price;
    
    private void setPrice(double price) { this.price = price; }

    public void decreasePrice(double price) {
        setPrice(price);
    }
    
    public void increasePrice(double price) {
        setPrice(price);
    }
}
~~~

从功能上来说，上述代码是冗余的。但是从可维护性上来说，上述代码就做得很好。



此外，items这个属性也是有问题的。我们为items属性提供了getter方法，返回的是一个List集合容器。外部调用者在拿到这个容器之后，是可以操作容器内部数据的。也就是说，外部代码还是能修改items中的数据。比如像下面这样：

~~~java
ShoppingCart cart = new ShoppCart();
...
cart.getItems().clear(); // 清空购物车
~~~

但是这样的代码写法，会导致itemsCount、totalPrice、items三者数据不一致。我们不应该将清空购物车的业务逻辑暴露给上层代码。正确的做法应该是，在ShoppingCart类中定义一个clear()方法，将清空购物车的业务逻辑封装在里面，透明地给调用者使用。ShoppingCart类的clear()方法的具体代码实现如下：

~~~java
public class ShoppingCart {
  // ...省略其他代码...
  public void clear() {
    items.clear();
    itemsCount = 0;
    totalPrice = 0.0;
  }
}
~~~

但是，如果需要查看购物车中都购买了什么，那么这个时候就不得不给items提供getter方法。我们可以通过Java提供的Collections.unmodifiableList()方法，让getter方法返回一个不可被修改的UnmodifiableList集合容器。

~~~java
public class ShoppingCart {
    
  // ...省略其他代码...
  public List<ShoppingCartItem> getItems() {
    return Collections.unmodifiableList(this.items);
  }
}

//Collections.unmodifiableList的返回类型UnmodifiableList<E>
public class UnmodifiableList<E> extends UnmodifiableCollection<E>
                          implements List<E> {
  public boolean add(E e) {
    throw new UnsupportedOperationException();
  }
  public void clear() {
    throw new UnsupportedOperationException();
  }
  // ...省略其他代码...
}

ShoppingCart cart = new ShoppingCart();
List<ShoppingCartItem> items = cart.getItems();
items.clear();//抛出UnsupportedOperationException异常
~~~

不过，这样的实现思路还是有点问题。因为当调用者通过ShoppingCart的getItems()获取到items之后，虽然我们没法修改容器中的数据，但我们仍然可以修改容器中每个对象（ShoppingCartItem）的数据：

~~~java
ShoppingCart cart = new ShoppingCart();
cart.add(new ShoppingCartItem(...));
List<ShoppingCartItem> items = cart.getItems();
ShoppingCartItem item = items.get(0);
item.setPrice(19.0); // 这里修改了item的价格属性
~~~

这个问题我们先留着。在这里稍微总结一下：在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义setter方法。除此之外，尽管getter方法相对setter方法要安全些，但是如果返回的是集合容器（比如例子中的List容器），也要防范集合内部数据被修改的危险。

#### 滥用全局变量和全局方法

在面向对象编程中，**静态变量与静态方法具有着全局语义**。其中静态方法将方法与数据分离，破坏了封装特性，但是在特定语境下，可以放心使用静态方法。下面我们介绍一下基于Static语义而设计的Constants类与Utils类，以及讲解如何正确地定义它们。

一般，Constants类以静态字段来保存一些配置参数：

~~~java
public class Constants {
  public static final String MYSQL_ADDR_KEY = "mysql_addr";
  public static final String MYSQL_DB_NAME_KEY = "db_name";
  public static final String MYSQL_USERNAME_KEY = "mysql_username";
  public static final String MYSQL_PASSWORD_KEY = "mysql_password";
  
  public static final String REDIS_DEFAULT_ADDR = "192.168.7.2:7234";
  public static final int REDIS_DEFAULT_MAX_TOTAL = 50;
  public static final int REDIS_DEFAULT_MAX_IDLE = 50;
  public static final int REDIS_DEFAULT_MIN_IDLE = 20;
  public static final String REDIS_DEFAULT_KEY_PREFIX = "rt:";
  
  // ...省略更多的常量定义...
}
~~~

这样设计有着以下缺陷：

- 可维护性：随着项目开发，这个Constants类就会变得越来越大，成百上千行都有可能，查找修改某个常量也会变得比较费时。
- 复用性：如果我们要在另一个项目中，复用本项目开发的某个类，而这个类又依赖Constants类。即便这个类只依赖Constants类中的一小部分常量，我们仍然需要把整个Constants类也一并引入，也就引入了很多无关的常量到新的项目中。



有两种方案可以改进Constants类的设计：

- 细化，将Constants类拆解为功能更加单一的多个类，比如跟MySQL配置相关的常量，我们放到MysqlConstants类中；跟Redis配置相关的常量，我们放到RedisConstants类中
- 按需定义，若哪个类用到了某个常量，我们就把这个常量定义到这个类中。



Utils类的出现是基于这样一个问题背景：如果我们有两个类A和B，它们要用到一块相同的功能逻辑，为了避免代码重复，我们不应该在两个类中，将这个相同的功能逻辑，重复地实现两遍。这个时候我们该怎么办呢？我们首先想到可以使用继承来解决代码复用问题，但是从业务含义上，A类和B类并不一定具有继承关系，比如Crawler类和PageAnalyzer类，它们都用到了URL拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。既然继承不能解决这个问题，我们可以定义一个新的类，实现URL拼接和分割的方法。而拼接和分割两个方法，不需要共享任何数据，所以新的类不需要定义任何属性，这个时候，我们就可以把它定义为只包含静态方法的Utils类了。除此之外，就不要使用静态方法了。

我们设计Utils类的时候，最好也能细化一下，针对不同的功能，设计不同的Utils类，比如FileUtils、IOUtils、StringUtils、UrlUtils等，不要设计一个过于大而全的Utils类。

#### 定义数据和方法分离的类

传统的MVC结构分为Model层、Controller层、View层这三层。不过，在做前后端分离之后，三层结构在后端开发中，会稍微有些调整，被分为Controller层、Service层、Repository层。Controller层负责暴露接口给前端调用，Service层负责核心业务逻辑，Repository层负责数据读写。而在每一层中，我们又会分别定义VO（View Object）、BO（Business Object）、Entity。一般情况下，VO、BO、Entity中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的Controller类、Service类、Repository类中。数据定义在一个类中，方法定义在另一个类中，这是典型的面向过程编程。既然这种开发模式明显违背面向对象的编程风格，为什么大部分Web项目都是基于这种开发模式来开发呢？这个问题先留着，等之后的实战篇再讲解。

### 抽象类 or 接口？

抽象类与接口在语法特性上的差别就不再阐述，下面我们从设计角度比较它俩的区别：**接口和抽象类都提供了一种更加结构化的方式，来分离接口与实现。**接口实现了类型的完全解耦！而多态只实现了在继承层次上的类型解耦。由于抽象类反映子类共有的特性，所以抽象类仍然表示`is-a`的关系，但是接口表示`has-a`的关系。

事实上，可以通过具体类来模拟抽象类的语法特性。Java仍提供抽象类语法，是为了强制性地让程序员遵循某些规则，以降低出错的可能性。下面通过一个例子来说明：

~~~java
// 抽象类
public abstract class Logger {
  private String name;
  private boolean enabled;
  private Level minPermittedLevel;

  public Logger(String name, boolean enabled, Level minPermittedLevel) {
    this.name = name;
    this.enabled = enabled;
    this.minPermittedLevel = minPermittedLevel;
  }
  
  public void log(Level level, String message) {
    boolean loggable = enabled && (minPermittedLevel.intValue() <= level.intValue());
    if (!loggable) return;
    doLog(level, message);
  }
  
  protected abstract void doLog(Level level, String message);
}


// 抽象类的子类：输出日志到文件
public class FileLogger extends Logger {
  private Writer fileWriter;

  public FileLogger(String name, boolean enabled,
    Level minPermittedLevel, String filepath) {
    super(name, enabled, minPermittedLevel);
    this.fileWriter = new FileWriter(filepath); 
  }
  
  @Override
  public void doLog(Level level, String mesage) {
    // 格式化level和message,输出到日志文件
    fileWriter.write(...);
  }
}


// 抽象类的子类: 输出日志到消息中间件(比如kafka)
public class MessageQueueLogger extends Logger {
  private MessageQueueClient msgQueueClient;
  
  public MessageQueueLogger(String name, boolean enabled,
    Level minPermittedLevel, MessageQueueClient msgQueueClient) {
    super(name, enabled, minPermittedLevel);
    this.msgQueueClient = msgQueueClient;
  }
  
  @Override
  protected void doLog(Level level, String mesage) {
    // 格式化level和message,输出到消息中间件
    msgQueueClient.send(...);
  }
}
~~~

我们可以用下述代码代替抽象类语法：

~~~java
// 父类：非抽象类，就是普通的类. 删除了doLog()，新增了isLoggable().
public class Logger {
  private String name;
  private boolean enabled;
  private Level minPermittedLevel;

  public Logger(String name, boolean enabled, Level minPermittedLevel) {
    //...构造函数不变，代码省略...
  }

  protected boolean isLoggable() {
    boolean loggable = enabled && (minPermittedLevel.intValue() <= level.intValue());
    return loggable;
  }
  /** 
  如果不提供该方法，执行
  
  Logger logger = new FileLogger("access-log", true, Level.WARN, "/users/wangzheng/access.log");
  logger.log(Level.ERROR, "This is a test log message.");
  
  就会出现编译错误，毕竟Logger中并没有定义log()方法。所以这里我们要提供一个空方法，让子类重载它即可
  */
  public void log(Level level, String mesage) { // do nothing... }
}


// 子类：输出日志到文件
public class FileLogger extends Logger {
  private Writer fileWriter;

  public FileLogger(String name, boolean enabled,
    Level minPermittedLevel, String filepath) {
    //...构造函数不变，代码省略...
  }
  
  public void log(Level level, String mesage) {
    if (!isLoggable()) return;
    // 格式化level和message,输出到日志文件
    fileWriter.write(...);
  }
}

// 子类: 输出日志到消息中间件(比如kafka)
public class MessageQueueLogger extends Logger {
  private MessageQueueClient msgQueueClient;
  
  public MessageQueueLogger(String name, boolean enabled,
    Level minPermittedLevel, MessageQueueClient msgQueueClient) {
    //...构造函数不变，代码省略...
  }
  
  public void log(Level level, String mesage) {
    if (!isLoggable()) return;
    // 格式化level和message,输出到消息中间件
    msgQueueClient.send(...);
  }
}
~~~

这个设计思路能用，但是，它显然没有之前通过抽象类的实现思路优雅。而且当创建一个新的子类继承Logger父类的时候，我们有可能会忘记重新实现log()方法。之前基于抽象类的设计思路，编译器会强制要求子类重写log()方法，否则会报编译错误。并且Logger可以被实例化，换句话说，我们可以new一个Logger出来，并且调用空的log()方法。这也增加了类被误用的风险。

### 基于接口而非实现编程

基于接口而非实现编程（“Program to an interface, not an implementation”）这条原则并不是与Java的Interface接口挂钩的，它最早出现于1994年GoF的《设计模式》这本书，是一条比较抽象、泛化的设计思想。应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。函数、抽象类、接口都是这种思想的体现。



那么我们是否需要为每个类定义接口？我们要回到接口的设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，直接使用实现类就可以了。

### 继承 or 组合？

在面向对象编程中，有一条非常经典的设计原则，那就是：**组合优于继承**

继承是面向对象的四大特性之一，可以解决代码复用的问题。但继承层次过深、过复杂，也会影响到代码的可维护性，下面通过一个例子来体会一下：

假设我们要设计一个关于鸟的类。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类AbstractBird。如果我们要在AbstractBird中添加fly()方法，那么就要考虑是否所有的鸟都会飞？ 答案是否定的（可爱的企鹅🥰就不会），我们可以在子类的fly()中抛出异常来表示该鸟不会飞。

~~~java
public class AbstractBird {
  //...省略其他属性和方法...
  public void fly() { //... }
}

    
public class Ostrich extends AbstractBird { //鸵鸟
  //...省略其他属性和方法...
  public void fly() {
    throw new UnSupportedMethodException("I can't fly.'");
  }
}
~~~

这种方案有两个问题：

- 徒增了编码的工作量，我们必须给每个不会飞的鸟类，添加这个重载抛出异常的方法。
- 也违背了最小知识原则（Least Knowledge Principle），即暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。

我们还可以通过AbstractBird类派生出两个更加细分的抽象类：会飞的鸟类AbstractFlyableBird和不会飞的鸟类AbstractUnFlyableBird

![](assets/1e27919f63ef615dba98bc00673914b7.jpg)

但是我们还要说明该鸟是否会叫，继续沿用刚才的设计思路，那就需要再定义四个抽象类：

![](assets/3f99fa541e7ec7656a1dd35cc4f28bc6.jpg)

如果我们还需要考虑“是否会下蛋”这样一个行为，那估计就要组合爆炸了。

继承关系会越复杂，层次越深，会导致代码的可读性变差，因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码…… 一直追溯到最顶层父类的代码。另一方面，子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的实现逻辑。

总而言之，继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么我们不推荐使用继承。

实际上，我们可以利用**组合（composition）**、**接口**、**委托（delegation）**三个技术替代掉继承，并且有效地避免由于继承过深而问题影响代码可维护性的问题。我们知道继承主要有三个作用：表示is-a关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。通过组合和接口的has-a关系来替代is-a关系；利用接口来实现多态特性；通过组合和委托来实现代码复用。

我们看看如何通过这三个技术来解决继承的问题：               

~~~java                           
public interface Flyable {
  void fly();
}

public interface Tweetable {
  void tweet();
}

public interface EggLayable {
  void layEgg();
}

public class Ostrich implements Tweetable, EggLayable {//鸵鸟
  //... 省略其他属性和方法...
  @Override
  public void tweet() { //... }
  @Override
  public void layEgg() { //... }
}
      
public class Sparrow impelents Flyable, Tweetable, EggLayable {//麻雀
  //... 省略其他属性和方法...
  @Override
  public void fly() { //... }
  @Override
  public void tweet() { //... }
  @Override
  public void layEgg() { //... }
}
~~~

不过，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍layEgg()方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？

我们可以针对三个接口再定义三个实现类，它们分别是：实现了fly()方法的FlyAbility类、实现了tweet()方法的TweetAbility类、实现了layEgg()方法的EggLayAbility类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：

~~~java
public interface Flyable {
  void fly()；
}

public class FlyAbility implements Flyable {
  @Override
  public void fly() { //... }
}
    
//省略Tweetable/TweetAbility/EggLayable/EggLayAbility
public class Ostrich implements Tweetable, EggLayable {//鸵鸟
  private TweetAbility tweetAbility = new TweetAbility(); //组合
  private EggLayAbility eggLayAbility = new EggLayAbility(); //组合
  //... 省略其他属性和方法...
  
  @Override
  public void tweet() {
    tweetAbility.tweet(); // 委托——将实现交给其他对象来处理
  }
    
  @Override
  public void layEgg() {
    eggLayAbility.layEgg(); // 委托
  }
}
~~~



从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口，这或多或少地增加代码的复杂程度和维护成本。

如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。相反，就尽量使用组合来替代继承。



利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A类和B类并不一定具有继承关系。比如，Crawler类和PageAnalyzer类，它们都用到了URL拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。**仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性**。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示：

~~~java
public class Url {
  //...省略属性和方法
}

public class Crawler {
  private Url url; // 组合
  public Crawler() {
    this.url = new Url();
  }
  //...
}

public class PageAnalyzer {
  private Url url; // 组合
  public PageAnalyzer() {
    this.url = new Url();
  }
  //..
}
~~~

如果我们无法对类进行修改（第三方代码），那么我们只能继承并重写该类了：

~~~java
public class FeignClient { // Feign Client框架代码，无法修改
  //...省略其他代码...
  public void encode(String url) { //... }
}

public class CustomizedFeignClient extends FeignClient {
  @Override
  public void encode(String url) { //...重写encode的实现...}
}
~~~





## 实战：业务开发常用的基于贫血模型的MVC架构违背OOP吗？

### 问题背景

基于贫血模型的MVC三层架构开发模式已经成为标准的Web项目的开发模式，但它却违反了面向对象编程风格，是一种彻彻底底的面向过程的编程风格，因此而被有些人称为[反模式（anti-pattern）](https://zh.wikipedia.org/wiki/%E5%8F%8D%E9%9D%A2%E6%A8%A1%E5%BC%8F)。特别是**领域驱动设计**（Domain Driven Design，简称DDD）盛行之后，这种基于贫血模型的传统的开发模式就更加被人诟病。而基于充血模型的DDD开发模式越来越被人提倡。

接下来，我们将结合一个虚拟钱包系统的开发案例，来彻底弄清楚这两种开发模式。

### 什么是基于贫血模型的传统开发模式？

MVC三层架构中的M表示Model，V表示View，C表示Controller。它将整个项目分为三层：展示层、逻辑层、数据层。现在很多Web或者App项目都是前后端分离的，后端负责暴露接口给前端调用。这种情况下，我们一般就将后端项目分为Repository层、Service层、Controller层。其中，Repository层负责数据访问，Service层负责业务逻辑，Controller层负责暴露接口。

举一个简单的例子来说明什么是贫血模型：

~~~dart
////////// Controller+VO(View Object) //////////
public class UserController {
  private UserService userService; //通过构造函数或者IOC框架注入一个Service层对象
  
  public UserVo getUserById(Long userId) {
    UserBo userBo = userService.getUserById(userId);
    UserVo userVo = [...convert userBo to userVo...];
    //向前端返回数据
    return userVo;
  }
}

public class UserVo {
  private Long id;
  private String name;
  private String cellphone;
}

////////// Service+BO(Business Object) //////////
public class UserService {
  private UserRepository userRepository; //通过构造函数或者IOC框架注入一个Repository层对象
  
  public UserBo getUserById(Long userId) {
    UserEntity userEntity = userRepository.getUserById(userId);
    UserBo userBo = [...convert userEntity to userBo...];
    return userBo;
  }
}

public class UserBo {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}

////////// Repository+Entity //////////
public class UserRepository {
  public UserEntity getUserById(Long userId) { //... }
}

public class UserEntity {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}

~~~

像UserBo、UserEntity、UserVo这样，只包含数据，不包含业务逻辑的类（POJO类），就叫作**贫血模型（Anemic Domain Model）**。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。

但是为什么基于贫血模型的MVC框架如此受欢迎。因为我们开发的系统业务都比较简单，就是基于SQL的CRUD操作，贫血模型就足够应付。充血模型的设计要比贫血模型更加有难度，因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在Service层定义什么操作，不需要事先做太多设计。

### 什么是基于充血模型的DDD开发模式

在贫血模型中，数据和业务逻辑被分割到不同的类中。**充血模型（Rich Domain Model）**正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。

领域驱动设计，即DDD，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。做好领域驱动设计的关键是，看你对自己所做业务的熟悉程度，而并不是对领域驱动设计这个概念本身的掌握程度。不过，DDD也并非银弹。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用。

微服务除了监控、调用链追踪、API网关等服务治理系统的开发之外，还有针对公司的业务，合理地做微服务拆分。而领域驱动设计恰好就是用来指导如何划分服务的。所以，微服务加速了领域驱动设计的盛行。

实际上，基于充血模型的DDD开发模式实现的代码，也是按照MVC三层架构分层的，它跟基于贫血模型的传统开发模式的区别主要在Service层。其中，它的Service层包含Service类和Domain类两部分。而Domain类似BO，但是它既包含数据，也包含业务逻辑。总结一下的话就是，基于贫血模型的传统的开发模式，重Service轻BO；基于充血模型的DDD开发模式，轻Service重Domain。

在代码层面上，就是一个将业务逻辑放到Service类中，一个将业务逻辑放到Domain领域模型中，这体现不出充血模型的优势。但是在开发流程上，两者的区别就体现出来了。我们平时的开发，大部分都是**SQL驱动（SQL-Driven）**的开发模式（例如，需要哪张表，如何编写SQL语句来获取数据），业务逻辑基本上包裹在一个大的SQL语句中，Service层做的事情很少。当需求变化后，只能重新写个满足新需求的SQL语句。复用性很差！如果我们在项目中，应用基于充血模型的DDD的开发模式，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型充当可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成，复用性好。越复杂的系统，对代码的复用性、易维护性要求就越高。所以，基于充血模型的DDD开发模式，更适合业务复杂的系统开发。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。

### 基于充血模型的DDD开发一个虚拟钱包系统

#### 需求分析

应用为每个用户开设一个系统内的虚拟钱包账户，支持用户充值、提现、支付、冻结、透支、转赠、查询账户余额、查询交易流水等操作。



![](assets/9e91377602ef154eaf866c7e9263a64a.jpg)

我们先来实现充值、提现、支付、查询余额、查询交易流水这五个核心的功能。

- 充值

  ![](assets/3915a6544403854d35678c81fe65f014.jpg)

- 支付

  ![](assets/7eb44e2f8661d1c3debde85f79fb2c5e.jpg)

- 提现

  ![](assets/66ede1de93d29b86a9194ea0f80d1e43.jpg)

- 查询余额：直接查询虚拟钱包中的余额数字即可

- 查询交易流水：我们只支持三种类型的交易流水：充值、支付、提现。在用户充值、支付、提现的时候，我们会记录相应的交易信息。在需要查询的时候，我们只需要将之前记录的交易流水，按照时间、类型等条件过滤之后，显示出来即可。交易流水的格式如下：

  ![](assets/38b56bd1981d8b40ececa4d638e4a968.jpg)



我们进行业务划分，给系统解耦，将整个钱包系统拆分为两个子系统：虚拟钱包系统和三方支付系统。

![](assets/60d3cfec73986b52e3a6ef4fe147e562.jpg)



#### 基于贫血模型的传统开发模式

~~~~java
//Controller层
public class VirtualWalletController {
  // 通过构造函数或者IOC框架注入
  private VirtualWalletService virtualWalletService;
  
  public BigDecimal getBalance(Long walletId) { ... } //查询余额
  public void debit(Long walletId, BigDecimal amount) { ... } //出账
  public void credit(Long walletId, BigDecimal amount) { ... } //入账
  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) { ...} //转账
  //省略查询transaction的接口
}



//Service层
public class VirtualWalletBo {//省略getter/setter/constructor方法
  private Long id;
  private Long createTime;
  private BigDecimal balance;
}

public Enum TransactionType {
  DEBIT,
  CREDIT,
  TRANSFER;
}

public class VirtualWalletService {
  // 通过构造函数或者IOC框架注入
  private VirtualWalletRepository walletRepo;
  private VirtualWalletTransactionRepository transactionRepo;
  
  public VirtualWalletBo getVirtualWallet(Long walletId) {
    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
    VirtualWalletBo walletBo = convert(walletEntity);
    return walletBo;
  }
  
  public BigDecimal getBalance(Long walletId) {
    return walletRepo.getBalance(walletId);
  }

  @Transactional
  public void debit(Long walletId, BigDecimal amount) {
    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
    BigDecimal balance = walletEntity.getBalance();
    if (balance.compareTo(amount) < 0) {
      throw new NoSufficientBalanceException(...);
    }
    VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
    transactionEntity.setAmount(amount);
    transactionEntity.setCreateTime(System.currentTimeMillis());
    transactionEntity.setType(TransactionType.DEBIT);
    transactionEntity.setFromWalletId(walletId);
    transactionRepo.saveTransaction(transactionEntity);
    walletRepo.updateBalance(walletId, balance.subtract(amount));
  }

  @Transactional
  public void credit(Long walletId, BigDecimal amount) {
    VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
    transactionEntity.setAmount(amount);
    transactionEntity.setCreateTime(System.currentTimeMillis());
    transactionEntity.setType(TransactionType.CREDIT);
    transactionEntity.setFromWalletId(walletId);
    transactionRepo.saveTransaction(transactionEntity);
    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
    BigDecimal balance = walletEntity.getBalance();
    walletRepo.updateBalance(walletId, balance.add(amount));
  }

  @Transactional
  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {
    VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
    transactionEntity.setAmount(amount);
    transactionEntity.setCreateTime(System.currentTimeMillis());
    transactionEntity.setType(TransactionType.TRANSFER);
    transactionEntity.setFromWalletId(fromWalletId);
    transactionEntity.setToWalletId(toWalletId);
    transactionRepo.saveTransaction(transactionEntity);
    debit(fromWalletId, amount);
    credit(toWalletId, amount);
  }
}
~~~~

#### 基于贫血模型的传统开发模式

基于充血模型的DDD开发模式，跟基于贫血模型的传统开发模式的主要区别就在Service层，Controller层和Repository层的代码基本上相同。

~~~java
public class VirtualWallet { // Domain领域模型(充血模型)
  private Long id;
  private Long createTime = System.currentTimeMillis();;
  private BigDecimal balance = BigDecimal.ZERO;
  
  public VirtualWallet(Long preAllocatedId) {
    this.id = preAllocatedId;
  }
  
  public BigDecimal balance() {
    return this.balance;
  }
  
  public void debit(BigDecimal amount) {
    if (this.balance.compareTo(amount) < 0) {
      throw new InsufficientBalanceException(...);
    }
    this.balance = this.balance.subtract(amount);
  }
  
  public void credit(BigDecimal amount) {
    if (amount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException(...);
    }
    this.balance = this.balance.add(amount);
  }
}

public class VirtualWalletService {
  // 通过构造函数或者IOC框架注入
  private VirtualWalletRepository walletRepo;
  private VirtualWalletTransactionRepository transactionRepo;
  
  public VirtualWallet getVirtualWallet(Long walletId) {
    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
    VirtualWallet wallet = convert(walletEntity);
    return wallet;
    //与贫血模型一样
  }
  
    
  public BigDecimal getBalance(Long walletId) {
    return walletRepo.getBalance(walletId);
  }
  
    
  @Transactional
  public void debit(Long walletId, BigDecimal amount) {
    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
    VirtualWallet wallet = convert(walletEntity);
    wallet.debit(amount);
    VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
    transactionEntity.setAmount(amount);
    transactionEntity.setCreateTime(System.currentTimeMillis());
    transactionEntity.setType(TransactionType.DEBIT);
    transactionEntity.setFromWalletId(walletId);
    transactionRepo.saveTransaction(transactionEntity);
    walletRepo.updateBalance(walletId, wallet.balance());
  }
  
  @Transactional
  public void credit(Long walletId, BigDecimal amount) {
    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
    VirtualWallet wallet = convert(walletEntity);
    wallet.credit(amount);
    VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
    transactionEntity.setAmount(amount);
    transactionEntity.setCreateTime(System.currentTimeMillis());
    transactionEntity.setType(TransactionType.CREDIT);
    transactionEntity.setFromWalletId(walletId);
    transactionRepo.saveTransaction(transactionEntity);
    walletRepo.updateBalance(walletId, wallet.balance());
  }

  @Transactional
  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {
    //...跟基于贫血模型的传统开发模式的代码一样...
  }
}
~~~

看上去仅仅是将业务逻辑转移从Service对象中到BO对象中，实则不然。如果我们要支持透支和冻结部分余额的功能。这个时候，我们重新来看一下VirtualWallet类的实现代码。

~~~java
public class VirtualWallet {
  private Long id;
  private Long createTime = System.currentTimeMillis();;
  private BigDecimal balance = BigDecimal.ZERO;
  private boolean isAllowedOverdraft = true;
  private BigDecimal overdraftAmount = BigDecimal.ZERO;
  private BigDecimal frozenAmount = BigDecimal.ZERO;
  
  public VirtualWallet(Long preAllocatedId) {
    this.id = preAllocatedId;
  }
  
  public void freeze(BigDecimal amount) { ... }
  public void unfreeze(BigDecimal amount) { ...}
  public void increaseOverdraftAmount(BigDecimal amount) { ... }
  public void decreaseOverdraftAmount(BigDecimal amount) { ... }
  public void closeOverdraft() { ... }
  public void openOverdraft() { ... }
  
  public BigDecimal balance() {
    return this.balance;
  }
  
  public BigDecimal getAvaliableBalance() {
    BigDecimal totalAvaliableBalance = this.balance.subtract(this.frozenAmount);
    if (isAllowedOverdraft) {
      totalAvaliableBalance += this.overdraftAmount;
    }
    return totalAvaliableBalance;
  }
  
  public void debit(BigDecimal amount) {
    BigDecimal totalAvaliableBalance = getAvaliableBalance();
    if (totoalAvaliableBalance.compareTo(amount) < 0) {
      throw new InsufficientBalanceException(...);
    }
    this.balance = this.balance.subtract(amount);
  }
  
  public void credit(BigDecimal amount) {
    if (amount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException(...);
    }
    this.balance = this.balance.add(amount);
  }
}
~~~

如果功能继续演进，我们可以增加更加细化的冻结策略、透支策略、支持钱包账号（VirtualWallet id字段）自动生成的逻辑（不是通过构造函数经外部传入ID，而是通过分布式ID生成算法来自动生成ID）等等。VirtualWallet类的业务逻辑会变得越来越复杂，也就很值得设计成充血模型了。



这里我们要问：为什么不去掉Service类呢？

- Service类负责与Repository交流。之所以让VirtualWalletService类与Repository打交道，而不是让领域模型VirtualWallet与Repository打交道，那是因为我们想**保持领域模型的独立性**，不与任何其他层的代码（Repository层的代码）或开发框架（比如Spring、MyBatis）耦合在一起，将流程性的代码逻辑（比如从DB中取数据、映射数据）与领域模型的业务逻辑解耦，让领域模型更加可复用。
- Service类负责跨领域模型的业务聚合功能。
- Service类负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的RPC接口等，都可以放到Service类中。



为什么不将Controller层和Repository层进行充血领域建模呢？

- 没有必要。因为Controller层与Repository层的业务逻辑简单，直接对其贫血建模即可。即使违反面向对象设计原则——数据与操作分离，也无所谓。因为，对象在其整个生命周期中是不可变的，即没有被修改的 。

  就拿Controller层的VO来说。它是一种DTO（Data Transfer Object，数据传输对象）。它主要是作为接口的数据传输承载体，将数据发送给其他系统。从功能上来讲，它理应不包含业务逻辑、只包含数据。所以，我们将它设计成贫血模型也是比较合理的。

## 实战：对接口鉴权做面向对象分析

针对框架、类库、组件等非业务系统的开发，其中一个比较大的难点就是，需求一般都比较抽象、模糊，需要你自己去挖掘，做合理取舍、权衡、假设，把抽象的问题具象化，最终产生清晰的、可落地的需求定义。需求分析的过程实际上是一个不断迭代优化的过程，先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。

### 需求

微服务通过HTTP协议暴露接口给其他系统调用。为了保证接口调用的安全性，设计实现一个接口调用鉴权功能，即只有经过认证之后的系统才能调用接口。

我们该如何做需求分析？先从最简单的方案想起，然后再优化，最后形成一个可执行、可落地的需求

#### 第一轮基础分析

通过用户名加密码来做认证。我们给每个允许访问我们服务的调用方，派发一个应用名（或者叫应用ID、AppID）和一个对应的密码（或者叫秘钥）。调用方每次进行接口请求的时候，都携带自己的AppID和密码。微服务在接收到接口调用请求之后，会解析出AppID和密码，跟存储在微服务端的AppID和密码进行比对。如果一致，说明认证成功，则允许接口调用请求；否则，就拒绝接口调用请求。

#### 第二轮分析优化

不过，这样的验证方式，每次都要明文传输密码，密码很容易被截获，是不安全的。那我们借助加密算法（比如SHA），对密码进行加密之后，再传递到微服务端验证。实际上，这样也是不安全的，因为加密之后的密码及AppID，照样可以被未认证系统（或者说黑客）截获，未认证系统可以携带这个加密之后的密码以及对应的AppID，伪装成已认证系统来访问我们的接口。这就是典型的“[重放攻击](https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB)”。

我们可以借助OAuth的验证思路来解决（仍然是有重放攻击的风险，实际上这个方案与上述加密方案本质上是一样的）。调用方将请求接口的URL跟AppID、密码拼接在一起，然后进行加密，生成一个token。调用方在进行接口请求的的时候，将这个token及AppID，随URL一块传递给微服务端。微服务端接收到这些数据之后，根据AppID从数据库中取出对应的密码，并通过同样的token生成算法，生成另外一个token。用这个新生成的token跟调用方传递过来的token对比。如果一致，则允许接口调用请求；

![](assets/0704c4806f9d6c01bb20884d05ee54d7.jpg)

#### 第三轮分析优化

不过，这样的设计仍然存在重放攻击的风险，还是不够安全。每个URL拼接上AppID、密码生成的token都是固定的。未认证系统截获URL、token和AppID之后，还是可以通过重放攻击的方式，伪装成认证系统，调用这个URL对应的接口。

为了解决这个问题，我们可以进一步优化token生成算法，引入时间戳，让每次接口请求生成的token都不一样。现在我们将URL、AppID、密码、时间戳四者进行加密来生成token。调用方在进行接口请求的时候，将token、AppID、时间戳，随URL一并传递给微服务端。

微服务端在收到这些数据之后，会验证当前时间戳跟传递过来的时间戳，是否在一定的时间窗口内（比如一分钟）。如果超过时间窗口，则判定token过期，拒绝接口请求。如果没有超过一分钟，则说明token没有过期，就再通过同样的token生成算法，在服务端生成新的token，与调用方传递过来的token比对，看是否一致。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。

![](assets/bde932c73c6636ad85380e4801dbfb60.jpg)

这样还是不够安全。未认证系统还是可以在这一分钟的token失效窗口内，通过截获请求、重放请求，来调用接口！不过，攻与防之间，本来就没有绝对的安全。我们能做的就是，尽量提高攻击的成本。这个方案虽然还有漏洞，但是实现起来足够简单，而且不会过度影响接口本身的性能（比如响应时间）。所以，权衡安全性、开发成本、对系统性能的影响，这个方案算是比较折中、比较合理的了。

此外，针对AppID和密码的存储，我们最好能灵活地支持各种不同的存储方式，比如ZooKeeper、本地配置文件、自研配置中心、MySQL、Redis等，为了避免与第三方系统有过度的耦合。

### 分析

设计环节主要包含以下几个部分：

*   划分职责进而识别出有哪些类；
*   定义类及其属性和方法；
*   定义类与类之间的交互关系；
*   将类组装起来并提供执行入口。



下面我们针对鉴权这个例子，来说明是如何进行分析的

如何去识别出有哪些类呢？

- 根据需求描述中的名词来划分类。
- 根据功能点来进行划分（推荐）。在遇到复杂的需求分析时，涉及的功能点可能会很多。此时，应该先将需求简单划分成几个独立的功能模块，然后再在模块内根据功能点来划分。

在划分中，我们可能遗漏掉某些类。但这也没关系，面向对象分析、设计、编程本来就是一个循环迭代的过程。



如果要根据功能点来划分，要注意的是，拆解出来的每个功能点要尽可能的小。每个功能点只负责做一件很小的事情（单一职责原则）：

1.  把URL、AppID、密码、时间戳拼接为一个字符串；
2.  对字符串通过加密算法加密生成token；
3.  将token、AppID、时间戳拼接到URL中，形成新的URL；
4.  解析URL，得到token、AppID、时间戳等信息；
5.  从存储中取出AppID和对应的密码；
6.  根据时间戳判断token是否过期失效；
7.  验证两个token是否匹配；

其中1、2、6、7都是跟token有关，负责token的生成、验证；3、4都是在处理URL，负责URL的拼接、解析；5是操作AppID和密码，负责从存储中读取AppID和密码。所以，我们可以粗略地得到三个核心的类：AuthToken、Url、CredentialStorage。



然后将功能点中的动词作为候选方法，名词作为侯选属性，然后筛选出所需的方法、属性：

![](assets/69c8954e0db1a4db99a6094ee359fc9b.jpg)

![](assets/1cc9b95e511bd49fbc23c00ac5c0fed6.jpg)

![](assets/3b6d2c0cadafa723e26cc032c29c8785.jpg)



类与类之间都有哪些交互关系呢？UML统一建模语言中定义了六种类之间的关系。它们分别是：

- **泛化**（Generalization）：可以简单理解为继承关系。

  ~~~java
  public class A { ... }
  public class B extends A { ... }
  ~~~

- **实现**（Realization）：一般是指接口和实现类之间的关系

  ~~~java
  public interface A {...}
  public class B implements A { ... }
  ~~~

- **聚合**（Aggregation）是一种包含关系，A类对象包含B类对象，但B类对象的生命周期可以不依赖A类对象的生命周期

  ~~~java
  public class A {
    private B b;
    public A(B b) {
      this.b = b;
    }
  }
  ~~~

- **组合**（Composition）也是一种包含关系。A类对象包含B类对象，B类对象的生命周期依赖A类对象的生命周期

  ~~~java
  public class A {
    private B b;
    public A() {
      this.b = new B();
    }
  }
  ~~~

- **关联**（Association）是一种非常弱的关系，包含聚合、组合两种关系。一般来说就是B类对象是A类的成员变量

- **依赖**（Dependency）是一种比关联关系更加弱的关系，包含关联关系。一般来说就是B类对象是A类对象的成员变量，或者A类的方法使用B类对象作为参数或者返回值、局部变量。

出于学习成本的考虑，我们用组合关系替代UML中组合、聚合、关联三个概念。



最后，我们要将将类组装起来并提供执行入口。接口鉴权并不是一个独立运行的系统，而是一个集成在系统上运行的组件。所以，我们封装所有的实现细节，设计了一个最顶层的ApiAuthenticator接口类，作为触发执行鉴权逻辑的入口：

![](assets/f408ac59caffde117716d11148d010ca.jpg)
