# 初步

如何配置虚拟机、无线/USB调试以及构建项目？请参见：



~~~kotlin
class MainActivity : ComponentActivity() {
   override fun onCreate(savedInstanceState: Bundle?) {
       super.onCreate(savedInstanceState)
       setContent {
           GreetingCardTheme {
               // A surface container that uses the 'background' color from the theme
               Surface(color = MaterialTheme.colors.background) {
                   Greeting("Android")
               }
           }
       }
   }
}

@Composable
fun Greeting(name: String) {
   Surface(color = Color.Magenta) {
       // Modifier 用于扩充或修饰可组合项。
       Text(text = "Hi, my name is $name!", modifier = Modifier.padding(24.dp))
   }
}

@Preview(showBackground = true)
@Composable
fun DefaultPreview() {
   GreetingCardTheme {
       Greeting("Meghan")
   }
}
~~~

`onCreate()` 函数是此应用的入口点。在 Kotlin 程序中，`main()` 函数是 Kotlin 编译器在代码中开始编译的特定位置；在 Android 应用中，则是由 `onCreate()` 函数来担任这个角色。通过`setContent()`来设置根组件。



`Jetpack Compose` 是用于构建 `Android` 界面的新款工具包。在 Compose 中，**可组合函数（@Composable）是界面的基本构建块**，用于表达界面元素。通过嵌套这些构建块，我们可以逐步搭建出复杂的用户界面。

~~~kotlin
@Composable
fun Greeting(name: String) {
   Text(text = "Hello $name!")
}
~~~

这是一种声明式UI语言，只需描述应用界面的外观，而不必关注界面的构建过程。



添加 `@Preview` 注解，使`@Composable`函数其成为预览函数，注意必须设置预览函数的参数或者为形参提供默认值。这样就无需构建整个应用，就能查看该组件的外观。`@Preview` 注解可以接收名为 `showBackground` 的参数。如果 `showBackground` 设置为 **true**，则会向应用预览添加背景。

~~~kotlin
@Preview(
    showBackground = true,
    showSystemUi = true,
    name = "My Preview"
)
@Composable
fun GreetingPreview() {
    HappyBirthdayTheme {
        Greeting("Android")
    }
}
~~~







Compose 中的 3 个基本标准布局元素是 [`Column`](https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=zh-cn#Column(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,kotlin.Function1))、[`Row`](https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=zh-cn#Row(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.ui.Alignment.Vertical,kotlin.Function1)) 和 [`Box`](https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=zh-cn#Box(androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Boolean,kotlin.Function1)) 可组合项

![Column 显示了垂直排列的三个元素，Row 显示了水平排列的三个元素](assets/51c199c8a23bd6a8.png)

[`Box`](https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=zh-cn#Box(androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Boolean,kotlin.Function1)) 布局是 Compose 中的标准布局元素之一。使用 `Box` 布局可将元素堆叠在一起。`Box` 布局还可用于配置它所包含的元素的特定对齐方式。

![4d191637aaecf374.png](assets/4d191637aaecf374.png)

## 使用图片

首先下载图片，然后在 Android Studio 中，依次点击 **View > Tool Windows > Resource Manager**，或点击 **Project** 窗口旁边的 **Resource Manager** 标签页。

![image-20231122220458995](assets/image-20231122220458995.png)



## 像素

因为不同的屏幕具有不同的像素密度，所以同样数量的像素在不同的设备上可能对应于不同的物理尺寸。

Android 应用中的界面元素使用两种不同的度量单位：

- 密度无关像素 (DP)
- 可缩放像素 (SP)



如果将某个视图定义为“100px”宽，那么它在左侧设备上看起来要大得多。因此，您必须改用“100dp”来确保它在两个屏幕上看起来大小相同。

![img](assets/densities-phone_2x.png)





dp 是一个虚拟像素单位，1 dp 约等于中密度屏幕（160dpi；“基准”密度）上的 1 像素。对于其他每个密度，Android 会将此值转换为相应的实际像素数。
$$
px = dp * (dpi / 160)
$$


在定义文本大小时，您应改用可缩放像素 (sp) 作为单位（但切勿将 sp 用于布局尺寸）。默认情况下，sp 单位与 dp 大小相同，但它会根据用户的首选文本大小来做调整。



假设在某一应用中，用户的手指至少移动 16 像素之后，系统才会识别出滚动或滑动手势。在基线屏幕上，用户必须移动 `16 pixels / 160 dpi`（等于一英寸的 1/10 或 2.5 毫米），系统才会识别该手势。而在配备高密度显示屏 (240dpi) 的设备上，用户的手指必须至少移动 `16 pixels / 240 dpi`，相当于 1 英寸的 1/15（1.7 毫米）。此距离短得多，因此用户会感觉应用在该设备上更灵敏。要解决此问题，必须在代码中以 `dp` 表示手势阈值，然后再转换为实际像素。例如：

~~~kotlin
// The gesture threshold expressed in dp
    private const val GESTURE_THRESHOLD_DP = 16.0f
    ...
    private var mGestureThreshold: Int = 0
    ...
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Get the screen's density scale
        val scale: Float = resources.displayMetrics.density
        // Convert the dps to pixels, based on density scale
        mGestureThreshold = (GESTURE_THRESHOLD_DP * scale + 0.5f).toInt()

        // Use mGestureThreshold as a distance in pixels...
    }
~~~

`DisplayMetrics.density` 字段根据当前像素密度指定将 `dp` 单位转换为像素时所必须使用的缩放系数。在中密度屏幕上，`DisplayMetrics.density` 等于 1.0；在高密度屏幕上，它等于 1.5；在超高密度屏幕上，等于 2.0；在低密度屏幕上，等于 0.75。



要在像素密度不同的设备上提供良好的图形质量，您应该以相应的分辨率在应用中提供每个位图的多个版本（针对每个密度级别提供一个版本）。否则，Android 系统必须缩放位图，使其在每个屏幕上占据相同的可见空间，从而导致缩放失真，如模糊。

![img](assets/devices-density_2x.png)

适用于不同像素密度的配置限定符：

| `ldpi`    | 适用于低密度 (ldpi) 屏幕 (~ 120dpi) 的资源。                 |
| --------- | ------------------------------------------------------------ |
| `mdpi`    | 适用于中密度 (mdpi) 屏幕 (~ 160dpi) 的资源（这是基准密度）。 |
| `hdpi`    | 适用于高密度 (hdpi) 屏幕 (~ 240dpi) 的资源。                 |
| `xhdpi`   | 适用于加高 (xhdpi) 密度屏幕 (~ 320dpi) 的资源。              |
| `xxhdpi`  | 适用于超超高密度 (xxhdpi) 屏幕 (~ 480dpi) 的资源。           |
| `xxxhdpi` | 适用于超超超高密度 (xxxhdpi) 屏幕 (~ 640dpi) 的资源。        |
| `nodpi`   | 适用于所有密度的资源。这些是与密度无关的资源。无论当前屏幕的密度是多少，系统都不会缩放以此限定符标记的资源。 |
| `tvdpi`   | 适用于密度介于 mdpi 和 hdpi 之间的屏幕（约 213dpi）的资源。这不属于“主要”密度组。它主要用于电视，而大多数应用都不需要它。对于大多数应用而言，提供 mdpi 和 hdpi 资源便已足够，系统将视情况对其进行缩放。如果您发现有必要提供 tvdpi 资源，应按一个系数来确定其大小，即 1.33*mdpi。例如，如果某张图片在 mdpi 屏幕上的大小为 100px x 100px，那么它在 tvdpi 屏幕上的大小应该为 133px x 133px。 |

要针对不同的密度创建备用可绘制位图资源，您应遵循六种主要密度（ldpi ~ xxxhdpi）之间的 **3:4:6:8:12:16 缩放比**。

然后，将生成的图片文件置于 `res/` 下的相应子目录中，系统将自动根据运行您的应用的设备的屏幕密度选取正确的文件：

~~~xml
  res/
      drawable-xxxhdpi/
        awesome-image.png
      drawable-xxhdpi/
        awesome-image.png
      drawable-xhdpi/
        awesome-image.png
      drawable-hdpi/
        awesome-image.png
      drawable-mdpi/
        awesome-image.png
~~~

之后，每当您引用 `@drawable/awesomeimage` 时，系统便会根据屏幕 dpi 选择相应的位图。如果您没有为某个密度提供特定于密度的资源，那么系统会选取下一个最佳匹配项并对其进行缩放以适合屏幕。

您应将所有应用图标都放在 `mipmap` 目录中，而不是放在 `drawable` 目录中。

~~~xml
  res/
      mipmap-xxxhdpi/
        launcher-icon.png
      mipmap-xxhdpi/
        launcher-icon.png
      mipmap-xhdpi/
        launcher-icon.png
      mipmap-hdpi/
        launcher-icon.png
      mipmap-mdpi/
        launcher-icon.png
    
~~~



除了创建多个特定于密度的图片版本之外，另一种方法是仅创建一个矢量图形。在借助矢量图形创建图片时，是在使用 XML 来定义路径和颜色。因此，矢量图形可以缩放到任何尺寸而不会出现缩放失真矢量图形通常以 SVG（可缩放矢量图形）文件的形式提供，但 Android 不支持此格式，因此您必须将 SVG 文件转换为 Android 的[矢量图](https://developer.android.com/guide/topics/graphics/vector-drawable-resources?hl=zh-cn)格式。您可以在 Android Studio 中使用 [Vector Asset Studio](https://developer.android.com/studio/write/vector-asset-studio?hl=zh-cn) 轻松地将 SVG 转换为矢量图，具体步骤如下：

1. 在 **Project** 窗口中，右键点击 **res** 目录，然后依次选择 **New > Vector Asset**。
2. 选择 **Local file (SVG, PSD)**。
3. 找到要导入的文件并进行任何调整。

可以对所有像素密度使用一个矢量图，所以此文件位于默认的 drawable 目录中（您不需要使用特定于密度的目录）：

~~~xml
res/
      drawable/
        ic_android_launcher.xml
~~~



如果您请求预缩放的资源的尺寸，系统将返回表示缩放后尺寸的值。例如，假设针对 mdpi 屏幕设计了一个 50x50 像素的位图，它在 hdpi 屏幕上会放大到 75x75 像素（如果没有针对 hdpi 的备用资源），那么系统会将尺寸报告为 75x75 像素。

不推荐关闭预缩放行为，这会导致预期外的结果



## 资源

资源是指代码使用的附加文件和静态内容，例如位图、布局定义、界面字符串、动画说明等。您应该始终将应用资源（如图片和字符串）与代码分隔开，以便能够独立地维护这些资源。

~~~xml
MyProject/
    src/
        MyActivity.kt
    res/
        drawable/
            graphic.png
        mipmap/
            icon.png
        values/
            strings.xml
~~~

项目 `res/` 目录中支持的资源目录：

| `animator/` | 用于定义[属性动画](https://developer.android.com/guide/topics/graphics/prop-animation?hl=zh-cn)的 XML 文件。 |
| ----------- | ------------------------------------------------------------ |
| `anim/`     | 用于定义[补间动画](https://developer.android.com/guide/topics/graphics/view-animation?hl=zh-cn#tween-animation)的 XML 文件。 |
| `color/`    | 用于定义颜色状态列表的 XML 文件                              |
| `drawable/` | 位图文件（PNG、`.9.png`、JPG 或 GIF）或编译为以下可绘制资源子类型的 XML 文件：位图文件九宫图（可调整大小的位图）状态列表形状动画可绘制对象其他可绘制对象 |
| `mipmap/`   | 适用于不同启动器图标密度的可绘制对象文件                     |
| `layout/`   | 用于定义界面布局的 XML 文件。                                |
| `menu/`     | 用于定义应用菜单（例如选项菜单、上下文菜单或子菜单）的 XML 文件。 |
| `raw/`      | 需以原始形式保存的任意文件。如要使用原始 `InputStream` 打开这些资源，请使用资源 ID（即 `R.raw.filename`）调用 `Resources.openRawResource()`。但是，如需访问原始文件名和文件层次结构，请考虑将资源保存在 `assets/` 目录（而非 `res/raw/`）下。`assets/` 中的文件没有资源 ID，因此您只能使用 `AssetManager` 读取这些文件。 |
| `values/`   | 包含字符串、整数和颜色等简单值的 XML 文件。                  |
| `xml/`      | 可在运行时通过调用 `Resources.getXML()` 读取的任意 XML 文件。各种 XML 配置文件（例如[搜索配置](https://developer.android.com/guide/topics/search/searchable-config?hl=zh-cn)）都必须保存在此处。 |
| `font/`     | 带有扩展名的字体文件（例如 TTF、OTF 或 TTC），或包含 `<font-family>` 元素的 XML 文件。 |



可以使用在项目的 `R` 类中生成的资源 ID 访问资源。在大多数情况下，资源 ID 与文件名相同。

例如，可以使用以下代码访问上面的文件层次结构中的图片：

~~~xml
R.drawable.graphic
~~~

