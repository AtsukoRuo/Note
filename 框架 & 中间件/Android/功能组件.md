# 功能组件

[TOC]

Android系统中提供了3种持久化方案

- 文件存储
- SharedPreferences存储
- 数据库存储



## 文件存储

它比较适合存储一些简单的文本数据或二进制数据。如果想要存储结构化数据，那么需要自解释的格式规范。

### 写入

`Context`类中提供了一个`openFileOutput()`方法，可以用于将数据存储到指定的文件。

~~~java
FileOutputStream openFileOutput(String name, int mode)
~~~

- `name`：文件的路径。相对路径为`/data/data/<package name>/files/`
- `mode`：指定文件的操作模式
  - `MODE_PRIVATE`：覆盖原文件中的内容
  - `MODE_APPEND`：在原文件的基础上追加内容

使用示例：

~~~kotlin
val output = openFileOutput("data", Context.MODE_PRIVATE)
val writer = BufferedWriter(OutputStreamWriter(output))
writer.use {
    it.write(inputText)
}
~~~

这里的`use`函数是Kotlin所提供的内置扩展函数，它会保证在Lambda表达式中的代码执行完后（包括异常情况），自动将外层的流关闭

### 读取

`Context`类中还提供了一个`openFileInput()`方法，用于从文件中读取数据。

~~~kotlin
FileInputStream openFileInput(String name)
~~~

相对路径为`/data/data/<package name>/files/`

使用示例：

~~~kotlin
val input = openFileInput("data")
val reader = BufferedReader(InputStreamReader(input))
reader.use {
    reader.forEachLine {
        content.append(it)
    }
}
~~~

`forEachLine`函数也是Kotlin提供的内置扩展函数，它会将读到的每行内容都传入到Lambda表达式中



## SharedPreferences存储

`SharedPreferences`是使用键值对的方式来存储数据的。在Android中，提供了以下两种方法来获取`SharedPreferences`对象：

- `Context`类中的`getSharedPreferences()`方法

  ~~~java
  SharedPreferences getSharedPreferences(String name, int mode)
  ~~~

  - `name`：指定SharedPreferences文件的名称，如果指定的文件不存在则会创建一个，SharedPreferences文件都是存放在`/data/data/<package name>/shared_prefs/`目录下的、
  - `mode`：目前只有默认的`MODE_PRIVATE`这一种模式可选

- `Activity`类中的`getPreferences()`方法

  ~~~java
  SharedPreferences getPreferences(int mode)
  ~~~

  这个方法时会自动将当前`Activity`的类名作为`SharedPreferences`的文件名

  

得到了`SharedPreferences`对象之后，就可以开始向SharedPreferences文件中存储数据了，分为以下三步：

- 调用`SharedPreferences`对象的`edit()`方法获取一个`SharedPreferences.Editor`对象。
-  向`SharedPreferences.Editor`对象中添加数据
-  调用`apply()`方法将数据提交

~~~kotlin
val editor = getSharedPreferences("data", Context.MODE_PRIVATE).edit()
editor.putString("name", "Tom")
editor.putInt("age", 28)
editor.putBoolean("married", false)
editor.apply()
~~~

读取数据更为简单：
~~~kotlin
val prefs = getSharedPreferences("data", Context.MODE_PRIVATE)
val name = prefs.getString("name", "")
val age = prefs.getInt("age", 0)
val married = prefs.getBoolean("married", false)
~~~



## SQLite数据库存储

Android系统内置了一个轻量级的关系型数据库：SQLite。

同时还为我们提供了`SQLiteOpenHelper`抽象类来创建或升级数据库：

~~~kotlin
class MyDatabaseHelper(val context: Context, name: String, version: Int) : SQLiteOpenHelper(context, name, null, version) {

    private val createBook = "create table Book (" +
            " id integer primary key autoincrement," +
            "author text," +
            "price real," +
            "pages integer," +
            "name text)"

    // 在数据库文件不存在时，会调用该回调方法，并自动创建一个数据库文件
    override fun onCreate(db: SQLiteDatabase) {
        db.execSQL(createBook)
    }

    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
    }

}
~~~

构建出`SQLiteOpenHelper`的实例之后，再调用它的`getReadableDatabase()`或`getWritableDatabase()`方法就能够获得数据库实例（一个`SQLiteDatabase`对象）了，数据库文件会存放在`/data/data/<package name>/databases/`目录下。

~~~kotlin
//这三个参数分别是 context对象、数据库文件名、版本号
val dbHelper = MyDatabaseHelper(this, "BookStore.db", 1)

dbHelper.writableDatabase 
// 语法糖，相当于dbHelper.getWritableDatabase()
~~~

下面介绍CURD操作：

- 插入语句

  ~~~kotlin
  val db = dbHelper.writableDatabase
  val values1 = ContentValues().apply {
      // 开始组装第一条数据
      put("name", "The Da Vinci Code")
      put("author", "Dan Brown")
      put("pages", 454)
      put("price", 16.96)
  }
  
  // 第一个参数是表名
  db.insert("Book", null, values1) // 插入第一条数据
  ~~~

- 更新语句

  ~~~kotlin
  val db = dbHelper.writableDatabase
  val values = ContentValues()
  values.put("price", 10.99)
  
  //这四个参数分别是，表名、值、where语句、一个数组对应where语句中的占位符
  db.update("Book", values, "name = ?", arrayOf("The Da Vinci Code"))
  ~~~

- 删除语句

  ~~~kotlin
  db.delete("Book", "pages > ?", arrayOf("500"))
  ~~~

- 查询语句

  | `query()`方法参数 | 对应SQL部分                 | 描述                            |
  | :---------------- | :-------------------------- | :------------------------------ |
  | `table`           | `from table_name`           | 指定查询的表名                  |
  | `columns`         | `select column1, column2`   | 指定查询的列名                  |
  | `selection`       | `where column = value`      | 指定`where`的约束条件           |
  | `selectionArgs`   | -                           | 为`where`中的占位符提供具体的值 |
  | `groupBy`         | `group by column`           | 指定需要`group by`的列          |
  | `having`          | `having column = value`     | 对`group by`后的结果进一步约束  |
  | `orderBy`         | `order by column1, column2` | 指定查询结果的排序方式          |

  使用示例：

  ~~~kotlin
  
  val db = dbHelper.writableDatabase
  // 查询Book表中所有的数据
  val cursor = db.query("Book", null, null, null, null, null, null)
  
  //通过游标来读取数据
  if (cursor.moveToFirst()) {
      do {
          // 遍历Cursor对象，取出数据并打印
          val name = cursor.getString(cursor.getColumnIndex("name"))
          val author = cursor.getString(cursor.getColumnIndex("author"))
          val pages = cursor.getInt(cursor.getColumnIndex("pages"))
          val price = cursor.getDouble(cursor.getColumnIndex("price"))
          Log.d("MainActivity", "book name is $name")
          Log.d("MainActivity", "book author is $author")
          Log.d("MainActivity", "book pages is $pages")
          Log.d("MainActivity", "book price is $price")
      } while (cursor.moveToNext())
  }
  cursor.close()
  ~~~

  

除了上述四个辅助方法，Android还给我们提供了一个通用方法来执行CURD操作

~~~kotlin
db.execSQL("update Book set price = ? where name = ?", arrayOf("10.99", "The Da Vinci Code"))

val cursor = db.rawQuery("select * from Book", null)
~~~

SQL还支持事务操作

~~~kotlin
val db = dbHelper.writableDatabase
db.beginTransaction() // 开启事务
try {
    if (true) {
        // 手动抛出一个异常，让事务失败
        throw NullPointerException()
    }
    val values = ContentValues().apply {
        put("name", "Game of Thrones")
        put("author", "George Martin")
        put("pages", 720)
        put("price", 20.85)
    }
    db.insert("Book", null, values)
    db.setTransactionSuccessful() // 事务已经执行成功
} catch (e: Exception) {
    e.printStackTrace()
} finally {
    db.endTransaction() // 结束事务
}
~~~

## 通知

每条通知都要属于一个对应的渠道，每个应用程序都可以自由地创建当前应用拥有哪些通知渠道，但是通知渠道的控制权是掌握在用户手中的。

发送通知的几个基本步骤

- 首先需要一个`NotificationManager`对通知进行管理，可以通过调用`Context`的`getSystemService()`方法获取。

  ~~~Kotlin
  val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
  ~~~

- 使用`NotificationChannel`类构建一个通知渠道，并调用`NotificationManager`的`createNotificationChannel()`方法完成创建。

  ~~~kotlin
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
      val channel = NotificationChannel(channelId, channelName, importance)
      manager.createNotificationChannel(channel)
  }
  ~~~

  其中，`NotificationChannel`构造函数的定义如下：

  ~~~kotlin
  NotificationChannel(String id, CharSequence name, int importance)
  ~~~

  - `id`，随便定义，只需保证全局唯一即可

  - `name`，以文本的形式向用户表达这个渠道的用途

  - `importance`，表示通知的重要程度，不同的等级会决定通知的不同行为。

    `IMPORTANCE_HIGH`、`IMPORTANCE_DEFAULT`、`IMPORTANCE_LOW`、`IMPORTANCE_MIN`

    注意：用户可以随时手动更改某个通知渠道的重要等级

- 使用一个`Builder`构造器来创建`Notification`对象

  ~~~kotlin
  val notification = NotificationCompat.Builder(context, channelId)
        .setContentTitle("This is content title")
        .setContentText("This is content text")
        .setSmallIcon(R.drawable.small_icon)
   	  .setLargeIcon(BitmapFactory
                      .decodeResource(
                          getResources(),
                          R.drawable.large_icon)
                     )
        .build()
  ~~~

  这里，通知的id需要和其所要绑定的通知渠道的id匹配

- 最后，调用`NotificationManager`的`notify()`方法来发送通知

  ~~~kotlin
  manager.notify(1, notification)
  ~~~

  第一个参数是`id`，要保证为每个通知指定的`id`都是不同的；第二个参数则是要发送的`Notification`对象

- 通知所需的权限：

  ~~~xml
  <uses-permission android:name="android.permission.READ_CONTACTS" />
  ~~~



如果想在点击通知时执行一些动作，那么就需要使用`PendingIntent`。它主要解决**间接跳转的需求**。例如，当发送携带`PendingIntent`通知时，并不会直接根据`Intent`的进行跳转，直到用户点击这个通知后，通知服务才调用`PendingIntent#send`来跳转到指定的`Activity`中。

`PendingIntent`是`Intent`的一种特殊类型，它可以在稍后的时间点触发`Intent`。通常，`PendingIntent`用于在特定条件下触发某个操作，例如在特定时间、特定位置或特定事件发生时触发。

实现逻辑如下：

- 先可以通过`getActivity()`方法、`getBroadcast()`方法，还是`getService()`方法静态方法获取`PendingIntent`的实例

  ~~~kotlin
  val intent = Intent(this, NotificationActivity::class.java)
  val pi = PendingIntent.getActivity(this, 0, intent, 0)
  ~~~

  其中，`getActivity`的定义如下：

  ~~~java
  PendingIntent getActivity(Context context, int requestCode, Intent intent, int flags)
  ~~~

  - `requestCode`，传入0即可
  - `flags`：用于指定`PendingIntent`的行为，可取的值有`FLAG_ONE_SHOT`、`FLAG_NO_CREATE`、`FLAG_CANCEL_CURRENT`和`FLAG_UPDATE_CURRENT`

- 再调用`setContentIntent`，完成`PendingIntent`的注册

  ~~~kotlin
  val notification = NotificationCompat.Builder(this, "normal")
  	.setContentIntent(pi)
      .build()
  
  manager.notify(1, notification)
  ~~~



如何取消通知呢？有两种办法

- ~~~kotlin
  val notification = NotificationCompat.Builder(this, "normal")
          ...
          .setAutoCancel(true)
          .build()
  ~~~

- ~~~kotlin
  // 跳转到指定的Activity后，取消该通知
  override fun onCreate(savedInstanceState: Bundle?) {
      super.onCreate(savedInstanceState)
      setContentView(R.layout.activity_notification)
      val manager = getSystemService(Context.NOTIFICATION_SERVICE) as
          NotificationManager
      manager.cancel(1)
  }
  ~~~



`setStyle()`支持通知的富文本格式，例如长文本：

~~~kotlin
val notification = NotificationCompat.Builder(this, "normal")
    ...
    .setStyle(NotificationCompat.BigTextStyle().bigText("Learn how to build
    notifications, send and sync  data, and use voice actions. Get the official
    Android IDE and developer tools to build apps for Android."))
   .build()
~~~

以及图片

~~~kotlin
val notification = NotificationCompat.Builder(this, "normal")
    ...
    .setStyle(NotificationCompat.BigPictureStyle().bigPicture(
        BitmapFactory.decodeResource(resources, R.drawable.big_image)))
    .build()
~~~



## 摄像头

Flutter

## 音频

在Android中，一般是使用`MediaPlayer`类实现来播放音频文件。

表9.1列出了`MediaPlayer`类中一些较为常用的控制方法。

**表9.1　`MediaPlayer`类中常用的控制方法**

| 方法名            | 功能描述                                            |
| :---------------- | :-------------------------------------------------- |
| `setDataSource()` | 设置要播放的音频文件的位置                          |
| `prepare()`       | 在开始播放之前调用，以完成准备工作                  |
| `start()`         | 开始或继续播放音频                                  |
| `pause()`         | 暂停播放音频                                        |
| `reset()`         | 将MediaPlayer对象重置到刚刚创建的状态               |
| `seekTo()`        | 从指定的位置开始播放音频                            |
| `stop()`          | 停止播放音频。调用后的MediaPlayer对象无法再播放音频 |
| `release()`       | 释放与MediaPlayer对象相关的资源                     |
| `isPlaying()`     | 判断当前MediaPlayer是否正在播放音频                 |
| `getDuration()`   | 获取载入的音频文件的时长                            |

示例：

~~~kotlin
class MainActivity : AppCompatActivity() {

    private val mediaPlayer = MediaPlayer()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        initMediaPlayer()
        play.setOnClickListener {
            if (!mediaPlayer.isPlaying) {
                mediaPlayer.start() // 开始播放
            }
        }
        pause.setOnClickListener {
            if (mediaPlayer.isPlaying) {
                mediaPlayer.pause() // 暂停播放
            }
        }
        stop.setOnClickListener {
            if (mediaPlayer.isPlaying) {
                mediaPlayer.reset() 
                initMediaPlayer()
            }
        }
    }

    private fun initMediaPlayer() {
        val assetManager = assets
        val fd = assetManager.openFd("music.mp3")
        mediaPlayer.setDataSource(fd.fileDescriptor, fd.startOffset, fd.length)
        mediaPlayer.prepare()
    }

    override fun onDestroy() {
        super.onDestroy()
        mediaPlayer.stop()
        mediaPlayer.release()
    }

}
~~~



## 视频

Flutter

## WebView

https://gist.github.com/TheMelody/6ec3fcba6d57f544465651acc480ff39

WebViewClient就是帮助WebView处理各种通知、请求事件的，具体来说包括：

- onLoadResource

- onPageStart

- onPageFinish

- onReceiveError

- onReceivedHttpAuthRequest

- ...


WebChromeClient主要辅助WebView处理Javascript的对话框、网站图标、网站title、加载进度等，例如如

- onCloseWindow(关闭WebView)
- onCreateWindow()
- onJsPrompt
- onJsConfirm
- onProgressChanged
- onReceivedIcon
- onReceivedTitle
- ....



在AndroidManifest.xml文件中，还需要声明网络权限：

~~~kotlin
<uses-permission android:name="android.permission.INTERNET" />
~~~



~~~kotlin
@Composable
fun CustomWebView(modifier: Modifier = Modifier,
    url:String,
    onBack: (webView:WebView?) -> Unit,
    onProgressChange: (progress:Int)->Unit = {},
    initSettings: (webSettings:WebSettings?) -> Unit = {},
    onReceivedError: (error: WebResourceError?) -> Unit = {}){
    val webViewChromeClient = object:WebChromeClient(){
        override fun onProgressChanged(view: WebView?, newProgress: Int) {
            //回调网页内容加载进度
            onProgressChange(newProgress)
            super.onProgressChanged(view, newProgress)
        }
    }
    
    val webViewClient = object: WebViewClient(){
        override fun onPageStarted(view: WebView?, url: String?, 
            favicon: Bitmap?) {
            super.onPageStarted(view, url, favicon)
            onProgressChange(-1)
        }
        override fun onPageFinished(view: WebView?, url: String?) {
            super.onPageFinished(view, url)
            onProgressChange(100)
        }
        override fun shouldOverrideUrlLoading(
            view: WebView?,
            request: WebResourceRequest?
        ): Boolean {
            if(null == request?.url) return false
            val showOverrideUrl = request.url.toString()
            try {
                if (!showOverrideUrl.startsWith("http://")
                    && !showOverrideUrl.startsWith("https://")) {
                    //处理非http和https开头的链接地址
                    Intent(Intent.ACTION_VIEW, Uri.parse(showOverrideUrl)).apply {
                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                        view?.context?.applicationContext?.startActivity(this)
                    }
                    return true
                }
            }catch (e:Exception){
                //没有安装和找到能打开(「xxxx://openlink.cc....」、「weixin://xxxxx」等)协议的应用
                return true
            }
            return super.shouldOverrideUrlLoading(view, request)
        }

        override fun onReceivedError(
            view: WebView?,
            request: WebResourceRequest?,
            error: WebResourceError?
        ) {
            super.onReceivedError(view, request, error)
            //自行处理....
            onReceivedError(error)
        }
    }
    var webView:WebView? = null
    val coroutineScope = rememberCoroutineScope()
    
    AndroidView(modifier = modifier,factory = { ctx ->
        WebView(ctx).apply {
            this.webViewClient = webViewClient
            this.webChromeClient = webViewChromeClient
            //回调webSettings供调用方设置webSettings的相关配置
            initSettings(this.settings)
            webView = this
            loadUrl(url)
        }
    })
    
    BackHandler {
        coroutineScope.launch {
            //自行控制点击了返回按键之后，关闭页面还是返回上一级网页
            onBack(webView)
        }
    }
}
~~~



~~~kotlin
var rememberWebViewProgress: Int by remember { mutableStateOf(-1) }
Box {
    CustomWebView(
        modifier = Modifier.fillMaxSize(),
        url = "https://www.baidu.com/",
        onProgressChange = { progress ->
            rememberWebViewProgress = progress
        },
        initSettings = { settings ->
            settings?.apply {
                //支持js交互
                javaScriptEnabled = true
                //将图片调整到适合webView的大小
                useWideViewPort = true
                //缩放至屏幕的大小
                loadWithOverviewMode = true
                //缩放操作
                setSupportZoom(true)
                builtInZoomControls = true
                displayZoomControls = true
                //是否支持通过JS打开新窗口
                javaScriptCanOpenWindowsAutomatically = true
                //不加载缓存内容
                cacheMode = WebSettings.LOAD_NO_CACHE
            }
        }, onBack = { webView ->
            if (webView?.canGoBack() == true) {
                webView.goBack()
            } else {
                finish()
            }
        }, onReceivedError = {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            }
        }
    )
    LinearProgressIndicator(
        progress = rememberWebViewProgress * 1.0F / 100F,
        modifier = Modifier
            .fillMaxWidth()
            .height(if (rememberWebViewProgress == 100) 0.dp else 5.dp),
        color = Color.Red
    )
}
~~~

## 网络

### 原生

~~~kotlin
val url = URL("https://www.baidu.com")

// 获取HttpURLConnection的实例
val connection = url.openConnection() as HttpURLConnection

// 设置方法头
connection.requestMethod = "GET"
connection.connectTimeout = 8000
connection.readTimeout = 8000

// 获取输入流
val input = connection.inputStream

// 关闭连接
connection.disconnect()
~~~



~~~kotlin
connection.requestMethod = "POST"
val output = DataOutputStream(connection.outputStream)
output.writeBytes("username=admin&password=123456")
~~~

### OkHttp

OkHttp的项目主页地址是：https://github.com/square/okhttp

在`dependencies`闭包中添加如下内容：

```xml
implementation 'com.squareup.okhttp3:okhttp:4.1.0'
```

使用示例：

~~~kotlin
// 创建一个OkHttpClient的实例
val client = OkHttpClient()

// 创建一个Request对象，默认是get方法
val request = Request.Builder()
        .url("https://www.baidu.com")
        .build()

// 创建一个Call对象，并调用它的execute()方法来发送请求，并获取服务器返回的数据
val response = client.newCall(request).execute()

val responseData = response.body?.string()

~~~



~~~kotlin
val requestBody = FormBody.Builder()
        .add("username", "admin")
        .add("password", "123456")
        .build()

val request = Request.Builder()
        .url("https://www.baidu.com")
        .post(requestBody)
        .build()
~~~



- client.newCall(request).execute()：同步的请求方法
- client.newCall(request).enqueue(Callback callBack)：异步的请求方法，但Callback是执行在子线程中的，因此不能在此进行UI更新操作

### Retrofit

OkHttp侧重的是底层通信的实现，而Retrofit侧重的是上层接口的封装。

Retrofit的项目主页地址是：https://github.com/square/retrofit。

在`dependencies`闭包中添加如下内容：

```xml
implementation 'com.squareup.retrofit2:retrofit:2.6.1'
implementation 'com.squareup.retrofit2:converter-gson:2.6.1'
```



首先定义接口

~~~kotlin
interface AppService {
    @GET("get_data.json")
    // 发起一条GET请求， 这里的地址为一条根路径
    // 方法的返回值必须声明成Retrofit中内置的Call类型，并通过泛型来指定服务器响应的数据应该转换成什么对象。
    fun getAppData(): Call<List<App>>
    
    // 动态路径
    @GET("{page}/get_data.json")
    fun getData(@Path("page") page: Int): Call<Data>
    
    // 查询参数
    @GET("get_data.json")
    fun getData(@Query("u") user: String, @Query("t") token: String): Call<Data>
    
    // FormBody
    @POST("data/create")
    fun createData(@Body data: Data): Call<ResponseBody>
    
    // Http请求头
    @Headers("User-Agent: okhttp", "Cache-Control: max-age=0")
    @GET("get_data.json")
    fun getData(): Call<Data>
    
    // 动态请求头
    @GET("get_data.json")
    fun getData(@Header("User-Agent") userAgent: String,
        @Header("Cache-Control") cacheControl: String): Call<Data>
}
~~~

使用：

~~~kotlin
val retrofit = Retrofit.Builder()
    .baseUrl("http://10.0.2.2/")							// 设置根路径
    .addConverterFactory(GsonConverterFactory.create())		// 设置Retrofit在解析数据时所使用的转换库
    .build()

val appService = retrofit.create(AppService::class.java)		// 返回一个请求对象（使用了动态代理技术）

appService.getAppData().enqueue(object : Callback<List<App>> {
    
    override fun onResponse(call: Call<List<App>>,
        response: Response<List<App>>) {
        val list = response.body()
        if (list != null) {
            for (app in list) {
                Log.d("MainActivity", "id is ${app.id}")
                Log.d("MainActivity", "name is ${app.name}")
                Log.d("MainActivity", "version is ${app.version}")
            }
        }
    }

    override fun onFailure(call: Call<List<App>>, t: Throwable) {
        t.printStackTrace()
    }
})

~~~



## JSON

解析JSON数据也有很多种方法：

- 官方提供的JSONObject

  ~~~kotlin
  val jsonData: String;		// 假设已经保存JSON内容了
  val jsonArray = JSONArray(jsonData)
  for (i in 0 until jsonArray.length()) {
      val jsonObject = jsonArray.getJSONObject(i)
      val id = jsonObject.getString("id")
      val name = jsonObject.getString("name")
      val version = jsonObject.getString("version")
  }
  ~~~

  

- Google的开源库GSON

  添加如下依赖：

  ~~~xml
  implementation 'com.google.code.gson:gson:2.8.5'
  ~~~

  ~~~kotlin
  val gson = Gson()
  val person = gson.fromJson(jsonData, Person::class.java)	// 将JSON数据自动解析成一个Person对象
  ~~~

  ~~~kotlin
  val typeOf = object : TypeToken<List<Person>>() {}.type
  val people = gson.fromJson<List<Person>>(jsonData, typeOf)		// 解析JSON数组
  ~~~

  

- 第三方的开源库，例如Jackson、FastJSON
