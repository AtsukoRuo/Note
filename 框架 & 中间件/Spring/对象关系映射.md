# ORM

[TOC]



在关系数据库中，数据类型是Table，这与面向对象编程语言中的类类型存在天然结构上的差异。因此我们必须在它们两种类型之间做转换，好在**对象关系映射（Object-Relational Mapping，ORM）**框架能够自动帮我们完成这项转换工作。

**Java 的持久化标准 JPA（Java Persistent API，Java 持久化 API）**旨在屏蔽不同持久化 API 之间的差异。

## MyBatis

|                      |        MyBatis        |         Hibernate         |
| :------------------- | :-------------------: | :-----------------------: |
| XML 方式配置映射     |         支持          |           支持            |
| 注解方式配置映射     |         支持          |           支持            |
| 自动生成目标 SQL     |        不支持         |           支持            |
| 复杂的 SQL 操作      |         支持          |         部分支持          |
| SQL 优化难易程度     |         方便          |          不方便           |
| 底层数据库的可移植性 | 映射 SQL 与数据库绑定 | 有灵活的“方言”（HQL）支持 |

`Mapper`接口就相当于`Repository`层了

### 定义Mapper

MyBatis 支持通过 XML 和注解两种方式来配置映射。下面我们通过一个例子来介绍如何使用注解的方式来配置映射：首先是MyBatis 中使用的部分实体类定义：

~~~java
public enum Size {
    SMALL, MEDIUM, LARGE
}

@Builder
@Data
@AllArgsConstructor
@NoArgsConstructor
public class MenuItem {
    private Long id;
    private String name;
    private Size size;
    private Money price;
    private Date createTime;
    private Date updateTime;
}
~~~

添加了 @Mapper注解 的 `Mapper` 接口

~~~java
@Mapper
public interface MenuItemMapper {
    @Select("select count(*) from t_menu")
    long count();

    @Insert("insert into t_menu (name, price, size, create_time, update_time) " +
            "values (#{name}, #{price}, #{size}, now(), now())")
    @Options(useGeneratedKeys = true, keyProperty = "id")
    int save(MenuItem menuItem);

    @Update("update t_menu set name = #{name}, price = #{price}, size = #{size}, update_time = now() " +
            "where id = #{id}")
    int update(MenuItem menuItem);

    @Select("select * from t_menu where id = #{id}")
    @Results(id = "menuItem", value = {
        // 表中的列到对象属性的映射
        @Result(column = "id", property = "id", id = true),
        @Result(column = "size", property = "size", typeHandler = EnumTypeHandler.class),
        @Result(column = "price", property = "price", typeHandler = MoneyTypeHandler.class),
        @Result(column = "create_time", property = "createTime"),
        @Result(column = "update_time", property = "updateTime")
    })
    MenuItem findById(@Param("id") Long id);

    @Delete("delete from t_menu where id = #{id}")
    int deleteById(@Param("id") Long id);

    @Select("select * from t_menu")
    List<MenuItem> findAll();

    @Select("select m.* from t_menu m, t_order_item i where m.id = i.item_id and i.order_id = #{orderId}")
    List<MenuItem> findByOrderId(Long orderId);
}
~~~

**MyBatis 中的常用注解**

| 注解         | 作用                                                    | 重点属性说明                                                 |
| :----------- | :------------------------------------------------------ | :----------------------------------------------------------- |
| `@Insert`    | 定义插入操作                                            | `value` 为具体使用的 SQL 语句                                |
| `@Delete`    | 定义删除操作                                            | 同上                                                         |
| `@Update`    | 定义更新操作                                            | 同上                                                         |
| `@Select`    | 定义查询操作                                            | 同上                                                         |
| `@Param`     | 指定参数名称，方便在 SQL 中使用对应参数（一般不用指定） |                                                              |
| `@Results`   | 指定返回对象的映射方式，具体内容通过 `@Result` 注解设置 | `id`  以便复用（通过ResultMap）                              |
| `@Result`    | 指定具体字段、属性的映射关系                            | `javaType`                                                   |
| `@ResultMap` | 引用其他地方已事先定义好的映射关系                      |                                                              |
| `@Options`   | 设置开关和配置选项                                      | `useGeneratedKeys`——使用生成的主键，`keyProperty`——主键属性名，`fetchSize`——获取结果集的条数，`timeout`——超时时间 |
| `@One`       | 指定复杂的单个属性映射                                  | Select，用于指定关联查询的方法（一般是ByID）                 |
| `@Many`      | 指定复杂的集合属性映射                                  | 同上                                                         |



MyBatis 是通过 `TypeHandler` 来实现特殊类型的处理的。在上述代码示例中，有一段代码定义了特殊类型的映射：

~~~java
@Result(column = "size", property = "size", typeHandler = EnumTypeHandler.class),
@Result(column = "price", property = "price", typeHandler = MoneyTypeHandler.class),
~~~

`size` 属性是一个枚举，通常枚举在数据库中有两种保存方式，一种是保存枚举名，用的就是 `EnumTypeHandler`。另一种是保存枚举的顺序，用的是 `EnumOrdinalTypeHandler`。MyBatis 中默认使用 `EnumTypeHandler` 来处理枚举类型。

`price` 属性的类型是 `Money`，这个类 MyBatis 没有提供内置的 `TypeHandler`，因此需要我们自己来实现一个针对 `Money` 类型的处理器。MyBatis 提供了 `BaseTypeHandler` 抽象类，通过它可以方便地实现 `TypeHandler`。

~~~java
public class MoneyTypeHandler extends BaseTypeHandler<Money> {
    @Override
    public void setNonNullParameter(
        PreparedStatement ps, 
        int i,                    
        Money parameter, 
        JdbcType jdbcType) throws SQLException {
        
        ps.setLong(i, parameter.getAmountMinorLong());
    }

    @Override
    public Money getNullableResult(ResultSet rs, String columnName) throws SQLException {
        return parseMoney(rs.getLong(columnName));
    }

    @Override
    public Money getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
        return parseMoney(rs.getLong(columnIndex));
    }

    @Override
    public Money getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
        return parseMoney(cs.getLong(columnIndex));
    }

    private Money parseMoney(Long value) {
        return Money.ofMinor(CurrencyUnit.of("CNY"), value);
    }
}
~~~



我们再来考察在MyBatis中的一对多与多对多关系。

~~~java
@Mapper
public interface TeaMakerMapper {
    @Select("select * from t_tea_maker where id = #{id}")
    @Results(id = "teaMakerMap", value = {
        @Result(column = "id", property = "id"),
        @Result(column = "id", property = "orders",
                // 这里的id会传入到OrderMapper.findByMakerId中
                many = @Many(select = "learning.spring.binarytea.repository.OrderMapper.findByMakerId"))
    })
    TeaMaker findById(Long id);
    // 省略其他方法
}
~~~

~~~java
@Mapper
public interface OrderMapper {
    @Select("select * from t_order where id = #{id}")
    @Results(id = "orderMap", value = {
        @Result(column = "status", property = "status", typeHandler = EnumOrdinalTypeHandler.class),
        @Result(column = "amount_discount", property = "amount.discount"),
        @Result(column = "amount_total", property = "amount.totalAmount"),
        @Result(column = "amount_pay", property = "amount.payAmount"),
        @Result(column = "maker_id", property = "maker",
                one = @One(select = "learning.spring.binarytea.repository.TeaMakerMapper.findById")),
        @Result(column = "id", property = "items",
                many = @Many(select = "learning.spring.binarytea.repository.MenuItemMapper.findByOrderId"))
    })
    Order findById(Long id);

    @Select("select * from t_order where maker_id = #{makerId}")
    @ResultMap("orderMap")
    List<Order> findByMakerId(Long makerId);
    // 省略其他方法
}
~~~



### 使用Mapper

如何在工程中使用它们呢？有三种方式

- XML：

  ~~~xml
  <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
      <property name="dataSource" ref="dataSource" />
  </bean>
  
  <!-- 按需定义Mapper Bean -->
  <bean id="menuItemMapper" class="org.mybatis.spring.mapper.MapperFactoryBean">
      <property name="mapperInterface" value="learning.spring.binarytea.repository.MenuItemMapper" />
      <property name="sqlSessionFactory" ref="sqlSessionFactory" />
  </bean>
  ~~~

  在 `Mapper` 多的时候，可以直接通过扫描来实现 `Mapper` 的自动注册：

  ~~~xml
  <mybatis:scan base-package="learning.spring.binarytea.repository" />
  ~~~

- MapperScan：

  ~~~java
  @Configuration
  @MapperScan("learning.spring.binarytea.repository")
  public class Config {
      
  }
  ~~~

- starter：它自动会扫描项目下所有@Mapper标注的Mapper接口。

  ~~~java
  <dependency>
      <groupId>org.mybatis.spring.boot</groupId>
      <artifactId>mybatis-spring-boot-starter</artifactId>
      <version>2.2.2</version>
  </dependency>
  ~~~

  可以通过 `application.properties` 来定制一些配置：

  | 配置项                                               | 说明                                                         |
  | :--------------------------------------------------- | :----------------------------------------------------------- |
  | `mybatis.type-aliases-package`                       | 映射的 POJO 类型放置的包路径                                 |
  | `mybatis.type-handlers-package`                      | 类型映射所需的 `TypeHandler` 放置的包路径                    |
  | `mybatis.config-location`                            | MyBatis 配置文件的位置                                       |
  | `mybaits.mapper-locations`                           | 映射文件的位置                                               |
  | `mybatis.configuration.*`                            | MyBatis 核心配置，例如下面两个，不能和 `mybatis.config-location` 一起使用 |
  | `mybatis.configuration.map-underscore-to-camel-case` | 是否将下划线映射为驼峰规则 11                                |
  | `mybatis.configuration.default-statement-timeout`    | 默认语句超时时间                                             |



### 分页

MyBatis 分页插件 PageHelper，其spring-boot-starter为

~~~java
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>1.4.1</version>
</dependency>
~~~

接下来，在 `application.properties` 中添加一些设置。**PageHelper 在 Spring Boot 中的一些设置**

| 配置项                               | 说明                                                         |
| :----------------------------------- | :----------------------------------------------------------- |
| `pagehelper.offsetAsPageNum`         | 在使用 `RowBounds` 作为分页参数时，将 `offset` 作为页码      |
| `pagehelper.rowBoundsWithCount`      | 在使用 `RowBounds` 作为分页参数时，也会执行 `count` 操作     |
| `pagehelper.pageSizeZero`            | 如果分页大小为 `0`，则返回所有结果                           |
| `pagehelper.reasonable`              | 合理化分页，传入的页码小于等于 `0` 时返回第一页，大于最大页时返回最后一页 |
| `pagehelper.supportMethodsArguments` | 从方法的参数中获取分页所需的信息                             |

针对分页功能测试的 `MenuItemMapperTest` 代码片段：

~~~java
@SpringBootTest
public class MenuItemMapperTest {
    @Autowired
    private MenuItemMapper menuItemMapper;

    @Test
    public void testPagination() {
        // 不分页
        List<MenuItem> list = menuItemMapper.findAll();
        assertEquals(2, list.size());

        // 分页, 只有紧跟着PageHelper.startPage()的mapper方法才会有分页效果
        PageHelper.startPage(1, 1);
        list = menuItemMapper.findAll();
        assertEquals(1, list.size());
        assertTrue(list instanceof Page);
        PageInfo<MenuItem> pageInfo = new PageInfo<>(list);
        assertEquals(2, pageInfo.getPages()); // 总页数
        assertEquals(1, pageInfo.getPageSize()); // 每页大小
        assertEquals(1, pageInfo.getPageNum()); // 当前页码
        assertEquals(2, pageInfo.getNextPage()); // 下页页码
    }
}
~~~



此外，还可以在Mapper方法声明中，通过参数中指定分页信息（这是通过拦截器来实现的）：

~~~java
@Mapper
public interface TeaMakerMapper {
    @Select("select * from t_tea_maker")
    @ResultMap("teaMakerMap")
    List<TeaMaker> findAllWithRowBounds(RowBounds rowBounds);

    @Select("select * from t_tea_maker")
    @ResultMap("teaMakerMap")
    List<TeaMaker> findAllWithPage(int pageSize, int pageNum);

    // 省略其他方法
}
~~~

RowBounds会将所有的数据都加载到内存中，然后再做逻辑分页，而不是做物理分页。

~~~java
@SpringBootTest
public class TeaMakerMapperTest {
    @Autowired
    private TeaMakerMapper teaMakerMapper;

    @Test
    public void testPagination() {
        List<TeaMaker> list = teaMakerMapper.findAllWithRowBounds(new RowBounds(1, 1));
        PageInfo<TeaMaker> pageInfo = new PageInfo<>(list);
        assertEquals(1, list.size());
        assertEquals(1, pageInfo.getPageNum());
        assertEquals(1, pageInfo.getPageSize());
        assertEquals(2, pageInfo.getPages());

        list = teaMakerMapper.findAllWithPage(1, 2);
        pageInfo = new PageInfo<>(list);
        assertEquals(2, pageInfo.getPageNum());
        assertEquals(1, pageInfo.getPrePage());
        assertEquals(0, pageInfo.getNextPage()); // 没有下一页
    }
}
~~~



###  MyBatis Plus

在 MyBatis Plus 的帮助下，即只需要定义 POJO 类，再定义一个扩展了 `BaseMapper<T>` 的接口就能执行一些常规操作了。BaseMapper会自动为我们提供一些常用的方法。

`MyBatisPlus`的`spring-boot-starter`：

~~~java
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.5.1</version>
</dependency>
~~~

`MenuItem` 类的定义：

~~~java
@Builder
@Data
@AllArgsConstructor
@NoArgsConstructor
@TableName("t_menu")
public class MenuItem {...}
~~~

Mapper的定义：

~~~java
public interface MenuItemMapper extends BaseMapper<MenuItem> {
    // 在这个接口中，定义符合我们需求的方法即可
    @Select("select m.* from t_menu m, t_order_item i where m.id = i.item_id and i.order_id = #{orderId}")
    List<MenuItem> findByOrderId(Long orderId);
}
~~~

~~~java
@SpringBootTest
public class MenuItemMapperTest {
    @Autowired
    private MenuItemMapper menuItemMapper;

    @Test
    public void testSelect() {
        assertEquals(2, menuItemMapper.selectCount(null));

        MenuItem item = menuItemMapper.selectById(1L);
        assertEquals(1L, item.getId());
        assertEquals("Java咖啡", item.getName());
        assertEquals(Size.MEDIUM, item.getSize());
        assertEquals(Money.ofMinor(CurrencyUnit.of("CNY"), 1200), item.getPrice());

        // 这个selectList是BaseMapper里的
        List<MenuItem> list = menuItemMapper.selectList(null);
        assertEquals(2, list.size());
    }
    // 省略其他方法
}
~~~

MyBatis Plus 的 `BaseMapper<T>` 中带有分页的查询方法，但还需要配置分页插件才能完全发挥它的功能。在 Spring Boot 的配置类中增加如下 Bean，其中的 `PaginationInnerInterceptor` 就是分页插件

~~~java
@Bean
public MybatisPlusInterceptor mybatisPlusInterceptor() {
    MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
    mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
    return mybatisPlusInterceptor;
}
~~~

分页测试代码：

~~~java
@Test
public void testPagination() {
    Page<MenuItem> page = menuItemMapper.selectPage(new Page<MenuItem>(1, 1).addOrder(OrderItem.asc("id")), null);
    assertEquals(1, page.getCurrent());
    assertEquals(1L, page.getRecords().get(0).getId());
    assertEquals(1, page.getRecords().size());
    assertEquals(2, page.getTotal());
}
~~~

