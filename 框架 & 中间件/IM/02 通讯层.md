# 通讯层

[TOC]



把 websocket 和 tcp 协议封装到通信层内部，提供抽象接口给上层使用，达到业务逻辑与通信协议解耦的目的。同时，通信层封装了**端口监听、拨号连接、消息发送、消息接收、心跳、连接管理** 等逻辑，在不同协议上进行复用。

系统内部一个大致的逻辑关系如下：

![通信层消息流程图.png](./assets/7bec90b39abc4e50837ae3abb9da2ab7tplv-k3u1fbpfcp-jj-mark1512000q75.webp)

从中我们可以抽象出来两个通讯层接口：

1. Server：定义服务端接口，监听并维护连接。
2. Client：定义客户端接口，与服务端建立连接，并提供消息收发功能。

## Server 接口

Server 接口处理的流程如下：

![server.png](./assets/d61355fd6ccf4e5193307714e07c4735tplv-k3u1fbpfcp-jj-mark1512000q75.webp)

接口定义如下：

~~~go
type Server interface {
	SetAcceptor(Acceptor)
	SetMessageListener(MessageListener)
	SetStateListener(StateListener)
	SetReadWait(time.Duration)
        SetChannelMap(ChannelMap)
        
	Start() error
	Push(string, []byte) error
	Shutdown(context.Context) error
}
~~~

- `SetAcceptor`：用于设置一个 Acceptor，在 Server 的 Start() 方法中监听到连接之后，就要调用这个 Accept 方法，让上层业务处理握手相关的工作。

  ~~~go
  type Acceptor interface {
      // 这里的 Conn，是下面我们自己封装的对象
  	Accept(Conn, time.Duration) (string, error)
  }
  ~~~

  Accept 会返回以下对象

  - `channelID`：通道的唯一标识
  - `error`：如果上层业务返回一个 error，那么连接就会被 Server 断开。

- `SetStateListener`：用于设置一个状态监听器，将连接断开的事件上报给业务层，让业务层可以实现一些逻辑处理。

  ~~~go
  type StateListener interface {
  	Disconnect(string) error
  }
  ~~~

- `SetReadWait`：设置连接读超时，用于心跳逻辑中。

- `SetChannelMap`： 设置一个连接管理器，Server 会自动在内部管理这些连接

  ~~~go
  type ChannelMap interface {
  	Add(channel Channel)
  	Remove(id string)
  	Get(id string) (Channel, bool)
  	All() []Channel
  }
  ~~~

  它管理的对象是 Channel，而不是具体的一个 net.Conn 连接对象。Channel 就是对 net.Conn 的封装。

- `SetMessageListener`：用于设置一个消息监听器：

  ~~~go
  type MessageListener interface {
  	Receive(Agent, []byte)
  }
  ~~~

  Agent 表示发送方，它定义了两个方法：

  ~~~go
  type Agent interface {
      ID() string
      Push([]byte) error
  }
  ~~~

  - Push：用于向上层业务返回发送方传来的消息
  - ID : 返回连接的 channelID

## 拆包

由于我们通信协议是以 TCP / WS 为载体的，所以`[]byte` 必须是完整的数据包，否则上层业务在解析协议时就会失败；但是 websocket 与 tcp 数据封包与拆包逻辑不同：

- TCP协议是字节传输，通常需要上层业务处理拆包。
- Websocket 协议是基于 Frame，在底层 Server 中就可以区分出每一个 Frame，然后把Frame 中的 Payload 交给上层。

因此，我们通过两个抽象，来解决 WS 与 TCP 拆包逻辑不同的问题。

首先对协议进行抽象。这里我们在 TCP 协议的基础上，直接封装一个类似于 WS 的协议，在这个简易协议上再承载我们的通讯协议。这样好统一接口。

~~~go
type Frame interface {
	SetOpCode(OpCode)
	GetOpCode() OpCode
	SetPayload([]byte)
	GetPayload() []byte
}

// 简易协议的 OpCode 与 WS 保持一致，这样方便处理
const (
	OpContinuation OpCode = 0x0
	OpText         OpCode = 0x1
	OpBinary       OpCode = 0x2
	OpClose        OpCode = 0x8
	OpPing         OpCode = 0x9
	OpPong         OpCode = 0xa
)
~~~

![协议抽象.png](./assets/a91b98882ba9448cbc54dff34958e94dtplv-k3u1fbpfcp-jj-mark1512000q75.webp)

然后通过对 net.Conn 进行二次包装，把读与写的操作封装到连接中

~~~go
type Conn interface {
	net.Conn
	ReadFrame() (Frame, error)
	WriteFrame(OpCode, []byte) error
	Flush() error
}
~~~

## 客户端

客户端接口的定义：

```golang
type Client interface {
	ID() string
	Name() string
	Connect(string) error
	SetDialer(Dialer)
	Send([]byte) error
	Read() (Frame, error)
	Close()
}
```

- `Connect`：主动向一个服务器地址发起连接。

- `SetDialer`：设置一个拨号器，这个方法会在 Connect 中被调用，完成连接的建立和握手。

  ~~~go
  type Dialer interface {
      // DialerContext 由 Client 回传到该方法中
  	DialAndHandshake(DialerContext) (net.Conn, error)
  }
  
  type DialerContext struct {
  	Id      string
  	Name    string
  	Address string
  	Timeout time.Duration
  }
  ~~~

- `Send`：发送消息到服务端。

- `Read`：读取一帧数据

- `Close`：断开连接，退出