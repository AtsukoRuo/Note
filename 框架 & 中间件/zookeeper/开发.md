# 开发

每个 API 调用都需要 Zookeeper 句柄，它表示客户端与 ZooKeeper 服务端之间的一个会话。 ZooKeeper 句柄的构造函数如下：

~~~java
ZooKeeper(
	String connectString,
	int sessionTimeout,
	Watcher watcher)
~~~

- connectString：指定 Zookeeper 的主机名和端口
- sessionTimeout：以毫秒为单位，设置会话超时时间
- watcher：用于接收会话事件

Wacher 接口可以监控会话状态，也可以监控节点的变化，它的定义如下：

~~~java
public interface Watcher {
	void process(WatchedEvent event);
}
~~~

下面给出一个使用示例：

~~~java
public class Master implements Watcher {
    ZooKeeper zk;
    String hostPort;
    
    Master(String hostPort) {
        this.hostPort = hostPort;
    }
    
    void startZK() {
        zk = new ZooKeeper(hostPort, 15000, this);
    }
    
    public void process(WatchedEvent e) {
        System.out.println(e);
    }
    public static void main(String args[])
        throws Exception {
        Master m = new Master(args[0]);
        m.startZK();
    }
}
~~~

当客户端与服务端连接断开时，客户端的 Watcher 会收到 Disconnected 事件。此时，千万不要立即重新创建 ZooKeeper 句柄，来重新连接服务。因为 ZooKeeper 客户端库会自己负责重新连接服务，之后你应该会接收到 SyncConnected 事件。



创建一个节点：

~~~java
zk.create("/master",
	serverId.getBytes(),
	OPEN_ACL_UNSAFE,
	CreateMode.EPHEMERAL);
~~~

这里常量 `ZooDefs.Ids.OPEN_ACL_UNSAFE` 给所有用户授权了所有权限。ZooKeeper 通过插件式认证方法，为每个节点提供了 ACL 策略功能。即限制某个用户对某个 znode 节点的哪些权限。

create 方法会抛出两种异常：

- `KeeperException`
- `InterruptedException`

在 Zookeeper 提供的 API 中，有同步与异步两个版本。以下为 create 方法的异步调用版本

~~~java
void create(
    String path,
	byte[] data,
	List<ACL> acl,
	CreateMode createMode,
	AsyncCallback.StringCallback cb,
	Object ctx)
~~~

- cb：提供回调方法的对象。该对象只需实现以下方法：

  ~~~java
  void processResult(int rc, String path, Object ctx, String name)
  ~~~

  - rc：返回 OK 或 KeeperException 等异常对应的编码值。
  - name：znode 节点的名称。在 `CreateMode.SEQUENTIAL` 模式下，name 与 path 不相等。

- ctx：上下文信息，会传入到回调方法中

注意：只有一个线程来处理回调调用。避免在回调函数中使用同步阻塞方法。StringCallback 对象的使用示例：

~~~java
static StringCallback masterCreateCallback = new StringCallback() {
    void processResult(int rc, String path, Object ctx, String name) {
        switch(Code.get(rc)) {
            case CONNECTIONLOSS:
                //... 
            case OK:
                //... 
            case NONODE:
        }
    }
};
~~~





获取数据：

~~~java
byte[] getData(
	String path,
	bool watch,
	Stat stat)
~~~

- path：指定从中获取数据的节点
- watch：是否想要监听后续的数据变更。如果设置为 true，那么我们可以通过创建 ZooKeeper 句柄时所设置的 Watcher 对象得到事件
- stat：该方法会向其填充 znode 节点的元数据



一个应用在接收到通知后，注册另一个监视点时，可能会丢失事件。但这通常不是问题，因为我们可以通过读取操作，即获取最新的状态，又设置一个新的监控点。此外，在连接断开的情况下触发的 watcher 也是会丢失的。

客户端设置的每个监视点与会话关联，如果会话过期，等待中的监视点将会被删除。但是监控点可以跨越不同的服务端连接。

可以注册 watcher 的方法：getData、exists、getChildren。 可以触发 watcher 的方法：create、delete、setData。

getData、exists、getChildren 的参数 watch 可以是以下两个类型：

- bool：如果设置为 true，那么就设立监控点，并在触发时，调用 ZooKeeper 句柄上注册的 Watcher
- Watcher：如果提供了该对象，那么就设立监控点，并在触发时，调用这个 Watcher

我们只需覆写 Watcher 接口类中的 process 方法，即可监听事件：

~~~java
public void process(WatchedEvent event);
~~~

WatchedEvent 对象包括以下字段：

- ZooKeeper会话状态（KeeperState）：Disconnected、SyncConnected、AuthFailed、ConnectedReadOnly、SaslAuthenticated 和 Expired
- 事件类型（EventType）：NodeCreated、NodeDeleted、NodeDataChanged、NodeChildrenChanged 和 None
- 除 None 事件类型外，都会返回 znode 路径

一旦设置监视点，就无法主动移除。只能通过以下两个方法来移除：

- 触发这个监视点
- 关闭会话



写操作与ZK内部产生的事件的对应关系：

|                        | event For “/path”             | event For “/path/child”   |
| :--------------------- | :---------------------------- | :------------------------ |
| create(“/path”)        | EventType.NodeCreated         | 无                        |
| delete(“/path”)        | EventType.NodeDeleted         | 无                        |
| setData(“/path”)       | EventType.NodeDataChanged     | 无                        |
| create(“/path/child”)  | EventType.NodeChildrenChanged | EventType.NodeCreated     |
| delete(“/path/child”)  | EventType.NodeChildrenChanged | EventType.NodeDeleted     |
| setData(“/path/child”) | 无                            | EventType.NodeDataChanged |

写操作与 watcher 的对应关系：

|                        | “/path” |         |             | “/path/child” |         |             |
| :--------------------- | :------ | :------ | :---------- | :------------ | :------ | :---------- |
|                        | exists  | getData | getChildren | exists        | getData | getChildren |
| create(“/path”)        | √       | √       |             |               |         |             |
| delete(“/path”)        | √       | √       | √           |               |         |             |
| setData(“/path”)       | √       | √       |             |               |         |             |
| create(“/path/child”)  |         |         | √           | √             | √       |             |
| delete(“/path/child”)  |         |         | √           | √             | √       | √           |
| setData(“/path/child”) |         |         |             | √             | √       |             |

**值得注意的是：getChildren(“/path”) 监视 /path 的子节点，如果 /path 自己删了，也会触发 NodeDeleted 事件。**