# 客户端

[TOC]

## 协议格式

Redis制定了**RESP（REdis Serialization Protocol，Redis序列化协议）**，作为客户端与服务端之间的数据交换格式。

RESP 的规定一条请求命令的格式如下，CRLF代表 "\r\n"。

~~~resp
*<参数数量> CRLF
$<参数1的字节数量> CRLF
<参数1> CRLF
...
$<参数N的字节数量> CRLF
<参数N> CRLF
~~~

Redis的响应结果的类型分为以下五种

- 状态回复："+"

  ~~~resp
  +OK
  ~~~

- 错误回复："-"

  ~~~resp
  -ERR unknown command 'sethx'
  ~~~

- 整数回复："："

  ~~~resp
  :1
  ~~~

- 字符串回复："$"

  ~~~resp
  $5
  world
  ~~~

- 字符串回复："*"

  ~~~resp
  *3
  $5
  world
  $-1
  $5
  jedis
  ~~~

  

## 客户端管理

Redis 提供了与客户端相关的 API，可以对其状态进行监控和管理

`client list`命令能列出与 Redis 服务端相连的所有客户端连接信息

![image-20240113160613177](assets/image-20240113160613177.png)

- id、addr、fd、name：客户端的标识

  - id 客户端连接的唯一标识
  - addr 客户端连接的ip和端口
  - fd：socket的文件描述符
  - name：客户端的名字

- qbuf、qbuf-free：输入缓冲区。Redis为每个客户端分配了输入缓冲区，它的作用是将客户端发送的命令临时保存，同时Redis从会输入缓冲区拉取命令并执行

  - qbuf：缓冲区的总容量
  - qbuf-free：剩余容量

  Redis没有提供相应的配置来规定每个缓冲区的大小，输入缓冲区会根据输 入内容大小的不同动态调整，只是要求每个客户端缓冲区的大小不能超过 1G，超过后客户端将被关闭。

  ~~~c
  /* Protocol and I/O related defines */
  #define REDIS_MAX_QUERYBUF_LEN (1024*1024*1024) /* 1GB max query buffer. */
  ~~~

  输入缓冲区不受`maxmemory`控制，假设一个Redis实例设置了 `maxmemory`为4G，已经存储了2G数据，但是如果此时输入缓冲区使用了 3G，已经超过`maxmemory`限制，此时可能会产生数据丢失、键值淘汰、OOM等情况。如何监控到这一问题呢？

  - 通过定期执行 client list 命令，收集qbuf和qbuf-free找到异常的连接记录并分析。执行比较慢
  - 通过info clients命令，输出最大的输入缓冲区使用量。执行比较快

  

- obl、oll、omem：输出缓冲区。Redis为每个客户端分配了输出缓冲区，它的作用是缓存命令执行的结果。与输入缓冲区不同的是，输出缓冲区的容量可以通过参数`client-outputbuffer-limit`来进行设置

  ~~~shell
  $ client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
  ~~~

  - class ：客户端类型，分为三种。
    - a）normal：普通客户端；
    - b） slave：slave客户端
    - c）pubsub：发布订阅客户端。
  - `hard limit`： 如果客户端使用的输出缓冲区大于`hard limit`，客户端会被立即关闭。
  - `<soft limit>`和`<soft seconds>`：如果客户端使用的输出缓冲区超过了`<soft limit>`并且持续了`<soft seconds>`秒，客户端会被立即关闭。

  Redis的默认配置是：

  ~~~shell
  $ client-output-buffer-limit normal 0 0 0
  $ client-output-buffer-limit slave 256mb 64mb 60
  $ client-output-buffer-limit pubsub 32mb 8mb 60
  ~~~

  和输入缓冲区相同的是，输出缓冲区也不会受到maxmemory的限制。

  实际上输出缓冲区由两部分组成：固定缓冲区（16KB）和动态缓冲区，其中固定缓冲区返回比较小的执行结果，而动态缓冲区返回比较大的结果，例如大的字符串、hgetall、smembers命令的结果等。

  固定缓冲区使用的是字节数组，动态缓冲区使用的是链表。当固定缓 区存满后，一律会将Redis新的返回结果存放在动态缓冲区的队列中。

  - obl代表固定缓冲区的长度（结果的个数）
  - oll代表动态缓冲区列表的长度（结果的个数）
  - omem代表使用的字节数

  监控输出缓冲区的方法依然有两种：

  - 通过定期执行client list命令，收集obl、oll、omem找到异常的连接记录并分析
  - 通过info命令的info clients模块，输出最大的缓冲区列表对象数

- 客户端

  - age：当前客户端已经连接的时间
  - idle：客户端连接自最后一次发送任何命令到现在的秒数

- 客户端的限制

  - maxclients：最大连接数。默认值是10000

    可以通过config set maxclients对最大客户端连接数进行动态设置

    ![image-20240113170757999](assets/image-20240113170757999.png)

  - timeout：空闲超时时间.

- 客户端类型

  ![image-20240113171005260](assets/image-20240113171005260.png)



`client setName`用于给客户端设置名字

~~~shell
127.0.0.1:6379> client setName test_client
OK
~~~

`client getName`命令获取当前客户端的名字



`client kill`命令用于杀掉指定IP地址和端口的客户端

~~~shell
$ client kill ip:port
~~~





`client pause`命令用于阻塞**所有**客户端timeout毫秒数

~~~shell
$ client pause timeout
~~~

client pause只对普通和发布订阅客户端有效，对于主从复制是无效的。也就是说，这个命令主要用于给Redis主从复制提供一个的时间窗口



`monitor`命令用于监控其他Redis客户端正在执行的命令

![image-20240113172540957](assets/image-20240113172540957.png)

每个客户端都有自己的 输出缓冲区，既然monitor能监听到所有的命令，一旦Redis的并发量过大， monitor客户端的输出缓冲会暴涨



客户端还有其他配置

- timeout：检测客户端空闲连接的超时时间，一旦idle时间达到了 timeout，客户端将会被关闭，如果设置为0（默认值）就不进行检测。

- maxclients：客户端最大连接数

- tcp-keepalive：检测TCP连接活性的周期，默认值为0，也就是不进行检测。

- tcp-backlog：TCP三次握手后，会将该连接放入队列中等待Redis处理，tcpbacklog就是队列的大小，默认511。

  如果`/proc/sys/net/core/somaxconn`小于`tcp-backlog`，那么在Redis启动时会看到如下日志，并建议将`/proc/sys/net/core/somaxconn`设置更大。

  修改方法也非常简单，只需要执行如下命令：

  ~~~shell
  $ echo 511 > /proc/sys/net/core/somaxconn
  ~~~

  



~~~shell
127.0.0.1:6379> info clients
# Clients
connected_clients:1414
client_longest_output_list:0
client_biggest_input_buf:2097152
blocked_clients:0
~~~

- connected_clients：代表当前Redis节点的客户端连接数。一旦超过maxclients，新的客户端连接将被拒绝。
- client_longest_output_list：当前所有输出缓冲区中队列对象个数的最大值。
- client_biggest_input_buf：当前所有输入缓冲区中占用的最大容量。
- blocked_clients：正在执行阻塞命令（例如blpop、brpop、 brpoplpush）的客户端个数。

除此之外info stats中还包含了两个客户端相关的统计指标

~~~shell
127.0.0.1:6379> info stats
~~~

- `total_connections_received`：Redis自启动以来处理的客户端连接数总数。
- `rejected_connections`：Redis自启动以来拒绝的客户端连接数。

## 案例分析

1. **无法从连接池获取到连接**

   JedisPool中的Jedis对象个数是有限的，默认是8个。如果要获取Jedis但连接池中已经没有了，那么就需要进行等待。等待maxWaitMillis时间后仍然无法获取到Jedis对象，就会抛出异常

   ![image-20240113174337939](assets/image-20240113174337939.png)

   

   如果设置了`blockWhenExhausted=false`，那么调用者发现池子中没有资源时，会立即抛出异常

   ![image-20240113174411867](assets/image-20240113174411867.png)

2. **客户端执行命令超时**：

   ~~~shell
   redis.clients.jedis.exceptions.JedisConnectionException:
   java.net.SocketTimeoutException: connect timed out
   ~~~

   - 连接超时设置得过短
   - Redis发生阻塞，造成tcp-backlog已满
   - 客户端与服务端网络不正常

3. **客户端连接超时**

4. **客户端缓冲区异常**

5. 如果Redis当前正在执行某个Lua脚本超过了`lua-time-limit`，那么此时Jedis调用Redis时，会收到下面的异常

   ~~~shell
   redis.clients.jedis.exceptions.JedisDataException: BUSY Redis is busy running a
   script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.
   ~~~

6. Redis正在加载持久化文件

   Jedis调用Redis时，如果Redis正在加载持久化文件，那么会收到下面的 异常：

   ~~~shell
   redis.clients.jedis.exceptions.JedisDataException: LOADING Redis is loading the
   dataset in memory
   ~~~

7. Redis使用的内存超过maxmemory配置

8. 客户端连接数过大



Redis内存陡增

- 服务端现象：Redis主节点内存陡增，几乎用满maxmemory，而从节点 内存并没有变化

- 客户端现象：客户端产生了OOM异常，也就是Redis主节点使用的内存已经超过了maxmemory的设置

- 分析原因：

  - 查看主从复制是否出现问题，正常来说主节点的键个数与从节点的键个数基本相同

  - 排查是否由客户端缓冲区造成主节点内存陡增。一般monitor命令会导致缓冲区占用过大



客户端周期性的超时

- 客户端现象：客户端出现大量周期性超时
- 服务端现象：服务端并没有明显的异常
- 分析
  - 网络：服务端和客户端之间的网络出现周期性问题
  - 客户端：排查是否因为慢查询阻塞了Redis
