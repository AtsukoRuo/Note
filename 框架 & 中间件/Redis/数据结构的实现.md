# 数据结构的实现



## 字符串

Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。

~~~c
struct sdshdr {
    // 记录 buf 数组中已使用字节的数量
    // 等于 SDS 所保存字符串的长度
    int len;

    // 记录 buf 数组中未使用字节的数量
    int free;

    // 字节数组，用于保存字符串
    char buf[];

};
~~~

![image-20240114220519249](assets/image-20240114220519249.png)

这样做的好处有：

- **以O(1)复杂度获取字符串的长度**

- **杜绝缓冲区溢出**。当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求。若不满足， API 会自动将 SDS 的空间扩展至执行修改所需的大小。

- 减少修改字符串所带来的内存分配次数。

  - 如果程序执行的是增长字符串的操作， 比如拼接操作（append），那么必须重分配内存，扩展所需的空间，以避免缓冲区溢出。
  - 如果程序执行的是缩短字符串的操作， 比如截断操作（trim），那么必须重分配内存，抛除掉不需要的空间，以避免内存泄露

  而 SDS 采用了空间预分配机制，用于优化 SDS 字符串增长操作。即当 SDS  API 需要扩展一个 SDS 空间时，会额外分配一些空间，具体策略如下：

  - 如果对 SDS 进行修改后， SDS 的长度（也即是 `len` 属性的值）小于 `1 MB`，那么等额分配一个空间。举个例子， 如果进行修改之后， SDS 的 `len` 将变成 `13` 字节， 那么程序也会分配 `13` 字节的未使用空间， SDS 的 `buf` 数组的实际长度将变成 `13 + 13 + 1 = 27` 字节
  - 如果对 SDS 进行修改之后， SDS 的长度将大于等于 `1 MB` ， 那么会分配一个1MB大小的空间。举个例子， 如果进行修改之后， SDS 的 `len` 将变成 `30 MB` ， 那么程序会分配 `1 MB` 的未使用空间， SDS 的 `buf` 数组的实际长度将为 `30 MB + 1 MB + 1 byte` 。

  惰性空间释放用于优化 SDS 的字符串缩短操作：当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 `free` 属性将这些字节的数量记录起来， 并等待将来使用。与此同时， SDS 也提供了相应的 API ， 让我们可以在有需要时， 真正地释放 SDS 里面的未使用空间， 所以不用担心惰性空间释放策略会造成内存浪费。

- 二进制安全，SDS API会以二进制来解释字符串，这样Redis 不仅可以保存文本数据， 还可以保存任意格式的二进制数据。

- 兼容C字符串函数



Redis 会在初始化服务器时， 创建一万个**字符串对象**， 这些对象包含了从 `0` 到 `9999` 的所有整数值， 当服务器需要用到值为 `0` 到 `9999` 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。

> 创建共享字符串对象的数量可以通过修改 `redis.h/REDIS_SHARED_INTEGERS` 常量来修改。

另外， 这些共享对象不单单只有字符串键可以使用， 那些在数据结构中嵌套了字符串对象的对象（`linkedlist` 编码的列表对象、 `hashtable` 编码的哈希对象、 `hashtable` 编码的集合对象、以及 `zset` 编码的有序集合对象）都可以使用这些共享对象。但是由于压缩列表（ziplist）的实现，它并不共享对象。而且还要注意这种共享对于 maxmemory + lru 淘汰策略的影响

像 json 这样的数据可以使用 hash 结构，而不是作为一个字符串整体来存储。

## 链表的实现

每个链表节点使用一个 `adlist.h/listNode` 结构来表示：

~~~c
typedef struct listNode {

    // 前置节点
    struct listNode *prev;

    // 后置节点
    struct listNode *next;

    // 节点的值
    void *value;

} listNode;
~~~

![image-20240114222319632](assets/image-20240114222319632.png)

~~~c
typedef struct list {

    // 表头节点
    listNode *head;

    // 表尾节点
    listNode *tail;

    // 链表所包含的节点数量
    unsigned long len;

    // 节点值复制函数
    void *(*dup)(void *ptr);

    // 节点值释放函数
    void (*free)(void *ptr);

    // 节点值对比函数
    int (*match)(void *ptr, void *key);

} list;
~~~



## 压缩列表

压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。

一个压缩列表的各个组成部分

| 属性      | 类型       | 长度     | 用途                                                         |
| :-------- | :--------- | :------- | :----------------------------------------------------------- |
| `zlbytes` | `uint32_t` | `4` 字节 | 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 `zlend` 的位置时使用。 |
| `zltail`  | `uint32_t` | `4` 字节 | 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。 |
| `zllen`   | `uint16_t` | `2` 字节 | 记录了压缩列表包含的节点数量： 当这个属性的值小于 `UINT16_MAX` （`65535`）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 `UINT16_MAX` 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。 |
| `entryX`  | 列表节点   | 不定     | 压缩列表包含的各个节点，节点的长度由节点保存的内容决定。     |
| `zlend`   | `uint8_t`  | `1` 字节 | 特殊值 `0xFF` （十进制 `255` ），用于标记压缩列表的末端。    |

![image-20240114223327119](assets/image-20240114223327119.png)

![image-20240114223334458](assets/image-20240114223334458.png)

每个压缩列表节点可以保存一个字节数组或者一个整数值， 其中， 字节数组可以是以下三种长度的其中一种：

1. 长度小于等于 `63` （2^{6}-1）字节的字节数组；
2. 长度小于等于 `16383` （2^{14}-1） 字节的字节数组；
3. 长度小于等于 `4294967295` （2^{32}-1）字节的字节数组；

而整数值则可以是以下六种长度的其中一种：

1. `4` 位长，介于 `0` 至 `12` 之间的无符号整数；
2. `1` 字节长的有符号整数；
3. `3` 字节长的有符号整数；
4. `int16_t` 类型整数；
5. `int32_t` 类型整数；
6. `int64_t` 类型整数。

每个压缩列表节点都由 `previous_entry_length` 、 `encoding` 、 `content` 三个部分组成， 如图 7-4 所示。

![digraph {      label = "\n 图 7-4    压缩列表节点的各个组成部分";      node [shape = record];      n [label = " previous_entry_length | encoding | content "];  }](assets/graphviz-cc6b40e182bfc142c12ac0518819a2d949eafa4a.png)

- 节点的 `previous_entry_length` 属性以字节为单位， 记录了压缩列表中前一个节点的长度。

  - 如果前一节点的长度小于 `254` 字节， 那么 `previous_entry_length` 属性的长度为 `1` 字节： 前一节点的长度就保存在这一个字节里面。
  - 如果前一节点的长度大于等于 `254` 字节， 那么 `previous_entry_length` 属性的长度为 `5` 字节： 其中属性的第一字节会被设置为 `0xFE` （十进制值 `254`）， 而之后的四个字节则用于保存前一节点的长度。

  这样就可以方便地计算出前一个节点的起始地址

- 节点的 `encoding` 属性记录了节点的 `content` 属性所保存数据的类型以及长度：

  表 7-2 字节数组编码

  | 编码                                           | 编码长度 | `content` 属性保存的值                 |
  | :--------------------------------------------- | :------- | :------------------------------------- |
  | `00bbbbbb`                                     | `1` 字节 | 长度小于等于 `63` 字节的字节数组。     |
  | `01bbbbbb xxxxxxxx`                            | `2` 字节 | 长度小于等于 `16383` 字节的字节数组。  |
  | `10______ aaaaaaaa bbbbbbbb cccccccc dddddddd` | `5` 字节 | 长度小于等于 `4294967295` 的字节数组。 |

  表 7-3 整数编码

  | 编码       | 编码长度 | `content` 属性保存的值                                       |
  | :--------- | :------- | :----------------------------------------------------------- |
  | `11000000` | `1` 字节 | `int16_t` 类型的整数。                                       |
  | `11010000` | `1` 字节 | `int32_t` 类型的整数。                                       |
  | `11100000` | `1` 字节 | `int64_t` 类型的整数。                                       |
  | `11110000` | `1` 字节 | `24` 位有符号整数。                                          |
  | `11111110` | `1` 字节 | `8` 位有符号整数。                                           |
  | `1111xxxx` | `1` 字节 | 使用这一编码的节点没有相应的 `content` 属性， 因为编码本身的 `xxxx` 四个位已经保存了一个介于 `0` 和 `12` 之间的值， 所以它无须 `content` 属性。 |



Redis 将在特殊情况下产生的连续多次空间扩展操作称之为**“连锁更新”（cascade update）**。

现在， 考虑这样一种情况： 在一个压缩列表中， 有多个连续的、长度介于 `250` 字节到 `253` 字节之间的节点 `e1` 至 `eN` 

![image-20240114224641671](assets/image-20240114224641671.png)

这时， 如果我们将一个长度大于等于 `254` 字节的新节点 `new` 设置为压缩列表的表头节点。因为 `e1` 的 `previous_entry_length` 属性仅长 `1` 字节， 它没办法保存新节点 `new` 的长度， 所以程序将对压缩列表执行空间重分配操作， 并将 `e1` 节点的 `previous_entry_length` 属性从原来的 `1` 字节长扩展为 `5` 字节长。此时这对于e2、e3 ... eN来说都成立，那么恐怖的连锁更新就发生了。

因为连锁更新在最坏情况下需要对压缩列表执行 `N` 次空间重分配操作， 而每次空间重分配的最坏复杂度为 O(N) ， 所以连锁更新的最坏复杂度为 O(N^2) 。

## 字典



## 对象

Redis通过 redisObject 结构体来定义值对象

~~~c
typedef struct redisObject {
    unsigned type:4;       // RedisObject的类型
    unsigned encoding:4;   // 同一种类型的RedisObject数据有不同的编码形式
    unsigned lru:LRU_BITS; // 记录对象最后一次被访问的时间，用于LRU算法中
    int refcount;          // 引用计数，在Redis中同一个RedisObject可能被多个地方共用
    void *ptr;             // 指向底层实现数据结构的指针
} robj;
~~~

使用`object idletime {key}`命令，可以在不更新 lru 字段情况下，查看当前键的过期时间。

- 对象的 `type` 属性记录了对象的类型

  | 类型常量       | 对象的名称   |
  | :------------- | :----------- |
  | `REDIS_STRING` | 字符串对象   |
  | `REDIS_LIST`   | 列表对象     |
  | `REDIS_HASH`   | 哈希对象     |
  | `REDIS_SET`    | 集合对象     |
  | `REDIS_ZSET`   | 有序集合对象 |

- `encoding` 属性记录了对象所使用的编码

  | 编码常量                    | 编码所对应的底层数据结构      |
  | :-------------------------- | :---------------------------- |
  | `REDIS_ENCODING_INT`        | `long` 类型的整数             |
  | `REDIS_ENCODING_EMBSTR`     | `embstr` 编码的简单动态字符串 |
  | `REDIS_ENCODING_RAW`        | 简单动态字符串                |
  | `REDIS_ENCODING_HT`         | 字典                          |
  | `REDIS_ENCODING_LINKEDLIST` | 双端链表                      |
  | `REDIS_ENCODING_ZIPLIST`    | 压缩列表                      |
  | `REDIS_ENCODING_INTSET`     | 整数集合                      |
  | `REDIS_ENCODING_SKIPLIST`   | 跳跃表和字典                  |

  每种类型的对象都至少使用了两种不同的编码

  | `REDIS_STRING` | `REDIS_ENCODING_INT`        | 使用整数值实现的字符串对象。                         |
  | -------------- | --------------------------- | ---------------------------------------------------- |
  | `REDIS_STRING` | `REDIS_ENCODING_EMBSTR`     | 使用 `embstr` 编码的简单动态字符串实现的字符串对象。 |
  | `REDIS_STRING` | `REDIS_ENCODING_RAW`        | 使用简单动态字符串实现的字符串对象。                 |
  | `REDIS_LIST`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的列表对象。                         |
  | `REDIS_LIST`   | `REDIS_ENCODING_LINKEDLIST` | 使用双端链表实现的列表对象。                         |
  | `REDIS_HASH`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的哈希对象。                         |
  | `REDIS_HASH`   | `REDIS_ENCODING_HT`         | 使用字典实现的哈希对象。                             |
  | `REDIS_SET`    | `REDIS_ENCODING_INTSET`     | 使用整数集合实现的集合对象。                         |
  | `REDIS_SET`    | `REDIS_ENCODING_HT`         | 使用字典实现的集合对象。                             |
  | `REDIS_ZSET`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的有序集合对象。                     |
  | `REDIS_ZSET`   | `REDIS_ENCODING_SKIPLIST`   | 使用跳跃表和字典实现的有序集合对象。                 |

  因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码， 从而优化对象在某一场景下的效率。

