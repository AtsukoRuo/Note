# 功能型组件

[TOC]

## 媒体查询

MediaQuery 是一个帮助开发者获取设备信息的继承式组件（InheritedWidget）。例如是否为横屏状态、是否开启了夜间模式、是否在系统偏好里设置了较大的字号等。

|             查询             |        属性        |
| :--------------------------: | :----------------: |
|       屏幕的宽度和高度       |        size        |
|        是横屏还是竖屏        |    orientation     |
|       是否开启夜间模式       | platformBrightness |
| 设备的交互方式（触屏、手柄） |   navigationMode   |
|    是否调整了默认字体大小    |  textScaleFactor   |

## Builder

Builder 与 StatefulBuilder 是为了解决获取局部 context 的问题。此外 StatefulBuilder 还可以实现局部刷新（控制刷新范围）。

下面我们通过一个例子来学习Builder组件：

~~~dart
void main() => runApp(CustomWidget());

class CustomWidget extends StatelessWidget {
    @Override
    Widget build(BuildContext context) {
        return MaterialApp(
          home: Scaffold(
            body: GestureDetector(
              onTap: () {
                Scaffold.of(context).showSnackBar(SnackBar(
                  content: Text(''),
                ));
              },
              child : child,
            )
          )
       );    
    }
}
~~~

运行后直接抛出了异常。这是因为 context 是 CustomWidget 的，而不是GestureDetector 的。所以 Scaffold.of 无法通过 context 获取到 Scaffold 组件。为了解决这个问题，我们引入 Builder 组件，通过它可以获取局部 context：

~~~diff
class CustomWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
        home: Scaffold(
+            body: Builder(
+                builder : (context) {
                  return GestureDetector(
                    onTap: () {
                      Scaffold.of(context).showSnackBar(SnackBar(
                        content: Text(''),
                      ));
                    },
                    child : null,
                  );
                }
            )
        )
    );
  }
}
~~~

StatefulBuilder 的作用与 Builder 类似，但是它还可以局部刷新 UI。在不考虑复用性的前提下，可以代替 StatefulWidget：

~~~dart
body: Center(
    child: StatefulBuilder(
        builder: (BuildContext context, StateSetter setState) {
            return Text("clickTimes$clickTimes").gesture(onTap: () {
              setState(() {
                clickTimes++;
              });
            });
        },
    ),
),
~~~



## 悬浮

### Overlay

有时候，我们想要将`Overlay`相对定位于某个组件上，此时我们必须获取这个组件相对屏幕左上角的偏移量，以及组件的尺寸。

- `renderObject.size`获取尺寸
- `renderObject.localToGlobal(Offset.zero)`来获取相对屏幕左上角的偏移量。



可以通过`Element`类中的`renderObject`方法直接获取渲染对象。Flutter`框架在`Widget`层中通过`BuildContext`接口来暴露`Element`对象，其中`BuildContext` 定义了 `findRenderObject` 接口，`Element`对该接口的实现就是直接返回`renderObject`。

![img](assets/f4a564ee865941598138a3fab69a2acbtplv-k3u1fbpfcp-jj-mark1512000q75.webp)



~~~dart
void printInfo(BuildContext context){
  RenderObject? renderObject = context.findRenderObject();
  if(renderObject!=null && renderObject is RenderBox){
    // 获取尺寸
    print(renderObject.size);
    // 获取相对屏幕左上角的偏移量
    print(renderObject.localToGlobal(Offset.zero));
  }
}
~~~



如何获取指定组件的`context`，而不是当前`StatelessWidget#build`的`context`参数呢？通过`Builder`组件

~~~dart
Widget build(BuildContext context) {
    return Builder(
      builder: (BuildContext ctx) => {
           RenderBox? renderObject = ctx.findRenderObject() as RenderBox;
           renderObject!.size
           renderObject!.localToGlobal(Offset.zero)
           return Widget(...) 
      	}
    )
}
~~~



一般没有必要直接使用 `Overlay` 组件，因为 `MaterialApp` 中已经集成了 `Overlay` 。我们只需要获取到 `OverlayState` ，然后插入 `OverlayEntry` 节点即可显示浮动组件。

~~~dart
final OverlayState? overlayState = Overlay.of(context);
final entry = OverlayEntry(
	builder : (context) => Container(...)
)
overlayState.insert(entry);
entry.remove()			// 移除该OverlayEntry
~~~

这里要注意：

- `OverlayEntry#builder` 下的约束是紧约束 ，一般大小为整个屏幕大小
- `Positioned` 可以作为 `builder` 所返回的顶层组件，从而实现相对定位



有时候插入overlayState时会报错`Unhandled Exception: setState() or markNeedsBuild() called during build.`此时我们只需这样插入即可：

~~~dart
WidgetsBinding.instance.addPostFrameCallback((_) {
    overlayState?.insert(entry);
    window.scheduleFrame(); 	// 强制刷新一帧
});
~~~



### CompositedTransform Target/Follower

`CompositedTransformFollower`组件追踪`CompositedTransformTarget`的位置。

使用时，必须设置`CompositedTransformTarget`组件的`link`属性，其类型为`LayerLink`。当追随者和目标使用同一个`LayerLink`时，追随者会被位移至目标处。这里需要注意的是，“目标”必须在“追随者”之前绘制，否则会导致运行时错误。



~~~dart
const CompositedTransformFollower({
    super.key,
    required this.link,
    this.showWhenUnlinked = true,
    this.offset = Offset.zero,
    this.targetAnchor = Alignment.topLeft,
    this.followerAnchor = Alignment.topLeft,
    super.child,
});
~~~

- `offset`：用于为追随者组件增加额外的位移
- `showWhenUnlinked`：决定是否应继续显示该追随者。默认值为true，即追随者仍然可见，但不会再有位移。若修改为false，则当目标不可见时，追随者也会随之被暂时隐藏，直到目标再次出现



可以通过 CompositedFollower 解决 OverlayEntry 不跟随父组件移动的问题：

~~~dart
class _TitleWidgetState extends State<TitleWidget> {
  double elevation = 10.0;
  final LayerLink _layerLink = LayerLink();

  @override
  Widget build(BuildContext context) {
    return CompositedTransformTarget(
      link: _layerLink,
      child: GestureDetector(
            onTap: () => _onTapWithContext(context),
            child: //....
      ),
    );
  }

  void _onTapWithContext(BuildContext context) {
    RenderObject? renderObject = context.findRenderObject();
    if (renderObject != null && renderObject is RenderBox) {
      final size = renderObject.size;
      final offset = renderObject.localToGlobal(Offset.zero);
      OverlayEntry? entry;
      const double panelH = 250.0;
      const double panelW = 400.0;

      entry = OverlayEntry(
        builder: (context) => Positioned(
            left: offset.dx - ((panelW - size.width) / 2),
            top: offset.dy + size.height + 10,
            child: CompositedTransformFollower(
              link: _layerLink,
              offset: Offset(0.0, size.height + 10.0),
              child: SizedBox(
                height: panelH,
                width: panelW,
                child: // 你自己的 Widget
              ),
            )),
      );
      Overlay.of(context).insert(entry);
    }
  }
}

~~~

## 弹窗

### Dialog

`AlertDialog`、`SimpleDialog`以及`Dialog`是`Material`组件库提供的三种对话框，旨在帮助开发者快速构建出符合 Material 设计规范的对话框。



![image-20231109120724507](assets/image-20231109120724507.png)

~~~dart
const AlertDialog({
  Key? key,
  this.title, 					// 对话框标题组件
  this.titlePadding, 			// 标题填充
  this.titleTextStyle, 			// 标题文本样式
  this.content, 				// 对话框内容组件
  this.contentPadding = const EdgeInsets.fromLTRB(24.0, 20.0, 24.0, 24.0), //内容的填充
  this.contentTextStyle,		// 内容文本样式
  this.actions, 				// 对话框操作按钮组
  this.backgroundColor, 		 // 对话框背景色
  this.elevation,				// 对话框的阴影
  this.semanticLabel, 			// 对话框语义化标签(用于读屏软件)
  this.shape,				    // 对话框外形
})
~~~

实际上`AlertDialog`和`SimpleDialog`都使用了`Dialog`类。由于`AlertDialog`和`SimpleDialog`中使用了`IntrinsicWidth`来尝试通过子组件的实际尺寸来调整自身尺寸，这就导致他们的子组件不能是延迟加载模型的组件（如`ListView`、`GridView` 、 `CustomScrollView`等）。如下面的代码运行后会报错：

~~~dart
AlertDialog(
  content: ListView(
    children: ...//省略
  ),
);
~~~

如果我们就是需要嵌套一个`ListView`应该怎么做？这时，我们可以直接使用`Dialog`类，如：

~~~dart
Dialog(
  child: ListView(
    children: ...//省略
  ),
);
~~~

此外，Dialog 还可以自定义我们的弹窗：

~~~dart
showDialog(
    context: context,
    builder: (BuildContext context) {
        return Dialog(
            child: Padding(
                padding: const EdgeInsets.all(8.0),
                child: Text(
                    "hello world",
                    textAlign: TextAlign.center,
                ),
            ),
        );
    },
);
~~~

![在这里插入图片描述](./assets/853aaf1f1da1416880ea11bbadf53c10.png)



我们通过`Navigator.of(context).pop(…)`方法来关闭对话框的。

通过`showDialog()`弹出对话框，声明如下：

~~~dart
Future<T?> showDialog<T>({
  required BuildContext context,
  required WidgetBuilder builder, // 对话框 UI Widget 的builder
  bool barrierDismissible = true, //点击对话框barrier(遮罩)时是否关闭它
})
~~~

该方法返回一个`Future`，它正是用于接收对话框的返回值：如果我们是通过点击对话框遮罩关闭的，则`Future`的值为`null`，否则为`Navigator.of(context).pop(result)`中的`result`参数

~~~dart
await showDialog<bool>(
	context : context,
    builder : (context) {
		return AlertDialog(...);
    }
)
~~~



`showModalBottomSheet`方法可以弹出一个Material风格的底部菜单列表模态对话框。



为了避免在 `initState()` 阶段无法获取到完整的 `context`，要在 `WidgetsBinding.instance.addPostFrameCallback()` 里调用 `showDialog()` ，这样 `widget` 渲染完毕后才会显示对话框

~~~dart
@override
void initState() {
  super.initState();
  WidgetsBinding.instance.addPostFrameCallback((_) {
    showDialog(...);
  });
}
~~~

### 外部样式

实际上，`showDialog`方法正是`showGeneralDialog`的一个封装，它定制了`Material`风格对话框的遮罩颜色和动画。

外部样式包含对话框遮罩样式、打开动画等。

~~~dart
Future<T?> showGeneralDialog<T>({
  required BuildContext context,
  required RoutePageBuilder pageBuilder, 				//构建对话框内部UI				
  bool barrierDismissible = false, 						//点击遮罩是否关闭对话框				
  Color barrierColor = const Color(0x80000000), 		// 遮罩颜色		
  Duration transitionDuration = const Duration(milliseconds: 200), // 对话框打开/关闭的动画时长
  RouteTransitionsBuilder? transitionBuilder, 				// 对话框打开/关闭的动画
  ...
})
~~~

-  `pageBuilder`：类型为`Widget Function(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation)`。
- `transitionBuilder`：类型为`Widget Function(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation, Widget child)`



~~~dart
showGeneralDialog(
  context: context,
  pageBuilder: (BuildContext buildContext, 
                Animation<double> animation,
      			Animation<double> secondaryAnimation) {
    return Container();
  },
  barrierDismissible: barrierDismissible,
  barrierLabel: MaterialLocalizations.of(context).modalBarrierDismissLabel,
  barrierColor: Colors.black87,
  transitionDuration: const Duration(milliseconds: 150),
  transitionBuilder: (BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation, Widget child) {
    // 使用缩放动画
    return ScaleTransition(
      scale: CurvedAnimation(
        parent: animation,
        curve: Curves.easeOut,
      ),
      child: child,
    );
  },
);
~~~



## Theme & Color

### Theme

通过定义 `Theme`，我们可以更好地复用颜色和字体样式，从而让整个 app 的设计看起来更一致。 `MaterialApp` 已经事先为你预设了一个全局的 `Theme Widget`。`Theme`组件本身是一个`InheritedWidget`。

`ThemeData`用于保存 `Material` 组件库的主题数据

~~~dart
ThemeData({
  Brightness? brightness, 			// 深色还是浅色
  MaterialColor? primarySwatch, 	// 主题颜色样本
  Color? primaryColor, 				// 主色
  Color? cardColor, 				// 卡片颜色
  Color? dividerColor, 				// 分割线颜色
  ButtonThemeData buttonTheme, 		// 按钮主题
  Color dialogBackgroundColor,		// 对话框背景颜色
  String fontFamily,				// 文字字体
  TextTheme textTheme,				// 字体主题，包括标题、body等文字样式
  IconThemeData iconTheme, 			// Icon的默认样式
  TargetPlatform platform, 			// 指定平台，应用特定平台控件风格
  ColorScheme? colorScheme,			
  ...
})
~~~

注意：**ThemeData中的颜色属性正逐渐 Deprecated**，推荐使用`ColorScheme`来设置颜色。



下面给出一个例子：

~~~dart
Theme(
  data: ThemeData(
    splashColor: Colors.yellow,
  ),
  child: ...
);
~~~

相比从头开始定义一套样式，从父级 `Theme` 扩展并覆写可能更常规一些，使用 `copyWith()`方法即可。

~~~dart
Theme(
  data: Theme.of(context).copyWith(splashColor: Colors.yellow),
  child: ...
);
~~~

`Theme.of(context)` 会查询 widget 树，并返回其中最近的 `Theme`组件



### Color

> https://rydmike.com/flexcolorscheme/themesplayground-v7-1/#/ 配色网站

> https://m2.material.io/design/color/the-color-system.html#color-usage-and-palettes Materail Color

`MaterialColor`是实现`Material Design`中的颜色的类，它包含一种颜色的10个级别的渐变色。`MaterialColor`通过"[]"运算符的索引值来代表颜色的深度，有效的索引有：`50`，`100`，`200`，…，`900`。`MaterialColor`的默认值为索引等于`500`的颜色

~~~dart
Colors.blue.shade50
Colors.blue[50]
~~~



可以通过`ColorScheme`来快速创建应用程序的颜色主题。

~~~dart
final ColorScheme myColorScheme = ColorScheme(
  primary: Colors.blue,
  secondary: Colors.yellow,
  background: Colors.white,
  surface: Colors.grey[100],
  error: Colors.red[800],
  onPrimary: Colors.white,
  onSecondary: Colors.black,
  onBackground: Colors.black,
  onSurface: Colors.black,
);
~~~

![Diagram of Material color scheme displaying the baseline Material color theme](assets/k6WO1fd7T40A9JvSVfHqs0CPLFyTEDCecsVGxEDhOaTP0wUTPYOVVkxt60hKxBprgNoMqs8OyKqtlaQ4tDBtQJs-fTcZrpZEjxhUVQ=w1064-v0.png)

此外，还有：

- `tertiary`
- `primaryContainer`
- `secondaryContainer`



它还包括从单一种⼦颜⾊⽣成整个配⾊⽅案的能力。你可以使用任意颜色来创建新的 `ColorScheme` 类型：

```dart
final lightScheme = ColorScheme.fromSeed(seedColor: Colors.green);
final darkScheme = ColorScheme.fromSeed(seedColor: Colors.green, brightness: Brightness.dark);
```

`ThemeData` 的构造函数还有一个新的 `colorSchemeSeed` 参数，可以直接从颜色⽣成主题的配⾊⽅案：

~~~dart
final lightTheme = ThemeData(colorSchemeSeed: Colors.orange, ...); 
final darkTheme = ThemeData(colorSchemeSeed: Colors.orange, brightness: Brightness.dark, ...); 
~~~



使用示例：

~~~dart
Theme.of(context).colorScheme.background
~~~



在 Flutter 中，我已经给 MaterialApp 提供了 theme 参数以及 darkTheme 参数，现在的默认主题是亮色模式。如果我想给某个特定的控件指定暗色模式，那么应该怎么做？

答：使用一个全局变量来保存

~~~dart
class GlobalVar {
  static final themeData = FlexThemeData.light(...)
}

MaterialApp(theme: GlobalVar.themeData)
    
Theme(
     data: GlobalVar.themeData, // 提供暗色主题
     child:...
 );

// 错误做法
Theme(data: Theme.of(context))
Theme(data: ThemeData.light())
~~~

## 拖放

### Draggable

Draggable组件可为任意组件增添拖动支持，再配合DragTarget（拖放目标）组件，轻松实现拖放功能。

~~~dart
  const Draggable({
    super.key,
    required this.child,
    required this.feedback,
    this.data,
    this.axis,
    this.childWhenDragging,
    this.dragAnchorStrategy = childDragAnchorStrategy,
    this.affinity,
    this.maxSimultaneousDrags,
    this.onDragStarted,
    this.onDragUpdate,
    this.onDraggableCanceled,
    this.onDragEnd,
    this.onDragCompleted,
  })
~~~

- `feedback`：当子组件被拖动时，触点下的反馈组件。

- `childWhenDragging`：在正在被拖动的过程中，代替子组件而留在原地的组件。

- `maxSimultaneousDrags`：限制某组件可被同时拖动的次数。例如在多点触控情况下，用户可先用食指拖动一个Draggable组件，并在保持食指不松开的情况下，再使用其他手指拖动同一个组件

  ![image-20230914133325957](assets/image-20230914133325957.png)

- `dragAnchorStrategy`： A strategy that is used by this draggable to get the anchor offset when it is dragged。

  - childDragAnchorStrategy，则在拖动开始的瞬间，feedback会立即将其左上角与用户手指或鼠标光标的位置对齐。可使用Transform组件将中心与光标对齐

- `axis`：限制拖动的方向

- `data`：和DragTarget配合使用的。

- `onDragStarted`：开始拖动时回调

- `onDragEnd`：拖动结束时回调

- `onDragUpdate`：拖动时回调

- `onDraggableCanceled`：当拖动结束后，若组件落在DragTarget外，或者落在DragTarget内但被拒绝了，那么执行该函数。

- `onDragCompleted`：当拖动结束后，若组件落在DragTarget内，而且被接收了，那么就执行该函数。

其中落在的含义是指，拖动组件的指针在`DragTarget`内。



LongPressDraggable（长按拖放）组件，顾名思义，是普通的Draggable组件的“长按”版本。使用该组件可使被拖动的组件只有在用户长按后才进入拖动状态。



实际上，`Draggable`组件就是在用户开始拖放操作时，在`Overlay`中插入了一个`OverlayEntry`，内容为`Positioned`组件和`Draggable`的`feedback`属性所指定的“反馈”组件。在用户拖动的过程中，`Draggable`通过连续调用`markNeedsBuild()`方法不断更新这个`OverlayEntry`中的`Positioned`组件的`top`和`left`属性，以实现`feedback`组件自动跟随光标移动的效果。当拖放操作结束时，`Draggable`会将该`OverlayEntry`撤除。

### DragTarget

`DragTarget`是一个可用于接收`Draggable`的组件，当Draggable落在DragTarget中（触点在DragTarget内），那么就执行以下逻辑

- onWillAccept：当用户拖动进来到DragTarget时
  - 若类型匹配，立即调用`onWillAccept`，根据数据做业务逻辑判断，返回一个布尔值。
  - 如果DragTarget的类型与Draggable中的data属性的类型不匹配，那么直接拒接掉，并且不调用任何回调函数（onMove、onWillAccept、builder等等）
- 无论`onWillAccept`所返回的布尔值为什么，都会调用onMove以及onLeave，其中
  - onMove，用户仍在进行拖动时，并且拖动在DragTarget范围内，那么就会调用
  - onLeave，用户仍在进行拖动时，但从DragTarget中离开
- onAccept：当用户松手后触点在DragTarget中，并且onWillAccept返回true，那么就调用该函数
- builder，当用户拖动进来以及拖动离开后，调用该函数。参数为列表的原因是，用户可能同时拖动多个控件。



## 导航

`Navigator`是一个路由管理的组件。它在内部维护一个栈以及使用 Overlay 组件，来管理各个页面组件。它提供了打开和退出路由页方法

~~~dart
Future push(BuildContext context, Route route)
    
bool pop(BuildContext context, [ result ])
~~~

打开路由页

~~~dart
Navigator.of(context).push(Route route)
~~~

如果想要给调用页面返回一个值，那么在调用 pop() 方法时设置 result 参数即可。

~~~dart
// 在当前弹出的页面上
Navigator.pop(context, result);	// 向调用页面返回result

// 调用页面
var result = await Navigator.push(...);
~~~

如果想要给新的路由页面传递一个值。那么必须将这个页面封装成一个 Widget，并且在其构造函数中声明这个要传入的值。

~~~dart
val result =  await Navigator.push(
	MaterialRoutePage(builder: (context) => NewPage(value));
)
~~~



下面我们来看看当路由页面时，Widget Tree会发生怎么样的改变。

~~~plaintext
--> MaterialApp
    --> Navigator
        --> HomePage
~~~

当我们从`HomePage`导航至`SecondPage`时，调用`Navigator.push()`方法，此时`SecondPage`将会被添加到Widget Tree中：

~~~plaintext
--> MaterialApp
    --> Navigator
        --> HomePage
        --> SecondPage
~~~

要返回到`HomePage`时，可以调用`Navigator.pop()`方法，此时`SecondPage`会从Widget Tree中移除，进行如下变化：

~~~plaintext
--> MaterialApp
    --> Navigator
        --> HomePage
~~~



### 路由动画

`MaterialPageRoute`继承自`PageRoute`类。而`PageRoute`类是一个抽象类，继承自`Route`，表示占有整个屏幕空间的一个模态路由页面，它还定义了路由构建及切换时过渡动画的相关接口及属性。

而`MaterialPageRoute`定义了`Material`风格的过渡动画、遮罩等

```dart
  MaterialPageRoute({
    WidgetBuilder builder,
    RouteSettings settings,
    bool maintainState = true,
    bool fullscreenDialog = false,
  })
```

- `maintainState`：默认情况下，当入栈一个新路由时，原来的路由仍然会被保存在内存中，如果想在路由没用的时候释放其所占用的所有资源，可以设置`maintainState`为 `false`。
- `builder` 是一个`WidgetBuilder`类型的回调函数，它的作用是构建路由页面的具体内容，返回值是一个`widget`。

使用示例：

~~~dart
Navigator.of(context).push(
    MaterialPageRoute(
        builder: (_) => EnterPage()),
);
~~~







通过`PageRouteBuilder`来自定义路由切换动画。

```dart
Navigator.of(context).push(
  PageRouteBuilder(
    transitionDuration: Duration(milliseconds: 500), //动画时间为500毫秒
    pageBuilder: (BuildContext context, Animation animation,
        Animation secondaryAnimation) {
      );
    },
      
    
    transitionsBuilder: (context, animation, secondaryAnimation, child) {
     
    }
  ),
);
```

- `pageBuilder`：创建这个路由页面的内容。这个 `pageBuilder` 方法仅会在第一次构建路由的时候被调用。

- `transitionsBuilder`
  - `animation`: When the [Navigator](https://api.flutter-io.cn/flutter/widgets/Navigator-class.html) pushes a route on the top of its stack, the new route's primary `animation` runs from 0.0 to 1.0. When the [Navigator](https://api.flutter-io.cn/flutter/widgets/Navigator-class.html) pops the topmost route this animation runs from 1.0 to 0.0.
  - `secondaryAnimation`: When the Navigator pushes a new route on the top of its stack, the old topmost route's `secondaryAnimation` runs from 0.0 to 1.0. When the [Navigator](https://api.flutter-io.cn/flutter/widgets/Navigator-class.html) pops the topmost route, the `secondaryAnimation` for the route below it runs from 1.0 to 0.0.
  - `child`：是 `pageBuilder()` 的返回值。
  



而`PageRouteBuilder`其实只是`PageRoute`的一个封装。我们可以直接继承`PageRoute`类来实现自定义路由，但这样有点麻烦，不太推荐。

~~~dart
class FadeRoute extends PageRoute {
  FadeRoute({
    required this.builder,
    super.transitionDuration = const Duration(milliseconds: 300),
    super.opaque = true,
    super.barrierDismissible = false,
    super.barrierColor,
    super.barrierLabel,
    super.maintainState = true,
  });

  final WidgetBuilder builder;
	
    
  // Override this method to build the primary content of this route.
  
  @override
  Widget buildPage(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation) => builder(context);

  // Override this method to wrap the child with one or more transition widgets that define how the route arrives on and leaves the screen.
  @override
  Widget buildTransitions(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation, Widget child) {
     return FadeTransition( 
       opacity: animation,
       child: builder(context),
     );
  }
}


// 使用
Navigator.push(context, FadeRoute(builder: (context) {
  return PageB();
}));
~~~

### WillPopScope

Flutter中可以通过`WillPopScope`来实现导航返回拦截

```dart
const WillPopScope({
  ...
  required WillPopCallback onWillPop,
  required Widget child
})
```

- `onWillPop`：当用户按下 Android 物理返回按钮，或者导航返回（Navigator.pop）时会调用该函数。该回调需要返回一个`Future`对象，如果返回的`Future`最终值为`false`时，则当前路由不出栈(不会返回)；最终值为`true`时，当前路由出栈退出。

### 局部路由

之前介绍的路由页面都是整个屏幕，如何我们想要在某一个组件中进行路由跳转怎么办？提供一个**Navigator** 组件即可

~~~dart
class PageA extends StatelessWidget {
  const PageA({Key? key}) : super(key: key);
 
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Container(
        height: 350,
        width: 300,
        child: Navigator(
          initialRoute: '/',
          onGenerateRoute: (RouteSettings settins) {
            WidgetBuilder builder;
            switch (settins.name) {
              case '/':
                builder = (context) => PageC();
                break;
              default:
                builder = (context) => PageD();
                break;
            }
            return MaterialPageRoute(builder: builder);
          },
        ),
      ),
    );
  }
}
~~~

## 导航 2.0

由于 Flutter 最初是针对移动端开发的，所以导航体系在最初是在维护路由栈的，但是路由栈的全屏跳转是违反宽屏应用的交互习惯。因此 Flutter 在路由 2.0 中引入了路由树的概念，不仅可以实现局部跳转，而且可以基于数据来进行路由。而且路由 2.0 支持声明式操作，也就是说，只通过数据（`Navigator#pages`）来更新路由栈。

![image.png](./assets/7252164e29b545119cab526665246765tplv-k3u1fbpfcp-jj-mark1512000q75.webp)

Page 类是提供 Route 对象的配置信息。它定义了一个 `createRoute` 抽象方法，用于创建 Route 对象。Page 对象从类结构来看，和 Widget 是非常类似的，都是提供配置信息的。但 Page 比 Widget 要简单地多：因为 Page 创建的 Route，所维护的结构是**线型的**（一维）；Widget 创建的 Element，所维护的结构是**树形的**（二维）。

![img](./assets/bc57589cd7882.png)

通过 pages 列表可以自由地操作路由栈。比如 `['/', 'a', 'b', 'c']` ，此时你如果要退出 C 界面，同时想要移除 A 界面，只需要将数据改为 `['/', 'b']` 即可。

![image.png](./assets/bedb5cbcc9d249cd8d3ffcb1b9edbe99tplv-k3u1fbpfcp-jj-mark1663000q75.webp)



使用示例：

~~~dart
@override
Widget build(BuildContext context) {
    return MaterialApp(
        home: Router(
            routerDelegate: delegate,
        ),
    );
}
~~~

`Router` 组件必须有一个 `RouterDelegate` 参数。`RouterDelegate` 需要实现以下方法：

- `build`：构建导航组件
- `popRoute`：在有返回事件时被触发。比如移动端的返回手势、web 的导航回退。
- `setNewRoutePath`：在设置路由时被触发。比如 web 浏览器输入 url 时。

~~~dart
class AppRouterDelegate extends RouterDelegate<List<RouteSettings>> with ChangeNotifier {
  List<RouteSettings> _pages = [RouteSettings(name: "/home")];
    
  @override
  Widget build(BuildContext context) { }

  @override
  Future<bool> popRoute() { }

  @override
  Future<void> setNewRoutePath(configuration) async{}
    
    // ...
}
~~~

此外，必须给 `RouterDelegate` 提供 `addListener`、`removeListener` 方法，来实现监听的功能。我们可以混入 `ChangeNotifier` 来提供这些方法。

下面我们来看一个 `RouterDelegate` 示例：

~~~dart
class MyRouterDelegate extends RouterDelegate<List<RouteSettings>> 
    with ChangeNotifier, PopNavigatorRouterDelegateMixin<List<RouteSettings>> {

    final List<RouteSettings> _pages = [];

    @override
    final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

    @override
    Widget build(BuildContext context) {
        return Navigator(
            key: navigatorKey,
            pages: _pages.map((e) => _createPage(e)).toList(),
            onPopPage: (route, result) {
                if (!route.didPop(result)) {
                    return false;
                }
                _pages.removeLast();
                notifyListeners();
                return true;
            },
        );
    }

    @override
    Future<void> setNewRoutePath(List<RouteSettings> configuration) async {}

~~~

注意，这里混入了一个`PopNavigatorRouterDelegateMixin`，主要是为了重写它的`popRoute`方法

向外部暴露的更新逻辑

~~~dart
void push({required String name, dynamic arguments}) {
    // 操纵 _pages 来完成路由的更新
    _pages.add(_createPage(RouteSettings(name: name, arguments: arguments)));
    // 在更新完 _pages 后，一定要调用 notifyListener
    notifyListeners();
}

void replace({required String name, dynamic arguments}) {
    if (_pages.isNotEmpty) {
        _pages.removeLast();
    }
    push(name: name,arguments: arguments);
}


MaterialPage _createPage(RouteSettings routeSettings) {
    Widget child;
    switch (routeSettings.name) {
        case '/home':
            child = const Home();
            break;
        case '/splash':
            child = const Splash();
            break;
        case '/login':
            child = const Login();
            break;
        case '/details':
            child = Details(routeSettings.arguments! as Map<String, String>);
            break;
        default:
            child = const Scaffold();
    }
    return MaterialPage(
        child: child,
        key: Key(routeSettings.name!) as LocalKey,
        name: routeSettings.name,
        arguments: routeSettings.arguments,
    );
}
~~~

`RouterDelegate` 的 `popRoute`，它将会在 **系统请求弹出路由** 时触发。如果返回 true，那么说明 `RouterDelegate` 已经成功处理了这次的 "pop" 操作，Flutter 框架将不再继续处理。否则会继续分发这次的 "pop" 事件。这里的分发是指调用`Navigator` 的 `onPopPage` 回调函数。

~~~dart
@override
Future<bool> popRoute() {
    if (_pages.length > 1) {
        _pages.removeLast();
        // 这里要调用 notifyListeners
        notifyListeners();
        return Future.value(true);
    }
    return _confirmExit();
}

Future<bool> _confirmExit() async {
    final result = await showDialog<bool>(
        context: navigatorKey.currentContext!,
        builder: (context) {
            return AlertDialog(
                content: const Text('确定要退出App吗?'),
                actions: [
                    TextButton(
                        child: const Text('取消'),
                        // 这里的 pop 是 AlertDialog 的，而不是 RouterDelegate 的
                        onPressed: () => Navigator.pop(context, true),
                    ),
                    TextButton(
                        child: const Text('确定'),
                        onPressed: () => Navigator.pop(context, false),
                    ),
                ],
            );
        });
    return result ?? true;
}
~~~

注意，`Navigator.pop` 并不会直接更新 `pages`。然而调用 `Navigator.pop`  的时候，实际上会触发 `RouterDelegate` 的 `popRoute` 方法，我们可以在 `popRoute` 中去更新 `pages`：

~~~dart
@override
Future<bool> popRoute() {
    if (pages.length > 1) {
        pages.removeLast();
        notifyListeners();
        return Future.value(true);
    }
    return Future.value(false);
}
~~~

同理， `Navigator.push()`也不会更新 pages，而且不幸的是，在调用`Navigator.push` 的时候，不会触发 RouterDelegate 任何回调函数，因此也没有机会去更新 pages。

`Navigator` 的 `onPopPage`。`onPopPage` 只响应路由栈顶层页面的移除，中间页面的移除不会调用这个回调函数。返回 false 表示不弹出页面。

~~~dart
bool _onPopPage(Route route, dynamic result) {
    if (!route.didPop(result)) return false;
    // 如果当前路由无法执行 pop 操作，则返回 false
    if (canPop()) {
        _pages.removeLast();
        return true;
    } else {
        return false;
    }
}
~~~

我们再来看一个例子

~~~dart
bool _onPopPage(Route<dynamic> route, dynamic result) {
  // setState(() => pages.remove(route.settings));
  return route.didPop(result);
}
~~~

假设这里的 `route.didPop(result)` 返回true，即在底层路由栈中弹出该页面。这时，Flutter 就会发现底层路由栈和 pages  不一致，**那么会尝试根据 `pages` 来重建和更新路由栈，保证底层路由栈和上层 pages 保持一致**。这里就会将刚刚弹出的路由页面再重新添加回来。



路由跳转的示例：

~~~dart
MyRouterDelegate delegate = MyRouterDelegate();

GestureDetector(
   onTap: (){
     delegate.push(name: '/details',arguments: {'name':_movieList![i].name,'imgUrl':_movieList![i].imgUrl});
   },
}
~~~

可以在 Router 构建的页面中调用`Navigator.pop`，此时会触发 `RouterDelegate` 中的 `popRoute` 方法。一般在覆写的 popRoute 方法中，会弹出 _pages 最后一个元素。



如果我们直接维护 `List<Page>`，那么不方便对其中的元素进行修改。因此，我们通常维护 `List<RouteSettings>`，。在设置 Navigator 的 pages 参数时，调用 List.map() 将 RouteSetting 元素转换为 Page 元素。



### Web URL

![img](./assets/fb87d71461414deea1b539565a1d0110tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

我们需要自定义一个路由信息解析器：

~~~dart
class MyRouteInformationParser extends RouteInformationParser<List<RouteSettings>> {

  const MyRouteInformationParser() : super();


  // 帮助我们将一个 URL 地址转换成路由的状态（即配置信息）
  @override
  Future<List<RouteSettings>> parseRouteInformation(RouteInformation routeInformation) {
    final uri = Uri.parse(routeInformation.location!);

    if (uri.pathSegments.isEmpty) {
      return Future.value([const RouteSettings(name: '/home')]);
    }

    final routeSettings = uri.pathSegments
        .map((pathSegment) => RouteSettings(
              name: '/$pathSegment',
              arguments: pathSegment == uri.pathSegments.last
                  ? uri.queryParameters
                  : null,
            ))
        .toList();

    return Future.value(routeSettings);
  }

  // 帮助我们将路由的状态（配置信息）转换为一个 URL 地址
  @override
  RouteInformation restoreRouteInformation(List<RouteSettings> configuration) {
    final location = configuration.last.name;
    final arguments = _restoreArguments(configuration.last);

    return RouteInformation(location: '$location$arguments');
  }。

  String _restoreArguments(RouteSettings routeSettings) {
    if (routeSettings.name != '/details') return '';
    var args = routeSettings.arguments as Map;

    return '?name=${args['name']}&imgUrl=${args['imgUrl']}';
  }
}
~~~

在`MyRouterDelegate`中添加代码：

~~~dart
@override
List<Page> get currentConfiguration => List.of(_pages);

@override
Future<void> setNewRoutePath(List<RouteSettings> configuration) {
    debugPrint('setNewRoutePath ${configuration.last.name}');
    _setPath(configuration
             .map((routeSettings) => _createPage(routeSettings))
             .toList());
    return Future.value(null);
}

void _setPath(List<Page> pages) {
    _pages.clear();
    _pages.addAll(pages);

    if (_pages.first.name != '/') {
        // _pages.insert(0, _createPage(const RouteSettings(name: '/')));
    }
    notifyListeners();
}

~~~

注册路由信息解析器

~~~dart
MaterialApp.router(
    routerDelegate: delegate,
    routeInformationParser: const MyRouteInformationParser(),
);
~~~

### 动画

对整体应用变换风格: PageTransitionsTheme

~~~dart
class FadePageTransitionsBuilder extends PageTransitionsBuilder {
  const FadePageTransitionsBuilder();

  @override
  Widget buildTransitions<T>(
    PageRoute<T>? route,
    BuildContext? context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return FadeTransition(
      opacity: animation.drive(CurveTween(curve: Curves.easeIn)),
      child: child,
    );
  }
}


MaterialApp.router(
	theme: ThemeData(
    	pageTransitionsTheme: const PageTransitionsTheme(
        	builder: {
                TragetPlatform.android: FadePageTransitionsBuilder(),
                TargetPlatform.windows: FadePageTransitionsBuilder(),
            }
        )
    )
)
~~~



对单个页面应用变换风格。在路由 1.0 中，我们介绍过通过 Route 对路由添加动画。在 2.0 中，通过 `CustomTransitionPage`的 `transitionsBuilder`参数来指定路由动画：

~~~dart
CustomTransitionPage(
    child: SecondPage(),
    transitionsBuilder: (BuildContext context,
                         Animation<double> animation,
                         Animation<double> secondaryAnimation,
                         Widget child) {
        return SlideTransition(
            position: Tween<Offset>(
                begin: Offset(1.0, 0.0),
                end: Offset.zero,
            ).animate(animation),
            child: child,
        );
    },
)
~~~



## 异步

在`Dart`中，实际上有两种队列：

1. 事件队列(`event queue`)，包含所有的外来事件：`I/O`、`mouse events`、`drawing events`、`timers`、`isolate`之间的信息传递。
2. 微任务队列(`microtask queue`)，表示一个短时间内就会完成的异步任务。

![img](assets/213b91da096242649e0bf6fbf22065f2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

xxxxxxxxxx5 1String? selectedDirectory = await FilePicker.platform.getDirectoryPath();2​3if (selectedDirectory == null) {4  // User canceled the picker5}dart

~~~dart
scheduleMicrotask(() => print('microtask1'));
Future.microtask(() => print('microtask2'));
~~~

向event队列中添加任务

~~~dart
Future(() => print('event task'));
~~~

正常情况下，一个 `Future` 异步任务的执行是相对简单的：

1. 声明一个 `Future` 时，`Dart` 会将异步任务的函数执行体放入`event queue`，然后立即返回，后续的代码继续同步执行。
2. 当同步执行的代码执行完毕后，`event queue`会按照加入`event queue`的顺序（即声明顺序），依次取出事件。

### Future

Dart语言选择使用 Future 类型并配合 async 、await 关键字实现异步支持。Future有三种状态：uncompleted（未完成）、completed with data、completed with error

~~~dart
Future<String> mockGetName = Future.delayed(
    Duration(seconds:2),
    () => "Alice"
)
~~~



由于 Future 是单线程模型，因此并没有取消 Future 的函数。好在官方提供了 timeout 函数：

~~~dart
void testFuture() async {
    new Future
        .delayed(new Duration(seconds: 2), () {
      		return 1;
    	})
        .timeout(new Duration(seconds:1))
        .then(print)
        .catchError(print);
}
testFuture();
  
print("在testFuture()执行之后打印。");
~~~





### FutureBuilder

FutureBuilder是一个可以自动追踪Future的状态并在其状态改变时自动重绘的组件。

~~~dart
FutureBuilder({
  this.future,
  this.initialData,
  required this.builder,
})
~~~

- `future`：`FutureBuilder`依赖的`Future`，通常是一个异步耗时任务。

- `initialData`：在Future尚未完成之前，initialData属性可提供一个数据的“初始值”供FutureBuilder组件暂时使用。可以通过builder回调函数中的snapshot.data来访问。

  在有初始值的情况下，Future完成前的AsyncSnapshot的hasData会返回值true，此时AsyncSnapshot中的ConnectionState也依然会（正确地）是waiting等候状态，而不是done完成状态。

  Future以异常完成，那么AsyncSnapshot的data属性也会将先前的initialData清空为null，只有error属性保存错误信息。

- `builder`：Widget构建器；该构建器会在`Future`执行的不同阶段被多次调用

  ~~~dart
  Function (BuildContext context, AsyncSnapshot snapshot) 
  ~~~

  `snapshot`会包含当前异步任务的状态信息及结果信息

  - ConnectionState属性描述了Future的状态
    - none：none 状态表示没有追踪 Future，在 future 属性为 null 时出现
    - waiting：等待中。
    - active：在Stream中出现，在 Future 中不使用该属性
    - done：已经完成，可以获取数据或者异常
  - data属性：Future的数据。
  - error属性：Future的异常
  - hasData布尔属性
  - hasError布尔属性



这里有个问题，如果 FutureBuilder 组件销毁时， Future 对象还在等待中，那么当Future对象执行完成后，将会遇到异常。我们可以通过 async 包中的 CancelableOperation 对象来解决这个问题。

~~~dart
class _ServerAddLoadingState extends State<_ServerAddLoadingWidget> {
  late CancelableOperation operation;

  @override
  void initState() {
    final future = Config.defaultHttpClient
        .get("${Config.serverAddress}/configuration/${widget.proxyID}")
        .timeout(Duration(seconds: Config.networkTimeout));
    operation = CancelableOperation.fromFuture(future);
  }

  @override
  void dispose() {
    // 当 Widget 销毁时，取消操作
    operation.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder(
      future: operation.value,
      builder: (context, snapshot) {
        Widget widget;
        return widget;
      },
    );
  }
}
~~~



### Stream

`Stream`不同于`Future`，它可以在生命周期内释放出任意数量的数据值（正常）或错误信息（异常）。通过`StreamController().stream`获取`Stream`，该流只允许一个监听者，但是可以缓存数据。`StreamController.broadcast().stream`创建一个广播数据流，它允许多个监听者，但是并不缓存数据。

~~~dart
Stream<State> stream = StreamController.broadcast().stream;

StreamBuilder({stream : stream, builder : ...});
stream.add('11');		//发送消息
~~~



### StreamBuilder

`StreamBuilder`对`Stream`对象进行了封装，可以自动跟踪`Stream`（数据流或事件流）的状态，并在`Stream`有变化时自行重构组件。

```dart
StreamBuilder({
  this.initialData,
  Stream<T> stream,
  required this.builder,
}) 
```

- builder：与FutureBuilder中的builder属性类似。但是ConnectionState属性的含义有些不同
  - active则表示Stream当前活跃，可随时释放若干个数据或异常
  - done，表示Stream已经关闭，不再释放任何数据或异常。

### Timer

定时器在Flutter框架中的使用：

~~~dart
class _ImageSliderState extends State<ImageSlider>{
    late Timer timer;
    @override
    void initState() {
        timer = Timer(...)
    }
    
    @override
    void dispose() {
        timer.cancel();
	}
}
~~~



定时执行任务

~~~dart
timer = Timer.periodic(Duration(milliseconds: 5000), (timer) {
      
});
~~~



## ValueListenableBuilder

ValueListenableBuilder 组件用于监听一个数据源，如果数据源发生变化，则会重新执行其 builder

~~~dart
const ValueListenableBuilder({
  Key? key,
  required this.valueListenable, // 数据源，类型为ValueNotifier<T>
   
  required this.builder, // builder
  this.child,
}
~~~

- builder：数据源发生变化通知时，会重新调用 builder 重新 build 子组件树。

## InheritedWidget

我们来自定义一个 InheritedWidget

~~~dart
class ShareDataWidget extends InheritedWidget {
  ShareDataWidget({
    Key? key,
    required this.data,
    required Widget child,
  }) : super(key: key, child: child);

  final int data; // 需要在子树中共享的数据，保存点击次数

  // 一般通过 of 来注册依赖关系
  static ShareDataWidget? of(BuildContext context) {
    return context.dependOnInheritedWidgetOfExactType<ShareDataWidget>();
  }

  // 当 ShareDataWidget 被 rebuild 后，通过 updateShouldNotify 来决定是否 rebuild 依赖的组件
  @override
  bool updateShouldNotify(ShareDataWidget old) {
    return old.data != data;
  }
}
~~~

