# Layout

[TOC]

**组件（Widget）**是Flutter框架的基石。Flutter作为现代的UI框架，是从React框架获得灵感，即通过定义一个个相对独立的小组件，再利用组件与组件之间的嵌套与配合，逐步搭建出复杂的用户界面。

在Flutter框架中，组件**不可变（immutable）**，即一旦组件被创建就不可以再修改其中的内容。因此每当程序内部数据发生改变或因动画效果而导致用户界面需要更新时，所有涉及的组件都会被摧毁并重制。Flutter框架对组件摧毁和重制的过程优化到极致，所以并不需要过度担心性能问题。

Flutter框架中的尺寸或位置信息，例如高度、宽度等，一般都以**逻辑像素**作为单位。由于每个物理像素的规格不同。运行时，Flutter程序会根据当前的设备信息自动提供逻辑像素到物理像素的转换，最终提供统一的“每38像素约为1cm”的接口。这样开发者在处理页面布局时，就不需要考虑不同设备屏幕的像素密度问题了。

 ## 布局原理 & 约束

Flutter 中有两种布局模型：

- 基于 **RenderBox** 的盒模型布局：2D 绘制布局
- 基于 **Sliver ( RenderSliver )** 按需加载列表布局：滚动布局



这两种模型的布局流程如下：

1. 父Widget向其传递约束
2. Widget向子级传递约束。这个约束值是可以根据其他因素重新计算出来的。只要符合布局语义，任何计算策略都是可以接受的。
3. 子级将所需的大小回传给Widget。Widget的大小由以下三个因素来决定：
   - 父级约束
   - 子组件的大小
   - 相关参数（mainAxisSize、height、width等）
4. 然后Widget 就会对子Widget逐个进行布局。如果子Widget溢出，可以将其直接裁剪掉，或者直接绘制出来。
5. Widget 将会把它的大小信息向上传递至父 widget



约束包括但不限于以下几种类型：

- **紧约束（Tight Constraint）**：最小约束与最大约束相等
- **松约束（Loose Constraint）**：某个约束的最小值为0。
- **无边界（unbounded）**：某个约束的最大值为正无穷`double.infinity`



**在任何时候，子组件都必须先遵守父组件的约束**。也就是说，当子组件的期望大小不满足约束时，那么必须将大小设置为约束的范围内（通常是临界值处）。



~~~dart
Row(
  children: [TextField()],
  //TextField会尽可能的大，但是Row给它一个[0, double.infinity)约束。因此TextField选择抛出异常并不渲染。大部分组件对此情景的解决方法是尽可能的小。
)
~~~



这是所有Widget对于布局的假设，在自己自定义布局时，一定要满足这条不变式。但是要注意的是，**这个不变式仅仅在父子之间成立**。假设有一个A，它的子组件是B，B 的子组件是C。当B向C传递约束时，可以将A的约束考虑进来，与自身约束一起，计算出一个新的约束传递给C。下面来看两个例子：

~~~dart
ConstrainedBox(
  constraints: BoxConstraints(minWidth: 60.0, minHeight: 60.0), //父
  child: ConstrainedBox(
    constraints: BoxConstraints(minWidth: 90.0, minHeight: 20.0),//子
    child: redBox,
  ),
)
~~~

此时，redBox的最终显示效果是宽90，高60。而

~~~dart
UnconstrainedBox(
  alignment: Alignment.topLeft,
  child: Padding(
    padding: const EdgeInsets.all(16),
    child: Row(children: [Text('xx' * 100)]),
  ),
),
~~~

直接就溢出：

![图4-8](assets/4-8.cf2d7176.png)

第一个例子就是将父约束考虑进来，而第二次例子直接将父约束忽略掉，而是传递一个无约束给子Widget。**只要符合布局语义，任何计算策略都是可以接受的**。





## Layout Widget

### Column & Row

~~~dart
Row({
  ...  
  TextDirection 		textDirection,    									//子组件的布局顺序(是从左往右还是从右往左)
  MainAxisSize 			mainAxisSize = MainAxisSize.max,    				//在主轴(水平)方向占用的空间
  MainAxisAlignment 	mainAxisAlignment = MainAxisAlignment.start,		
  VerticalDirection 	verticalDirection = VerticalDirection.down,  
  CrossAxisAlignment 	crossAxisAlignment = CrossAxisAlignment.center,
  List<Widget> 			children = const <Widget>[],
})
~~~

- MainAxisAlignment：只有当`mainAxisSize`的值为`MainAxisSize.max`时，此属性才有意义。

  - start、end、center
  - spaceBetween：在相邻的子组件之间插入空白，但不在第一个和最后一个子组件外围插入留白
  - spaceEvenly：在子组件周围统一插入留白
  - spaceAround：在相邻的子组件之间插入留白，并在第一个和最后一个子组件外围插入一半的留白

- CrossAxisAlignment

  - start、end、center
  - stretch：Row或者Column控件在副轴上尽量扩展到父组件的最大约束，同时将紧约束传递给子组件
  - baseline：按组件文字的基准线对齐

- mainAxisSize：

  - MainAxisSize.max：表示尽可能多的占用主轴方向的空间
  - MainAxisSize.min：表示尽可能少的占用主轴空间。例如，当Row的子组件没有占满水平剩余空间，则`Row`的实际宽度等于所有子组件占用的水平空间；

  

Column & Row组件在主轴大小，取决于父级约束、children的总尺寸，以及mainAxisSize属性。而它们的副轴大小，取决于他们所有子元素在副轴方向上的最大大小、CrossAxisAlignment、父级约束。

注意，由于Column & Row在主轴方向上给子组件传递的是无约束，此时要小心溢出的情况。在副轴上直接传递`[0, 父约束的最大值]`。

如果`Row`里面嵌套`Row`，或者`Column`里面再嵌套`Column`，那么只有最外面的`Row`或`Column`会占用尽可能大的空间，里面`Row`或`Column`主轴所占用的空间为MainAxisSize.min。如果不这么做，其他元素将会被挤出去。



### Wrap

Wrap的行为与Row类似，但是如果一个元素在主轴放不下时，那么Wrap为其自动换行。Wrap尽可能地匹配所有子组件布局后的总尺寸。

```dart
Wrap({
  ...
  this.direction = Axis.horizontal,
  this.alignment = WrapAlignment.start,
  this.spacing = 0.0,
  this.runAlignment = WrapAlignment.start,
  this.runSpacing = 0.0,
  this.crossAxisAlignment = WrapCrossAlignment.start,
  List<Widget> children = const <Widget>[],
})
```

- `direction`：确定主轴的方向

- `spacing`：主轴方向子widget的间距

- `runSpacing`：纵轴方向的间距

- `runAlignment`：它是控制多个副轴的对齐，而crossAxisAlignment控制的是一个副轴上多个元素的对齐。此外crossAxisAlignment在此不能使用`stretch`参数

- `alignment`：

  ![img](assets/nr3fkw7t4w.jpeg)



### Stack & Positioned

层叠布局和 Web中的绝对定位是相似的。Flutter中使用`Stack`和`Positioned`这两个组件来配合实现绝对定位。`Stack`允许子组件堆叠，而`Positioned`用于根据`Stack`的四个角来确定子组件的位置。



Stack里的子组件在布局时会被分为“有位置”和“无位置”这2大类，而其中“有位置”特指被Positioned包裹的子组件。

```dart
Stack({
  this.alignment = AlignmentDirectional.topStart,
  this.fit = StackFit.loose,
  this.clipBehavior = Clip.hardEdge,
  List<Widget> children = const <Widget>[],
})
```

- `clipBehavior`：决定对超出`Stack`显示空间的部分如何剪裁。
  - Clip.hardEdge 表示直接剪裁，不应用抗锯齿。
  - Clip. none，要求不裁剪
- `fit`：控制Stack如何将自己的父级组件的尺寸约束传达给“无位置”的子组件。
  - StackFit. loose（宽松，默认值）：Stack可以允许其children在不违背父级最大约束（maxHeight、maxWidth）的前提下，自由选择尺寸
  - StackFit.expand（扩张）：要求所有“无位置”的children必须占满父级约束的最大空间
  - StackFit.passthrough（穿透）：Stack会将自己父级组件的尺寸约束直接传给子组件
- `alignment`：对于以下两种子Widget，会应用该属性：
  - “无位置”Widget，子组件的尺寸小于Stack本身
  - “有位置”Widget，但并未设置水平或垂直方向的对齐方式，此时，未设置的方向会应用alignment属性



Stack的布局算法

1. Stack首先会找到所有“无位置”的子组件，并向它们传入fit属性所设置的布局约束
2. 在得到全部“无位置”子组件所确定的最终尺寸后，Stack会把自身尺寸匹配到其中最大的子组件的尺寸
3. 再把子组件按照alignment属性设置的对齐方式摆放。默认为左上角
4. 如果Stack里不存在“无位置”的子组件，则Stack会尽量将自身尺寸设置为父级布局约束所允许的最大尺寸。

Stack在渲染时，会按照children属性里的列表顺序，依次绘制子组件并覆盖叠放。因此列表里第一个组件会首先被绘制，于是出现在最底层。

```dart
const Positioned({
  Key? key,
  this.left, 
  this.top,
  this.right,
  this.bottom,
  this.width,
  this.height,
  required Widget child,
})
```

同一维度的3个属性（横轴left、right、width属性，以及纵轴top、bottom、height属性）最多只可以传入2个，否则会产生运行时错误。



### Align

~~~dart
Align({
  Key key,
  this.alignment = Alignment.center,
  this.widthFactor,
  this.heightFactor,
  Widget child,
})
~~~

- alignment：它有两个常用的子类：`Alignment`和 `FractionalOffset`（不推荐）。
- `widthFactor`和`heightFactor`：它们是两个缩放因子，会分别乘以子组件的宽、高得到该组件期望的宽高。再结合父约束，确定`Align` 组件的最后布局的宽高。

在不设置widthFactor与heightFactor的情况下，Align组件的自身尺寸会尽量占满父级最大约束。如果在此情况下，父级传递了一个无约束，那么它会尽可能地小！



### Center

Center是Align的一个特例！

~~~dart
class Center extends Align { 
    const Center({
        double widthFactor,
        double heightFactor, 
        Widget child
    }) : super(widthFactor:widthFactor,heightFactor: heightFactor, child: child); 
}
~~~



### Flex & Expanded

实际上，Row和Column组件都继承于Flex组件。Flex与Row唯一不同的地方就是direction属性

~~~dart
Flex({
  ...
  required this.direction, //弹性布局的方向, Row默认为水平方向，Column默认为垂直方向
  List<Widget> children = const <Widget>[],
})
~~~



Expanded 只能作为 Flex 的孩子（包括Row、Column），否则会报错。它可以按比例“扩伸”`Flex`子组件所占用的空间。Flex会首先将固定尺寸的普通组件摆放到位，再计算剩余空间，最后分配给不固定尺寸的“弹性”组件。

~~~dart
const Expanded({
  int flex = 1, 
  required Widget child,
})
~~~

`flex`参数为弹性系数，默认为`1`。如果为` 0` 或`null`，则`child`是没有弹性的，应被当作普通的固定尺寸的子组件处理。其余情况下，它会被当作有弹性的组件，将按照flex属性的权重，参与Flex空闲空间的分配。



Flexible是Expanded组件的父类，主要作用也是用于“扩张”Flex中的部分组件，使它们占满全部空间。与Expanded组件不同的是，Flexible还可以通过fit属性设置其child是否必须占满Flexible为其扩张出的空间。fit属性值如下：

- `FlexFit.tight`：强制约束子组件的尺寸必须为Flexible分配的尺寸，与Expanded组件效果完全一致
- `FlexFit.loose`：允许子组件的尺寸小于或等于所分配的尺寸。此时，若某些子组件真的选择渲染更小的尺寸，则它们节约出的多余空间也不会再被分配给其他组件。





~~~dart
Row(children: [
    Flexible(flex: 5),
    Expanded(flex: 1),
    Expanded(flex: 1),
])
~~~

![image-20230913195642031](assets/image-20230913195642031.png)



Spacer是一个用于在Flex中弹性留白的组件。它没有child参数，但有flex参数，用于表示该组件相对于其他弹性组件的“弹性权重”。

~~~dart
Row(children: [
    Spacer(flex:5 ),
    Expanded(flex: 1),
    Expanded(flex: 1),
])
~~~

![image-20230913195811722](assets/image-20230913195811722.png)

### LayoutBuilder

通过 LayoutBuilder，我们可以在**布局过程**中拿到父组件传递的约束信息，然后我们可以根据约束信息动态的构建不同的布局。

~~~dart
LayoutBuidler(
	bhilder: (BuildContext context, BoxConstraints constraints) {
        if (constraints.maxWidth < 200) {
            
        } else {
            
        }
    }
)
~~~

## Constraints Widget

除了下面介绍的这些常用的尺寸限制类容器外，还有一些其他的尺寸限制类容器，比如`AspectRatio`，它可以指定子组件的长宽比、`LimitedBox` 用于指定最大宽高、`FractionallySizedBox` 可以根据父容器宽高的百分比来设置子组件宽高等

### UnconstrainedBox

通过UnconstrainedBox，可以去除掉父约束的限制，即向子组件传递$[0, double.infinite)$约束。在debug模式下，如果UnconstrainedBox下的子组件大小超过其祖父组件约束时，会导致溢出报错。

### ConstrainedBox

`ConstrainedBox`在满足父约束的前提下，对子组件添加额外的约束。它的尺寸会尽量匹配子Widget的尺寸。如果孩子为空，那么ConstrainedBox的大小则根据自身约束与父约束来设置。



### SizedBox

实际上，SizeBox是ConstrainedBox的一个特例：

~~~java
SizedBox(
  width: 80.0,
  height: 80.0,
  child: ...
)
    
ConstrainedBox(
  constraints: BoxConstraints.tightFor(width: 80.0,height: 80.0),
  child: ...
)
~~~

如果未设置height或者width，那么默认是父约束的最大值。

### LimitedBox

~~~dart
LimitedBox(
	maxHeight : 100,
    child : ...
)
~~~

maxHeight属性指遇到父级约束无边界时，子组件应采用的高度。并不会妨碍其child选择一个高于LimitedBox的maxHeight，但不违反父级约束的值。

### FractionallySizedBox

FractionallySizedBox尽可能地扩展到父组件的最大约束上。FractionallySizedBox可将父级约束乘以一个倍数，所得到的结果再以紧约束传递给子组件。一般用来实现“相对尺寸”。当倍数大于1时，可以打破父组件的约束。

此外还可以通过alignment属性设置子组件的对齐方式。

## 容器类Widget

### Padding

`Padding`可以给其子节点添加填充（留白）

~~~dart
Padding({
  ...
  EdgeInsetsGeometry padding,
  Widget child,
})
~~~

`EdgeInsetsGeometry`是一个抽象类，开发中，我们一般都使用`EdgeInsets`类

我们看看`EdgeInsets`提供的便捷方法：

- `fromLTRB(double left, double top, double right, double bottom)`：分别指定四个方向的填充。
- `all(double value)` : 所有方向均使用相同数值的填充。
- `only({left, top, right ,bottom })`：可以设置具体某个方向的填充(可以同时指定多个方向)。
- `symmetric({ vertical, horizontal })`：用于设置对称方向的填充，`vertical`指`top`和`bottom`，`horizontal`指`left`和`right`。

### SafeArea

SafeArea组件可以保证子组件不会被渲染到屏幕缺陷位置内。

~~~dart
const SafeArea({
  //...
	this.minimum = EdgeInsets.zero,
	required this.child,
});
~~~

- `minimum`：当屏幕无缺陷，或缺陷的尺寸小于最小留白尺寸时就会被采用。



### Transform

`Transform`可以**在其子组件绘制时**，对其应用一些矩阵变换。`Transform`的变换是应用在绘制阶段，而并不是应用在布局阶段。并且任何一个3D变换都可以用4*4矩阵来表达。

> 关于矩阵变换的相关内容属于线性代数范畴，在此不做讨论。



`Transform.translate`接收一个`offset`参数，可以在绘制时沿`x`、`y`轴对子组件平移指定的距离。

`Transform.rotate`可以对子组件进行旋转变换

`Transform.scale`可以对子组件进行缩小或放大



~~~dart
Transform.scale(
    scale: 1.5, 			//放大到1.5倍
    child: Text("Hello world")
);

Transform.rotate(
    angle:math.pi/2 ,		//旋转90度
    child: Text("Hello world"),
);

Transform.translate(
    offset: Offset(-20.0, -5.0),	//平移
    child: Text("Hello world"),
);
~~~

### RotatedBox

`RotatedBox`和`Transform.rotate`功能相似，它们都可以对子组件进行旋转变换，但是有一点不同：`RotatedBox`的变换是在layout阶段，会影响在子组件的位置和大小。

```dart
RotatedBox(
    quarterTurns: 1, //旋转90度(1/4圈)
    child: Text("Hello world"),
),
```

### Clip

Flutter中提供了一些剪裁组件，用于对组件进行剪裁。剪裁是在绘制阶段进行，而不是在layout阶段进行。

| 剪裁Widget | 默认行为                                                 |
| ---------- | -------------------------------------------------------- |
| ClipOval   | 子组件为正方形时剪裁成内贴圆形；为矩形时，剪裁成内贴椭圆 |
| ClipRRect  | 将子组件剪裁为圆角矩形                                   |
| ClipRect   | 默认剪裁掉子组件布局空间之外的绘制内容（溢出部分剪裁）   |
| ClipPath   | 按照自定义的路径剪裁                                     |



ClipPath的clipper属性接受一个`CustomClipper`类型的对象。

~~~dart
abstract class CustomClipper<T> extends Listenable {
  T getClip(Size size);
  bool shouldReclip(covariant CustomClipper<T> oldClipper);
}
~~~



### FittedBox

会尽量扩展到父组件的最大约束尺寸

```dart
const FittedBox({
  Key? key,
  this.fit = BoxFit.contain, // 适配方式
  this.alignment = Alignment.center, //对齐方式
  this.clipBehavior = Clip.none, //是否剪裁
  Widget? child,
})
```

FittedBox在布局子组件时会忽略其父组件传递的约束，而传递给子组件的约束为无边界（0<=width<=double.infinity, 0<= height <=double.infinity）。在获取子组件的真实大小后，根据fit属性来对子组件进行渲染！（注意，不是布局）



fit属性值如下：

- BoxFit. contain（默认值）
- BoxFit.fill
- BoxFit.cover
- BoxFit.fitHeight
- BoxFit.fitWidth
- BoxFit.none
- BoxFit.scaleDown

具体效果可以参考Image控件的fit属性。

### Container

Container组件是一个结合了定义尺寸、形状、背景颜色、装饰、间距、对齐等多功能于一身的组件。虽然这些功能都有对应的组件，而Container的实现也是利用这些组件。

~~~dart
Container({
  this.alignment,					// 子组件的对齐方式
  this.padding, 					// 内边距
  Color color, 						// 背景色，默认是透明的
  Decoration decoration, 			// 背景装饰。包括形状、阴影、边框、渐变色填充等
  Decoration foregroundDecoration, 	// 前景装饰
  double width,						// 宽度
  double height, 					// 高度
  BoxConstraints constraints, 		// 布局约束
  this.margin,						// 外边距
  this.transform, 					// 变换
  this.child,						// 子组件
  ...
})
~~~

- Alignment(double x, double y)，其中x、y分别对应横轴和纵轴方向的位置，取值范围为[-1.0, 1.0]。左上对齐既可以用Alignment(-1.0, -1.0)，也可以用Alignment.topLeft。

- EdgeInsets. fromLTRB（double left，double top，double right，double bottom）即依次单独设置左、上、右、下这4个方向分别留白多少逻辑像素。EdgeInsets. all（doublevalue）同时设置4个方向的值。EdgeInsets. only（）方法，传入需要设置的方向，省略的方向则自动为0。

  ~~~dart
  EdgeInsets.only(left : 16.0, bottom : 80);
  EdgeInsets.all(16.0)
  EdgeInsets.formLTRB(10, 20, 10, 20);
  ~~~

- transform接收一个4×4的矩阵。三维物体的任意缩放、平移和旋转都可以通过一个4× 4矩阵完成。

Container的布局行为十分复杂：推荐查阅官方文档https://api.flutter.dev/flutter/widgets/Container-class.html

- 没有子组件
  - 根据父级约束、width、height、constraints属性计算约束
  - 如果最终计算出的约束有界，则尽量占满
  - 如果最终计算出的约束无界，则尽量缩小
- 有子组件
  - 根据父级约束、width、height、constraints属性计算出一个紧约束，并传递给子组件
  - 但若提供了alignment属性，则扩大到父组件的最大约束，为对齐child创造条件；
  - 又若某一维度上约束无界，则依然只能尽量匹配child尺寸。



### AspectRatio

布局时AspectRatio会首先试图将子组件占满父级约束的最大宽度，再通过aspectRatio属性推算所需高度。若高度无法满足父级约束，它就会通过高度和比例推算所需宽度。如果宽度无法满足父级约束，则最终会为子组件选择违背aspectRatio但不违背父级约束的尺寸。

另外，当父级宽度约束无边界（unbounded）时，AspectRatio也会直接采用最大高度和比例进行宽度推算。若宽度和高度均无边界，则AspectRatio布局算法无法正常运行。

~~~dart
AspectRatio(
    aspectRatio: 16 / 9,
    child: Container(
      	color: Colors.green,
    ),
),
~~~



### OffStage

~~~dart
Offstage(
  offstage: true,
  child: child
),
~~~

offstage并不是通过插入或者删除widget tree的节点来实现显示隐藏效果，而是不绘制child（child的高度和宽度此时为0）来实现的。此时使用GlobalKey等方式可以获取它的尺寸。

### Visbility

相比较`Offstage`组件，`Visbility`是从widget tree中彻底将其子组件移除，来实现显示隐藏效果的。

~~~dart
const Visibility({
    required this.child,
    this.replacement = const SizedBox.shrink(),
    this.visible = true,
    this.maintainState = false,
    this.maintainAnimation = false,
    this.maintainSize = false,
    this.maintainInteractivity = false,
})
~~~

- `maintainState`：是否需要保持状态。如果不需要保存状态，那么将使用`replacement`参数所指定的`widget`代替该`child`

- `maintainAnimation`：是否保持动画。如果设置为false，Visibility组件会调用TickerMode组件将动画控制器所依赖的ticker关闭。如果要设置为true，那么maintainState必须设置为true。

  如果需要好的用户体验，那么在更改visible属性时，同时调用AnimationController的相关方法。

- `maintainSize`：是否保持尺寸。如果要设置为`true`，那么`maintainAnimation`必须设置为`true`。

- `maintainInteractivity`：是否保持交互。如果要设置为`true`，那么`maintainSize`必须设置为`true`。

### DecoratedBox

~~~dart
const DecoratedBox({
  Decoration decoration,
  DecorationPosition position = DecorationPosition.background,
  Widget? child
})
~~~

- `decoration`：代表将要绘制的装饰，它的类型为`Decoration`。`Decoration`是一个抽象类，它定义了一个接口 `createBoxPainter()`，子类的主要职责是需要通过实现它来创建一个画笔，该画笔用于绘制装饰。
- `position`：此属性决定在哪里绘制`Decoration`
  - `background`：在子组件之后绘制，即背景装饰。
  - `foreground`：在子组件之上绘制，即前景。



`BoxDecoration`类，它是一个Decoration的子类，实现了常用的装饰元素的绘制。

~~~dart
BoxDecoration({
  Color color, //颜色
  DecorationImage image,//图片
  BoxBorder border, //边框
  BorderRadiusGeometry borderRadius, //圆角
  List<BoxShadow> boxShadow, //阴影,可以指定多个
  Gradient gradient, //渐变
  BlendMode backgroundBlendMode, //背景混合模式
  BoxShape shape = BoxShape.rectangle, //形状
})
~~~



### RepaintBoundary

~~~dart
RepaintBoundary(
	child : MyExpensiveWidget(),
)
~~~

Flutter会将RepaintBoundary单独绘制在一个新图层上。这样当其他图层平移（如被嵌入于滚动列表中）或缩放（如受到Transform组件影响）时，Flutter就可以直接移动或缩放整个图层，而不再需要重新绘制它的内容了。

实际上，Flutter框架中不少组件已经自动添加了RepaintBoundary以提升性能。实战中，需要开发者手动添加RepaintBoundary的控件一般是CustomPaint等。

此外，RepaintBoundary对象的toImage方法可以输出图层数据。



### Flow

`Flow`是一个对子组件尺寸以及位置调整非常高效的控件。

~~~dart
Flow(
  delegate : MyDelegate(),
  children: [
    FlutterLogo(size : 48),
    FlutterLogo(size : 48),
  ],
);


class MyDelegate extends FlowDelegate {
    
  //接收父组件的约束，然后向父组件报告自身大小
  @override
  Size getSize(BoxConstraints constraints) {
    return constraints.biggest;
  }

  @override
  BoxConstraints getConstraintsForChild(int i, BoxConstraints constraints) {
    //默认情况下会直接将Flow的父级约束转达给自己的每个子组件
    return super.getConstraintsForChild(i, constraints);
  }

  @override
  void paintChildren(FlowPaintingContext context) {
    final size0 = context.getChildSize(0)!;
    final size1 = context.getChildSize(1)!;

    //直接绘制该子组件
    context.paintChild(0);
      
    //使用transform代替子组件的布局
    context.paintChild(1,
      transform : Matrix4.identity()
        ..translate(size0.width, size0.height)
        ..rotateZ(3.14 / 4)
        ..scale(2.0),

      opacity: .5,
    );
  }

  @override
  bool shouldRepaint(_) => false;
}
~~~



### CustomPaint

在Flutter中，提供了一个`CustomPaint` 组件，它可以结合画笔`CustomPainter`来实现自定义图形绘制。

`CustomPaint`构造函数：

~~~dart
CustomPaint({
  Key key,
  this.painter, 
  this.foregroundPainter,
  this.size = Size.zero, 
  this.isComplex = false, 
  this.willChange = false, 
  Widget child, //子节点，可以为空
})
~~~

- `painter`: 背景画笔，会显示在子节点后面;
- `foregroundPainter`: 前景画笔，会显示在子节点前面
- `size`：当child为null时，画布尺寸为size属性所设置的数值。如果有child则忽略此参数，画布尺寸为child尺寸。
- `isComplex`：是否复杂的绘制，如果是，Flutter会应用一些缓存策略来减少重复渲染的开销。
- `willChange`：和`isComplex`配合使用，当启用缓存时，该属性代表在下一帧中绘制是否会改变。



painter属性是一个CustomPainter类型，而`CustomPainter`中定义了一个虚函数`paint`：

~~~dart
void paint(Canvas canvas, Size size);
~~~

- `Canvas`：一个画布，包括各种绘制方法。

  我们列出一下常用的方法：

  | API名称    | 功能   |
  | ---------- | ------ |
  | drawLine   | 画线   |
  | drawPoint  | 画点   |
  | drawPath   | 画路径 |
  | drawImage  | 画图像 |
  | drawRect   | 画矩形 |
  | drawCircle | 画圆   |
  | drawOval   | 画椭圆 |
  | drawArc    | 画圆弧 |

- `Size`：当前绘制区域大小。



现在画布有了，我们最后还缺一个画笔，Flutter提供了`Paint`类来实现画笔。在`Paint`中，我们可以配置画笔的各种属性如粗细、颜色、样式等

~~~dart
var paint = Paint() 			//创建一个画笔并配置其属性
  ..isAntiAlias = true 			//是否抗锯齿
  ..style = PaintingStyle.fill 	//画笔样式：填充
  ..color=Color(0x77cdb175);	//画笔颜色
~~~

而上述介绍的Canvas对象的绘制方法用于控制画笔的走向。

~~~dart
var paint = Paint()
    ..style = PaintingStyle.fill
    ..color = Colors.black;

canvas.drawCircle(
    
    Offset(rect.center.dx - eWidth / 2, rect.center.dy - eHeight / 2),	//设置圆心
    min(eWidth / 2, eHeight / 2) - 2,									//设置半径
    paint,																//设置画笔
);
~~~



绘制是比较昂贵的操作，所以我们在实现自绘控件时应该考虑到性能开销，下面是两条关于性能优化的建议：

- 尽可能的利用好`shouldRepaint`返回值；在UI树重新build时，控件在绘制前都会先调用该方法以确定是否有必要重绘；假如我们绘制的UI不依赖外部状态，即外部状态改变不会影响我们的UI外观，那么就应该返回`false`；如果绘制依赖外部状态，那么我们就应该在`shouldRepaint`中判断依赖的状态是否改变，如果已改变则应返回`true`来重绘，反之则应返回`false`不需要重绘。
- 绘制尽可能多的分层。
- 使用`RepaintBoundary`控件
