# 创建型模式

设计模式中的核心思想：**将变化的事物与保持不变的事物分离**。大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导的。

[TOC]

## 单例

**单例设计模式**（Singleton Design Pattern）：一个类只允许创建一个对象（或者实例）。

### 案例

在这个例子中,实现了一个往文件中打印日志的Logger类：

~~~java
public class Logger {
  private FileWriter writer;
  
  public Logger() {
    File file = new File("/Users/wangzheng/log.txt");
    writer = new FileWriter(file, true); //true表示追加写入
  }
  
  public void log(String message) {
    writer.write(message);
  }
}

// Logger类的应用示例：
public class UserController {
  private Logger logger = new Logger();
  
  public void login(String username, String password) {
    // ...省略业务逻辑代码...
    logger.log(username + " logined!");
  }
}

public class OrderController {
  private Logger logger = new Logger();
  
  public void create(OrderVo order) {
    // ...省略业务逻辑代码...
    logger.log("Created an order: " + order.toString());
  }
}

~~~

如果我们忽略FileWriter是线程安全的事实，那么Logger是有着数据竞争的风险。避免这种风险的方案有多种：

- 类级别锁`synchronized(Logger.class)`
- 高性能的分布式锁
- 并发队列`BlockingQueue`
- 单例模式



这里我们来看看单例模式是如何解决的吧。单例模式相对于类级别锁的优势是

- 节省内存空间，不用为每个对象创建Logger对象
- 节省系统文件句柄

~~~java
public class Logger {
  private FileWriter writer;
  private static final Logger instance = new Logger();

  private Logger() {
    File file = new File("/Users/wangzheng/log.txt");
    writer = new FileWriter(file, true); //true表示追加写入
  }
  
  public static Logger getInstance() {
    return instance;
  }
  
  public void log(String message) {
    writer.write(mesasge);
  }
}

// Logger类的应用示例：
public class UserController {
  public void login(String username, String password) {
    // ...省略业务逻辑代码...
    Logger.getInstance().log(username + " logined!");
  }
}

public class OrderController {  
  public void create(OrderVo order) {
    // ...省略业务逻辑代码...
    Logger.getInstance().log("Created a order: " + order.toString());
  }
}
~~~



从业务概念上，如果有些数据在系统中只应保存一份且需求不会再变更，那就比较适合设计为单例类。比如，配置信息类。



### 如何实现一个单例？

基本思想就是将单例实例声明为静态的，这样就有全局语义了。然后再提供方法来访问它即可。

#### 饿汉式

在类加载的时候，将静态实例初始化。初始化的过程是线程安全的。不过这种方式不支持延迟加载。

~~~java
public class IdGenerator { 
  private AtomicLong id = new AtomicLong(0);
  private static final IdGenerator instance = new IdGenerator();		//饿汉式
    
  private IdGenerator() {}
  public static IdGenerator getInstance() {
    return instance;
  }
  public long getId() { 
    return id.incrementAndGet();
  }
}

~~~

有些人认为当实例占用资源多或者初始化耗时长时，提前初始化实例是一种浪费资源的行为。最好的方法是延迟加载。我个人并不认同这样的观点，原因如下：

- 采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成。这样就能避免在程序运行的时候，再去初始化而导致性能问题。比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时。
- 如果实例占用资源多，按照fail-fast的设计原则（有问题及早暴露），那应该在程序启动时就初始化实例，如果此时资源不够，那么就会在启动的阶段触发报错。而不是等到程序运行后再触发OOM，导致系统崩溃，而影响系统的可用性。

#### 懒汉式

~~~java
public class IdGenerator { 
  private AtomicLong id = new AtomicLong(0);
  private static IdGenerator instance;			//懒汉式
  private IdGenerator() {}
    
  //饿汉式
  public static synchronized IdGenerator getInstance() {
    if (instance == null) {
      instance = new IdGenerator();
    }
    return instance;
  }
    
  public long getId() { 
    return id.incrementAndGet();
  }
}

~~~

这把锁是有必要的，但这会导致该方法的并发度很低，存在性能问题。

#### 双重检测

饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。而双重检测方式既支持延迟加载、又支持高并发的单例

~~~java
public class IdGenerator { 
  private AtomicLong id = new AtomicLong(0);
  private static IdGenerator instance;		//双重检测
  private IdGenerator() {}
  public static IdGenerator getInstance() {
    if (instance == null) {
      synchronized(IdGenerator.class) { // 此处为类级别的锁
        if (instance == null) {
          instance = new IdGenerator();
        }
      }
    }
    return instance;
  }
  public long getId() { 
    return id.incrementAndGet();
  }
}
~~~

事实上，由于指令重排序，可能会导致一些线程安全的问题（详情见Java 多线程的笔记）。实际上，只有很低版本的Java才会有这个问题。我们现在用的高版本的Java已经在JDK内部实现中解决了这个问题。解决的方法很简单，只要把对象new操作和初始化操作设计为原子操作即可。

#### 静态内部类

还有一种比双重检测更加简单的实现方法，那就是Java的静态内部类

~~~java
public class IdGenerator { 
  private AtomicLong id = new AtomicLong(0);
  private IdGenerator() {}

  private static class SingletonHolder{
    private static final IdGenerator instance = new IdGenerator();
  }
  
  public static IdGenerator getInstance() {
    return SingletonHolder.instance;
  }
 
  public long getId() { 
    return id.incrementAndGet();
  }
}
~~~

由JVM来保证创建实例创建的线程安全性和实例的唯一性

#### 枚举

~~~java
public enum IdGenerator {
  INSTANCE;
  private AtomicLong id = new AtomicLong(0);
 
  public long getId() { 
    return id.incrementAndGet();
  }
}
~~~

### 存在的问题

单例存在哪些问题？

*   **对代码的扩展性不友好**

    ~~~java
    public class Order {
      public void create(...) {
        //...
        long id = IdGenerator.getInstance().getId();
        //...
      }
    }
    
    public class User {
      public void create(...) {
        // ...
        long id = IdGenerator.getInstance().getId();
        //...
      }
    }
    ~~~

    IdGenerator的使用方式违背了基于接口而非实现的设计原则，也就违背了OOP的抽象特性。如果未来需求发生变更，即用不同的ID生成算法，那么我们需要修改所有用到IdGenerator类的地方。这样代码的改动就会比较大，而基于接口编程的改动范围就比较小。

    ~~~java
    public class Order {
      public void create(...) {
        //...
    -    long id = IdGenerator.getInstance().getId();
    +    long id = OrderIdGenerator.getIntance().getId();
        //...
      }
    }
    
    public class User {
      public void create(...) {
        // ...
    -    long id = IdGenerator.getInstance().getId();
    +    long id = UserIdGenerator.getIntance().getId();
      }
    }
    ~~~

    所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性。

    

    而且如果将来需求变更为在代码中创建两个实例或多个实例。那么单例类显然就无法适应这样的需求变更，然后就要大刀阔斧地重构代码。

    

*   **会隐藏类之间的依赖关系**

    在阅读代码的时候，我们希望一眼就能看出类与类之间的依赖关系。通过查看函数定义中的参数列表，就能很容易识别出来依赖关系。但是，单例类不需要不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。

    

*   **对代码的可测试性不友好**

    

即使单例类有这么多的问题，但是如果单例类并没有后续扩展的需求，以及不依赖外部系统（可测试性方面），那设计成单例类就没有太大问题。



单例类有以下几个方法，来支持有参数的“构造函数”。

-  init()：

  ~~~java
  public class Singleton {
    private static Singleton instance = null;
    private final int paramA;
    private final int paramB;
  
    private Singleton(int paramA, int paramB) {
      this.paramA = paramA;
      this.paramB = paramB;
    }
  
    public static Singleton getInstance() {
      if (instance == null) {
         throw new RuntimeException("Run init() first.");
      }
      return instance;
    }
  
    public synchronized static Singleton init(int paramA, int paramB) {
      if (instance != null){
         throw new RuntimeException("Singleton has been created!");
      }
      instance = new Singleton(paramA, paramB);
      return instance;
    }
  }
  
  Singleton.init(10, 50); // 先init，再使用
  Singleton singleton = Singleton.getInstance();
  ~~~

- getIntance()

  ~~~java
  public class Singleton {
    private static Singleton instance = null;
    private final int paramA;
    private final int paramB;
  
    private Singleton(int paramA, int paramB) {
      this.paramA = paramA;
      this.paramB = paramB;
    }
  
    public synchronized static Singleton getInstance(int paramA, int paramB) {
      if (instance == null) {
        instance = new Singleton(paramA, paramB);
      }
      return instance;
    }
  }
  
  Singleton singleton = Singleton.getInstance(10, 50);
  ~~~

- 将参数放到另外一个全局变量中

  ~~~java
  public class Config {
    public static final int PARAM_A = 123;
    public static final int PARAM_B = 245;
  }
  
  public class Singleton {
    private static Singleton instance = null;
    private final int paramA;
    private final int paramB;
  
    private Singleton() {
      this.paramA = Config.PARAM_A;
      this.paramB = Config.PARAM_B;
    }
  
    public synchronized static Singleton getInstance() {
      if (instance == null) {
        instance = new Singleton();
      }
      return instance;
    }
  }
  ~~~



上面三个代码实现都是有相同问题的，就以第二种方式来说：

~~~java
Singleton singleton1 = Singleton.getInstance(10, 50);
Singleton singleton2 = Singleton.getInstance(20, 30);
~~~

获取到的singleton1和signleton2的paramA和paramB都是10和50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户。

### 代替方案

- 依赖注入

  ~~~java
  // 1. 老的使用方式
  public demofunction() {
    //...
    long id = IdGenerator.getInstance().getId();
    //...
  }
  
  // 2. 新的使用方式：依赖注入
  public demofunction(IdGenerator idGenerator) {
    long id = idGenerator.getId();
  }
  
  // 外部调用demofunction()的时候，传入idGenerator
  IdGenerator idGenerator = IdGenerator.getInsance();
  demofunction(idGenerator);
  ~~~

  这样可以解决单例隐藏类之间依赖关系的问题

- 工厂模式

- IOC容器



### 唯一性的作用范围

对象的唯一性的作用范围是**类加载器（Class Loader）**，而不是进程

### 如何实现线程唯一的单例？

我们通过一个HashMap来存储对象，其中key是线程ID，value是对象。这样我们就实现了线程唯一的单例。Java语言本身提供了ThreadLocal工具类，可以更加轻松地实现线程唯一单例，底层实现原理也是HashMap。

~~~java
public class IdGenerator {
  private AtomicLong id = new AtomicLong(0);

  private static final ConcurrentHashMap<Long, IdGenerator> instances
          = new ConcurrentHashMap<>();

  private IdGenerator() {}

  public static IdGenerator getInstance() {
    Long currentThreadId = Thread.currentThread().getId();
    instances.putIfAbsent(currentThreadId, new IdGenerator());
    return instances.get(currentThreadId);
  }

  public long getId() {
    return id.incrementAndGet();
  }
}
~~~

### 如何实现集群环境下的单例？

集群相当于多个进程构成的一个集合。

实现集群环境下的单例的大体思路为：

- 在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象。
- 使用完成之后还需要序列化，再存储回外部共享存储区。
- 为了保证数据一致性，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。



~~~java
public class IdGenerator {
  private AtomicLong id = new AtomicLong(0);
    
  private static IdGenerator instance;
  private static SharedObjectStorage storage = FileSharedObjectStorage(/*入参省略，比如文件地址*/);			//外部共享存储区
  private static DistributedLock lock = new DistributedLock();		//分布式锁
  
  private IdGenerator() {}

  public synchronized static IdGenerator getInstance() 
    if (instance == null) {
      lock.lock();
      instance = storage.load(IdGenerator.class);
    }
    return instance;
  }
  
  public synchroinzed void freeInstance() {
    storage.save(this, IdGeneator.class);
    instance = null; //释放对象
    lock.unlock();
  }
  
  public long getId() { 
    return id.incrementAndGet();
  }
}

// IdGenerator使用举例
IdGenerator idGeneator = IdGenerator.getInstance();
long id = idGenerator.getId();
IdGenerator.freeInstance();
~~~



### 如何实现一个多例模式？

多例模式就是，一个类只能创建N个对象。



~~~java
public class BackendServer {
  private long serverNo;
  private String serverAddress;
    
  private static final Map<Long, BackendServer> serverInstances = new HashMap<>();		//通过Map来存储这些对象，而不是一个单独的静态属性

  static {
    serverInstances.put(1L, new BackendServer(1L, "192.134.22.138:8080"));
    serverInstances.put(2L, new BackendServer(2L, "192.134.22.139:8080"));
    serverInstances.put(3L, new BackendServer(3L, "192.134.22.140:8080"));
  }

  private BackendServer(long serverNo, String serverAddress) {
    this.serverNo = serverNo;
    this.serverAddress = serverAddress;
  }

  //要获取对象时，要指定其唯一标识
  public BackendServer getInstance(long serverNo) {
    return serverInstances.get(serverNo);
  }
}
~~~



多例模式的相似性：

- 工厂模式
- 享元模式
- 枚举类型



## 工厂模式

工厂模式分为三种类型：**简单工厂**、**工厂方法**和**抽象工厂**。

工厂模式本质上就是封装了这样一个创建逻辑——根据分类方式，有选择地创建不同类型的对象。这样就解耦了对象的创建和使用。

### 简单工厂（Simple Factory）

我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象RuleConfig。

~~~java
public class RuleConfigSource {
  //读取ruleConfigFilePath指定路径的配置文件，然后返回内存对象RuleConfig
    
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
    
    //根据文件后缀选择解析器
    IRuleConfigParser parser = null;
    if ("json".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new JsonRuleConfigParser();
    } else if ("xml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new XmlRuleConfigParser();
    } else if ("yaml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new YamlRuleConfigParser();
    } else if ("properties".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new PropertiesRuleConfigParser();
    } else {
      throw new InvalidRuleConfigException(
             "Rule config file format is not supported: " + ruleConfigFilePath);
    }

    String configText = "";
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  }

  //获取文件后缀
  private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
  }
}

~~~

为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及parser创建的部分逻辑剥离出来，抽象成createParser()函数：

~~~java
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
    IRuleConfigParser parser = createParser(ruleConfigFileExtension);
    if (parser == null) {
      throw new InvalidRuleConfigException(
              "Rule config file format is not supported: " + ruleConfigFilePath);
    }

    String configText = "";
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  }

  private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
  }

 //将创建的逻辑封装到这个函数当中
  private IRuleConfigParser createParser(String configFormat) {
    IRuleConfigParser parser = null;
    if ("json".equalsIgnoreCase(configFormat)) {
      parser = new JsonRuleConfigParser();
    } else if ("xml".equalsIgnoreCase(configFormat)) {
      parser = new XmlRuleConfigParser();
    } else if ("yaml".equalsIgnoreCase(configFormat)) {
      parser = new YamlRuleConfigParser();
    } else if ("properties".equalsIgnoreCase(configFormat)) {
      parser = new PropertiesRuleConfigParser();
    }
    return parser;
  }
~~~

**为了让类的职责更加单一、代码更加清晰**，我们还可以进一步将createParser()函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。

~~~java
//将创建对象的逻辑进一步抽象为工具类，提供一个静态方法来创建对象
public class RuleConfigParserFactory {
    
  //静态方法
  public static IRuleConfigParser createParser(String configFormat) {
    IRuleConfigParser parser = null;
    //这里if-else结构可以用switch替换
    if ("json".equalsIgnoreCase(configFormat)) {
      parser = new JsonRuleConfigParser();
    } else if ("xml".equalsIgnoreCase(configFormat)) {
      parser = new XmlRuleConfigParser();
    } else if ("yaml".equalsIgnoreCase(configFormat)) {
      parser = new YamlRuleConfigParser();
    } else if ("properties".equalsIgnoreCase(configFormat)) {
      parser = new PropertiesRuleConfigParser();
    }
    return parser;
  }
}

public class RuleConfigSource {
  public RuleConfig load(String ruleConfigFilePath) {
      //...
    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);
      //...
  }
}
~~~

大部分工厂类的命名都是以「Factory」为后缀，而创建对象的方法一般以「create」为前缀。

**为了节省内存和对象创建的时间，我们可以将parser事先创建好缓存起来**。

~~~java
public class RuleConfigParserFactory {
  private static final Map<String, RuleConfigParser> cachedParsers = new HashMap<>();
	
  //缓存了这些要创建的对象，同时if-else结构巧妙地被替换为Map对象
  static {
    cachedParsers.put("json", new JsonRuleConfigParser());
    cachedParsers.put("xml", new XmlRuleConfigParser());
    cachedParsers.put("yaml", new YamlRuleConfigParser());
    cachedParsers.put("properties", new PropertiesRuleConfigParser());
  }

  public static IRuleConfigParser createParser(String configFormat) {
    if (configFormat == null || configFormat.isEmpty()) {
      return null;
      //返回null还是IllegalArgumentException全凭你自己说了算
    }
    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());
    return parser;
  }
}
~~~

至此

### 工厂方法（Factory Method）

工厂方法模式的典型代码实现：

~~~java
//工厂方法接口
public interface IRuleConfigParserFactory {
  IRuleConfigParser createParser();
}

public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {
  @Override
  public IRuleConfigParser createParser() {
    return new JsonRuleConfigParser();
  }
}

public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {
  @Override
  public IRuleConfigParser createParser() {
    return new XmlRuleConfigParser();
  }
}

public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {
  @Override
  public IRuleConfigParser createParser() {
    return new YamlRuleConfigParser();
  }
}

public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory {
  @Override
  public IRuleConfigParser createParser() {
    return new PropertiesRuleConfigParser();
  }
}

~~~

这样当我们新增一种parser的时候，只需要新增一个实现了`IRuleConfigParserFactory`接口的`Factory`具体类即可。所以，**工厂方法模式比起简单工厂模式更加符合开闭原则。**

但是，在工厂类的使用上有很大问题

~~~java
public class RuleConfigSource {
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);

    IRuleConfigParserFactory parserFactory = null;
    if ("json".equalsIgnoreCase(ruleConfigFileExtension)) {
      parserFactory = new JsonRuleConfigParserFactory();
    } else if ("xml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parserFactory = new XmlRuleConfigParserFactory();
    } else if ("yaml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parserFactory = new YamlRuleConfigParserFactory();
    } else if ("properties".equalsIgnoreCase(ruleConfigFileExtension)) {
      parserFactory = new PropertiesRuleConfigParserFactory();
    } else {
      throw new InvalidRuleConfigException("Rule config file format is not supported: " + ruleConfigFilePath);
    }
    IRuleConfigParser parser = parserFactory.createParser();

    String configText = "";
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  }

  private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
  }
}
~~~

工厂类对象的创建逻辑又耦合进了load()函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。

我们可以为工厂类再创建一个简单工厂，来解决这个问题，这里我们使用了缓存版本的工厂类。

~~~java
public class RuleConfigSource {
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);

    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);
    if (parserFactory == null) {
      throw new InvalidRuleConfigException("Rule config file format is not supported: " + ruleConfigFilePath);
    }
    IRuleConfigParser parser = parserFactory.createParser();

    String configText = "";
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  }

  private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
  }
}

public class RuleConfigParserFactoryMap { 
  private static final Map<String, IRuleConfigParserFactory> cachedFactories = new HashMap<>();

  static {
    cachedFactories.put("json", new JsonRuleConfigParserFactory());
    cachedFactories.put("xml", new XmlRuleConfigParserFactory());
    cachedFactories.put("yaml", new YamlRuleConfigParserFactory());
    cachedFactories.put("properties", new PropertiesRuleConfigParserFactory());
  }

  public static IRuleConfigParserFactory getParserFactory(String type) {
    if (type == null || type.isEmpty()) {
      return null;
    }
    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());
    return parserFactory;
  }
}
~~~

当我们需要添加新的规则配置解析器的时候，我们只需要创建新的parser类和parser factory类，并且在RuleConfigParserFactoryMap类中，将新的parser factory对象添加到cachedFactories中即可。基本上符合开闭原则。这样就避免了简单工厂类中大量的if-else逻辑判断。

**每个Factory类只是做简单的new操作，功能非常单薄**（只有一行代码），换句话说，创建逻辑很简单。故没必要设计成独立的类，**所以，在这个应用场景下，简单工厂比工厂方法更加合适。**

简单工厂的不同类型之间无需有相关性，而工厂方法却要求有，即继承同一个父类或者接口。



### 抽象工厂（Abstract Factory）

抽象工厂模式的应用场景比较特殊，了解即可。

如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule规则配置还是System系统配置）来分类，那就会对应下面这8个parser类。

~~~java
针对规则配置的解析器：基于接口IRuleConfigParser
JsonRuleConfigParser
XmlRuleConfigParser
YamlRuleConfigParser
PropertiesRuleConfigParser

针对系统配置的解析器：基于接口ISystemConfigParser
JsonSystemConfigParser
XmlSystemConfigParser
YamlSystemConfigParser
PropertiesSystemConfigParser
~~~

如果还是继续用工厂方法来实现的话，我们要针对每个parser都编写一个工厂类，也就是要编写8个工厂类。过多的类也会让系统难维护。这个问题该怎么解决呢？

定义一个接口`IConfigParserFactory`，负责创建多个不同类型的对象（`IRuleConfigParser`、`ISystemConfigParser`等），而不是只创建一种parser对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：

~~~java
public interface IConfigParserFactory {
  IRuleConfigParser createRuleParser();
  ISystemConfigParser createSystemParser();
  //此处可以扩展新的parser类型，比如IBizConfigParser
}

public class JsonConfigParserFactory implements IConfigParserFactory {
  @Override
  public IRuleConfigParser createRuleParser() {
    return new JsonRuleConfigParser();
  }

  @Override
  public ISystemConfigParser createSystemParser() {
    return new JsonSystemConfigParser();
  }
}

public class XmlConfigParserFactory implements IConfigParserFactory {
  @Override
  public IRuleConfigParser createRuleParser() {
    return new XmlRuleConfigParser();
  }

  @Override
  public ISystemConfigParser createSystemParser() {
    return new XmlSystemConfigParser();
  }
}

// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码
~~~

### Dependency Injection框架

DI容器的设计思路就是基于工厂模式的。它负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。

它的核心功能一般有三个：**配置解析**、**对象创建**和**对象生命周期管理**。

工厂类要创建哪个类对象是事先确定好的，并且是硬编码在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码是高度解耦的，DI容器事先并不知道应用会创建哪些对象。所以，我们需要通过配置，让应用告知DI容器要创建哪些对象。

~~~xml
<beans>
   <bean id="rateLimiter" class="com.xzg.RateLimiter">
      <constructor-arg ref="redisCounter"/>
   </bean>
 
   <bean id="redisCounter" class="com.xzg.redisCounter">
     <constructor-arg type="String" value="127.0.0.1">
     <constructor-arg type="int" value=1234>
   </bean>
</beans>
~~~

在DI容器中，所有类对象的创建都放到一个工厂类中，BeansFactory。它使用反射的特性来动态创建对象。



在Spring框架中，我们可以通过配置scope属性来决定所创建的对象是否为单例的：

- `scope=prototype`表示返回新创建的对象
- `scope=singleton`表示返回单例对象



除此之外，我们还可以配置对象是否支持懒加载。

- `lazy-init=true`，对象在真正被使用到的时候，比如：`BeansFactory.getBean(“userService”)`才被被创建；
- `lazy-init=false`，对象在应用启动的时候就事先创建好。

不仅如此，我们还可以配置对象的`init-method`和`destroy-method`方法，比如`init-method=loadProperties()`，`destroy-method=updateConfigFile()`。DI容器在创建好对象之后，会主动调用`init-method`属性指定的方法来初始化对象。在对象被最终销毁之前，DI容器会主动调用`destroy-method`属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。



现在我们来实现一个DI容器，其功能包括配置文件解析、根据配置文件通过“反射”语法来创建对象。

使用用例：

~~~java
<beans>
   <bean id="rateLimiter" class="com.xzg.RateLimiter">
      <constructor-arg ref="redisCounter"/>
   </bean>
 
   <bean id="redisCounter" class="com.xzg.redisCounter" scope="singleton" lazy-init="true">
     <constructor-arg type="String" value="127.0.0.1">
     <constructor-arg type="int" value=1234>
   </bean>
</bean
~~~

~~~java
public class Demo {
  public static void main(String[] args) {
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
            "beans.xml");
    RateLimiter rateLimiter = (RateLimiter) applicationContext.getBean("rateLimiter");
    rateLimiter.test();
    //...
  }
}
~~~



我们通过`ApplicationContext`和`ClassPathXmlApplicationContext`来提供执行入口

~~~java
ublic interface ApplicationContext {
  Object getBean(String beanId);			//根据beanID获取指定的Java对象
}

// ClassPathXmlApplicationContext负责组装BeansFactory和BeanConfigParser两个类
public class ClassPathXmlApplicationContext implements ApplicationContext {
  
  private BeansFactory beansFactory;
  private BeanConfigParser beanConfigParser;

  //configLocation——配置文件的路径
  public ClassPathXmlApplicationContext(String configLocation) {
    this.beansFactory = new BeansFactory();
    this.beanConfigParser = new XmlBeanConfigParser();
    loadBeanDefinitions(configLocation);
  }

  private void loadBeanDefinitions(String configLocation) {
    InputStream in = null;
    //从classpath中加载XML格式的配置文件
    try {
      in = this.getClass().getResourceAsStream("/" + configLocation);
      if (in == null) {
        throw new RuntimeException("Can not find config file: " + configLocation);
      }
        
      //通过BeanConfigParser解析为统一的BeanDefinition格式
      List<BeanDefinition> beanDefinitions = beanConfigParser.parse(in);
        
      //然后，BeansFactory根据BeanDefinition来创建对象。
      beansFactory.addBeanDefinitions(beanDefinitions);
    } finally {
      if (in != null) {
        try {
          in.close();
        } catch (IOException e) {
          // TODO: log error
        }
      }
    }
  }

  @Override
  public Object getBean(String beanId) {
    return beansFactory.getBean(beanId);
  }
}
~~~

配置文件解析主要包含BeanConfigParser接口和XmlBeanConfigParser实现类，负责将配置文件解析为BeanDefinition结构：

~~~java
public interface BeanConfigParser {
  List<BeanDefinition> parse(InputStream inputStream);
  List<BeanDefinition> parse(String configContent);
}

public class XmlBeanConfigParser implements BeanConfigParser {

  @Override
  public List<BeanDefinition> parse(InputStream inputStream) {
    String content = null;
    // TODO:...
    return parse(content);
  }

  @Override
  public List<BeanDefinition> parse(String configContent) {
    List<BeanDefinition> beanDefinitions = new ArrayList<>();
    // TODO:...
    return beanDefinitions;
  }

}

public class BeanDefinition {
  private String id;
  private String className;
  private List<ConstructorArg> constructorArgs = new ArrayList<>();
  private Scope scope = Scope.SINGLETON;
  private boolean lazyInit = false;
  // 省略必要的getter/setter/constructors
 
  public boolean isSingleton() {
    return scope.equals(Scope.SINGLETON);
  }


  public static enum Scope {
    SINGLETON,
    PROTOTYPE
  }
  
  public static class ConstructorArg {
    private boolean isRef;
    private Class type;
    private Object arg;
    // 省略必要的getter/setter/constructors
  }
}
~~~

BeansFactory根据从配置文件解析得到的BeanDefinition来创建对象。

~~~java
public class BeansFactory {
  private ConcurrentHashMap<String, Object> singletonObjects = new ConcurrentHashMap<>();
    
  private ConcurrentHashMap<String, BeanDefinition> beanDefinitions = new ConcurrentHashMap<>();

  public void addBeanDefinitions(List<BeanDefinition> beanDefinitionList) {
    for (BeanDefinition beanDefinition : beanDefinitionList) {
      this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);
    }

    for (BeanDefinition beanDefinition : beanDefinitionList) {
      if (beanDefinition.isLazyInit() == false && beanDefinition.isSingleton()) {
        createBean(beanDefinition);
      }
    }
  }

  public Object getBean(String beanId) {
    BeanDefinition beanDefinition = beanDefinitions.get(beanId);
    if (beanDefinition == null) {
      throw new NoSuchBeanDefinitionException("Bean is not defined: " + beanId);
    }
    return createBean(beanDefinition);
  }

  @VisibleForTesting
  protected Object createBean(BeanDefinition beanDefinition) {
    // 如果对象的scope属性是singleton，那对象创建之后会缓存在singletonObjects这样一个map中，下次再请求此对象的时候，直接从map中取出返回，不需要重新创建。
    if (beanDefinition.isSingleton() && singletonObjects.contains(beanDefinition.getId())) {
      return singletonObjects.get(beanDefinition.getId());
    }

    Object bean = null;
    try {
      //反射
      Class beanClass = Class.forName(beanDefinition.getClassName());
      List<BeanDefinition.ConstructorArg> args = beanDefinition.getConstructorArgs();
      if (args.isEmpty()) {
        bean = beanClass.newInstance();
      } else {
        Class[] argClasses = new Class[args.size()];
        Object[] argObjects = new Object[args.size()];
        for (int i = 0; i < args.size(); ++i) {
          BeanDefinition.ConstructorArg arg = args.get(i);
          if (!arg.getIsRef()) {
            argClasses[i] = arg.getType();
            argObjects[i] = arg.getArg();
          } else {
            BeanDefinition refBeanDefinition = beanDefinitions.get(arg.getArg());
            if (refBeanDefinition == null) {
              throw new NoSuchBeanDefinitionException("Bean is not defined: " + arg.getArg());
            }
            argClasses[i] = Class.forName(refBeanDefinition.getClassName());
            argObjects[i] = createBean(refBeanDefinition);
          }
        }
        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);
      }
    } catch (ClassNotFoundException | IllegalAccessException
            | InstantiationException | NoSuchMethodException | InvocationTargetException e) {
      throw new BeanCreationFailureException("", e);
    }

    if (bean != null && beanDefinition.isSingleton()) {
      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);
      return singletonObjects.get(beanDefinition.getId());
    }
    return bean;
  }
}

~~~

## 建造者模式

我们先来看一道设计面试题：定义一个资源池配置类ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个ResourcePoolConfig类。

![](assets/21f970b7c0d6b5afa6aa09ca14f55059.jpg)

~~~java
public class ResourcePoolConfig {
  private static final int DEFAULT_MAX_TOTAL = 8;
  private static final int DEFAULT_MAX_IDLE = 8;
  private static final int DEFAULT_MIN_IDLE = 0;

  private String name;
  private int maxTotal = DEFAULT_MAX_TOTAL;
  private int maxIdle = DEFAULT_MAX_IDLE;
  private int minIdle = DEFAULT_MIN_IDLE;

  public ResourcePoolConfig(String name, Integer maxTotal, Integer maxIdle, Integer minIdle) {
    if (StringUtils.isBlank(name)) {
      throw new IllegalArgumentException("name should not be empty.");
    }
    this.name = name;

    if (maxTotal != null) {
      if (maxTotal <= 0) {
        throw new IllegalArgumentException("maxTotal should be positive.");
      }
      this.maxTotal = maxTotal;
    }

    if (maxIdle != null) {
      if (maxIdle < 0) {
        throw new IllegalArgumentException("maxIdle should not be negative.");
      }
      this.maxIdle = maxIdle;
    }

    if (minIdle != null) {
      if (minIdle < 0) {
        throw new IllegalArgumentException("minIdle should not be negative.");
      }
      this.minIdle = minIdle;
    }
  }
  //...省略getter方法...
}
~~~

如果可配置项逐渐增多，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。

~~~java
// 参数太多，导致可读性差、参数可能传递错误
ResourcePoolConfig config = new ResourcePoolConfig("dbconnectionpool", 16, null, 8, null, false , true, 10, 20，false， true);
~~~

我们可以通过set()函数来给成员变量赋值，以替代冗长的构造函数。

~~~java
public class ResourcePoolConfig {
  private static final int DEFAULT_MAX_TOTAL = 8;
  private static final int DEFAULT_MAX_IDLE = 8;
  private static final int DEFAULT_MIN_IDLE = 0;

  private String name;
  private int maxTotal = DEFAULT_MAX_TOTAL;
  private int maxIdle = DEFAULT_MAX_IDLE;
  private int minIdle = DEFAULT_MIN_IDLE;
  
  public ResourcePoolConfig(String name) {
    if (StringUtils.isBlank(name)) {
      throw new IllegalArgumentException("name should not be empty.");
    }
    this.name = name;
  }

  public void setMaxTotal(int maxTotal) {
    if (maxTotal <= 0) {
      throw new IllegalArgumentException("maxTotal should be positive.");
    }
    this.maxTotal = maxTotal;
  }

  public void setMaxIdle(int maxIdle) {
    if (maxIdle < 0) {
      throw new IllegalArgumentException("maxIdle should not be negative.");
    }
    this.maxIdle = maxIdle;
  }

  public void setMinIdle(int minIdle) {
    if (minIdle < 0) {
      throw new IllegalArgumentException("minIdle should not be negative.");
    }
    this.minIdle = minIdle;
  }
  //...省略getter方法...
}

~~~

总结一下上述方案就是通过构造函数设置必填项，通过set()方法设置可选配置项。但是这仍有很多问题：

- 如果必填项增多，那么我们有面临参数列表过长的问题
- 无法处理配置项的依赖关系，比如，如果用户设置了maxTotal、maxIdle、minIdle其中一个，就必须显式地设置另外两个；
- 无法处理配置项的约束关系，比如，maxIdle和minIdle要小于等于maxTotal。
- 如果ResourcePoolConfig类对象是不可变对象，那么我们就不能在ResourcePoolConfig类中暴露set()方法。



上述问题都可以通过建造者模式来解决，具体思路是：

- 定义一个Builder类
- Builder类提供set方法，用于设置配置项
- 调用Builder的build方法，在build方法中集中做逻辑检查。
- 返回一个对象



~~~java
public class ResourcePoolConfig {
  private String name;
  private int maxTotal;
  private int maxIdle;
  private int minIdle;

  private ResourcePoolConfig(Builder builder) {
    this.name = builder.name;
    this.maxTotal = builder.maxTotal;
    this.maxIdle = builder.maxIdle;
    this.minIdle = builder.minIdle;
  }
  //...省略getter方法...

  //我们将Builder类设计成了ResourcePoolConfig的内部类。
  //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。
  public static class Builder {
    private static final int DEFAULT_MAX_TOTAL = 8;
    private static final int DEFAULT_MAX_IDLE = 8;
    private static final int DEFAULT_MIN_IDLE = 0;

    private String name;
    private int maxTotal = DEFAULT_MAX_TOTAL;
    private int maxIdle = DEFAULT_MAX_IDLE;
    private int minIdle = DEFAULT_MIN_IDLE;

    public ResourcePoolConfig build() {
      // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等
      if (StringUtils.isBlank(name)) {
        throw new IllegalArgumentException("...");
      }
      if (maxIdle > maxTotal) {
        throw new IllegalArgumentException("...");
      }
      if (minIdle > maxTotal || minIdle > maxIdle) {
        throw new IllegalArgumentException("...");
      }

      return new ResourcePoolConfig(this);
    }

    public Builder setName(String name) {
      if (StringUtils.isBlank(name)) {
        throw new IllegalArgumentException("...");
      }
      this.name = name;
      return this;
    }

    public Builder setMaxTotal(int maxTotal) {
      if (maxTotal <= 0) {
        throw new IllegalArgumentException("...");
      }
      this.maxTotal = maxTotal;
      return this;
    }

    public Builder setMaxIdle(int maxIdle) {
      if (maxIdle < 0) {
        throw new IllegalArgumentException("...");
      }
      this.maxIdle = maxIdle;
      return this;
    }

    public Builder setMinIdle(int minIdle) {
      if (minIdle < 0) {
        throw new IllegalArgumentException("...");
      }
      this.minIdle = minIdle;
      return this;
    }
  }
}

// 这段代码会抛出IllegalArgumentException，因为minIdle>maxIdle
ResourcePoolConfig config = new ResourcePoolConfig.Builder()
        .setName("dbconnectionpool")
        .setMaxTotal(16)
        .setMaxIdle(10)
        .setMinIdle(12)
        .build();
~~~




工厂模式与建造者模式的区别：工厂模式是用来创建**有选择地创建对象**。建造者模式是用来**创建一种类型**的复杂对象。

有一个经典的例子很好地解释了两者的区别：顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉（多个类型）。对于披萨（一个类型）来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。



## 原型模式

如果对象的创建成本比较大，而同一个类的不同对象的状态相似（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制的方式来创建新对象，以达到节省创建时间的目的。这就是**原型设计模式**（Prototype Design Pattern）

 **那何为“对象的创建成本比较大”？**：

- 对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值）
- 从RPC、网络、数据库、文件系统等非常慢速的IO中读取

对于大部分业务系统来说，给对象申请内存所花费的时间，是可以忽略不计的。不要为此做过度设计

下面我们通过一个来说明如何使用原型模式：

假设数据库中存储了大约10万条信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统A在启动的时候会加载这份数据到内存中，同时建立一个散列表索引（HashMap），为了方便快速地查找某个关键词对应的信息。还有另外一个系统B，专门用来分析搜索日志，定期地更新数据库中的数据。

![](assets/05233c28ddda51b81dfd946ffdef640e.jpg)

为了保证系统A中数据的实时性，系统A需要定期根据数据库中的数据，更新内存中的索引和数据。系统A可以在数据库中，获取时间戳大于当前版本时间的关键词信息即可

~~~java
public class Demo {
  //散列表
  private ConcurrentHashMap<String, SearchWord> currentKeywords = new ConcurrentHashMap<>();
    
  //当前版本时间
  private long lastUpdateTime = -1;

  public void refresh() {
    // 从数据库中取出更新时间 > lastUpdateTime的数据，放入到currentKeywords中
    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);
    long maxNewUpdatedTime = lastUpdateTime;
    
    
    for (SearchWord searchWord : toBeUpdatedSearchWords) {
      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {
        maxNewUpdatedTime = searchWord.getLastUpdateTime();
      }
      if (currentKeywords.containsKey(searchWord.getKeyword())) {
        currentKeywords.replace(searchWord.getKeyword(), searchWord);
      } else {
        currentKeywords.put(searchWord.getKeyword(), searchWord);
      }
    }
	//当前版本更新为时间戳最大的那个
    lastUpdateTime = maxNewUpdatedTime;
  }

  private List<SearchWord> getSearchWords(long lastUpdateTime) {
    // TODO: 从数据库中取出更新时间 > lastUpdateTime的数据
    return null; 
  }
}

~~~

现在我们有个需求，任何时刻，系统A中的所有数据都必须是同一个版本的，要么都是版本a，要么都是版本b，也就是说，所有符合条件的关键词信息都必须同时更新到内存中。如何实现现在这个需求呢？

我们把正在使用数据的版本定义为“服务版本”，当我们要更新内存中数据的时候，我们并不是直接在服务版本（假设是版本a数据）上更新，而是创建一个新版本b，然后在b上更新数据。等到更新完成之后，再将服务版本从版本a切换到版本b。这样既保证了数据一直可用，又避免了中间状态的存在。

~~~java
public class Demo {
  private HashMap<String, SearchWord> currentKeywords = new HashMap<>();

  public void refresh() {
    HashMap<String, SearchWord> newKeywords = new LinkedHashMap<>();

    // 从数据库中取出所有的数据，放入到newKeywords中
    List<SearchWord> toBeUpdatedSearchWords = getSearchWords();
    for (SearchWord searchWord : toBeUpdatedSearchWords) {
      newKeywords.put(searchWord.getKeyword(), searchWord);
    }
	
      
    //切换服务版本
    currentKeywords = newKeywords;
  }

  private List<SearchWord> getSearchWords() {
    // TODO: 从数据库中取出所有的数据
    return null;
  }
}

~~~

在上面的代码实现中，newKeywords构建的成本比较高。我们需要将这10万条数据从数据库中读出，然后计算哈希值，构建newKeywords。我们可以复制currentKeywords数据到newKeywords中，然后做增量更新。

~~~java
public class Demo {
  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();
  private long lastUpdateTime = -1;

  public void refresh() {
    // 原型模式就这么简单，复制已有对象的数据，然后做增量更新
    
    HashMap<String, SearchWord> newKeywords = (HashMap<String, SearchWord>) currentKeywords.clone();

    // 从数据库中取出更新时间 > lastUpdateTime的数据，放入到newKeywords中
    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);
    long maxNewUpdatedTime = lastUpdateTime;
    for (SearchWord searchWord : toBeUpdatedSearchWords) {
      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {
        maxNewUpdatedTime = searchWord.getLastUpdateTime();
      }
      if (newKeywords.containsKey(searchWord.getKeyword())) {
        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());
        oldSearchWord.setCount(searchWord.getCount());
        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());
      } else {
        newKeywords.put(searchWord.getKeyword(), searchWord);
      }
    }

    lastUpdateTime = maxNewUpdatedTime;
    currentKeywords = newKeywords;
  }

  private List<SearchWord> getSearchWords(long lastUpdateTime) {
    // TODO: 从数据库中取出更新时间 > lastUpdateTime的数据
    return null;
  }
~~~

事实上，这样做是无意义的。因为clone是浅复制，也就是说版本a和版本b是在共享同一份数据。在版本b上的更新会反应到版本a上，这实现不了我们之前提到的需求。

### 原型模式的实现方式：深复制和浅复制

我们以散列表来说明深复制和浅复制的区别

![](assets/f5ba85952b27a569687e2d44352216d2-1698079512016-5.jpg)

![](assets/74bceb7a0736957daaa4abeba6826182.jpg)

![](assets/b978d054ab3183b9e0ae461e6abac81b.jpg)

浅复制得到的对象跟原始对象一起共享数据，而深复制得到的是一份完完全全独立的对象。在Java语言中，Object类的clone()方法执行的就是浅复制。

如何实现深复制呢？有以下两种方法：

- 递归复制对象。这里递归的意思是，复制完对象后，如果对象为引用类型，那么继续对该对象复制；如果对象为基本类型，那么就停止复制。
- 先将对象序列化，然后再反序列化成新的对象



我们用深复制重新实现上述需求

递归复制对象

~~~java
public class Demo {
  // ...

  public void refresh() {
    // Deep copy
    HashMap<String, SearchWord> newKeywords = new HashMap<>();
    for (HashMap.Entry<String, SearchWord> e : currentKeywords.entrySet()) {
      //浅复制key
      SearchWord searchWord = e.getValue();
        
      //深复制value
      SearchWord newSearchWord = new SearchWord(
              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());
      
      newKeywords.put(e.getKey(), newSearchWord);
    }

	// ...
  }
  // ...
}
~~~

先将对象序列化

~~~java
public Object deepCopy(Object object) {
  ByteArrayOutputStream bo = new ByteArrayOutputStream();
  ObjectOutputStream oo = new ObjectOutputStream(bo);
  oo.writeObject(object);
  
  ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
  ObjectInputStream oi = new ObjectInputStream(bi);
  
  return oi.readObject();
}

~~~



显然，深复制都要比浅复制耗时、耗内存空间。我们可以采用惰性分配的思想，减少。先采用浅复制的方式创建newKeywords。对于需要更新的SearchWord对象，我们再使用深度复制的方式创建一份新的对象，替换newKeywords中的老对象。

~~~java
public class Demo {
  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();
  private long lastUpdateTime = -1;

  public void refresh() {
    // Shallow copy
    HashMap<String, SearchWord> newKeywords = (HashMap<String, SearchWord>) currentKeywords.clone();

    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中
    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);
    long maxNewUpdatedTime = lastUpdateTime;
    for (SearchWord searchWord : toBeUpdatedSearchWords) {
      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {
        maxNewUpdatedTime = searchWord.getLastUpdateTime();
      }
      if (newKeywords.containsKey(searchWord.getKeyword())) {
        newKeywords.remove(searchWord.getKeyword());
      }
        
      //深复制
      newKeywords.put(searchWord.getKeyword(), searchWord);
    }

    lastUpdateTime = maxNewUpdatedTime;
    currentKeywords = newKeywords;
  }

  private List<SearchWord> getSearchWords(long lastUpdateTime) {
    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据
    return null;
  }
}
~~~

