# 反射

[TOC]

## 概述

**反射可以在程序运行时发现并使用对象的类型信息**。它使我们摆脱了只能在编译时执行面向类型操作的限制，并且让我们能够编写一些非常强大的程序。

一般来说，你希望自己的代码尽可能少地知道对象的确切类型信息，而只和这类对象的通用表示（基类）打交道。这样的话，我们的代码就更易于编写、阅读和维护，并且设计也更易于实现、理解和更改。这是通过多态机制实现的。

但是有时候却需要使用确切的类型。可以通过向下转型来达到这一点，这是反射最基本的形式，在运行时检查了所有的类型转换是否正确。下面我们进一步介绍反射的使用。



## Class对象

Java使用**Class对象**执行反射，而Class对象包含了与类相关的信息。程序中的每个类都有一个Class对象，当编译一个新类时，都会生成一个Class对象（并被相应地存储在同名的.class文件中）。为了在运行时生成该类，Java虚拟机使用被称为**类加载器**（class loader）的子系统。

类加载器子系统有一个原始类加载器，它通常从本地磁盘加载所谓的可信类。此外我们由于特殊需要（例如通过网络来下载类）还可以添加额外的加载器。

Java程序在运行前并不会被完全加载，而是在必要时加载对应的部分。即首次使用该类（例如调用该类的静态成员或静态方法，构造方法也是静态的）时，才会触发这个类的加载。这与许多传统语言（C++）不同。这种动态加载能力使得Java可以支持很多反射行为。

类加载器首先检查是否加载了该类型的Class对象。如果没有，默认的类加载器会定位到具有该名称的.class文件。当该类的字节数据被加载时，它们会被验证，以确保没有被损坏，并且不包含恶意的Java代码。一旦该类型的Class对象加载到内存中，它就会用于创建该类型的所有对象。



### 如何获取到Class对象

可以通过Class类的静态方法`forName`来获取指定类的Class对象：

~~~java
try {
	Class class = Class.forName("cn.atsukoruo.list.Vector");
} catch(Exception e) {
    
}
~~~

注意`forName`的参数必须是全限定名，而且`forName`具有副作用，会执行被加载类的静态代码块。



如果你已经持有一个对象，那么可以通过`getClass`方法（基类Object中的方法）获取该对象的Class对象。注意：会获取到对象真正类型的Class，而不是当前类型的：

~~~java
Apple apple = new Apple();
Fruit fruit = apple;
System.out.println(apple.getClass().getName());		//Apple，而不是Fruit。
~~~



该可以通过**类字面量（class literal）**。这更简单也更安全，因为它会进行编译时检查（因此不必放在try块中）。另外它还消除了对forName()方法的调用，所以效率也更高。语法形式：类名.class

~~~java
Factory.class
~~~



### Class对象的方法

- getInterfaces
- getSuperclass
- newInstance。该方法被废弃，推荐使用Constructor.newInstance

