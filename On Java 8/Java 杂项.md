# Java 杂项

[TOC]

## 包管理

Java通过`package`机制解决了命名冲突的问题。包名的命名方法：**域名（唯一的）+ 相对路径名**。而且在项目中，**目录结构必须与包名对应**！





Javas使用`import`语句，可以将一个包下的类导入，这样在每次访问这些类时，无需再添加包名，例子：

~~~java
import java.util.Array;

Array array = new Array();
java.util.Array array = new java.util.Array();
~~~

可以使用通配符`*`来导入包下的所有类，例如`import java.util.*;`

所有的Java文件都自动导入一个特定的库——`java.lang`

Java还支持静态导入`import static`将一个类的可访问的静态字段或方法导入，这样可以在每次访问该类的静态字段或静态方法时，无需再添加类名了。例子：

~~~java
import static java.lang.System.*;

out.println("Hello World");
System.out.println("Hello World");
~~~





此外，Java 消除了所谓的**“前向引用”（forward referencing）**问题。假如某个类存在于当前被调用的源代码文件中。你只要使用这个类就可以了，哪怕这个类稍后才会在文件中定义。



### 类名冲突

当不同库中的类名冲突时，解决方案则是

- 利用import关键字告知 Java 编译器你想要使用哪个类。
- 使用**全限定名**，即在类名前添加包名。

~~~java
import java.sql.Date
    
Date date = new Date();							//date是java.sql.Date类型
java.util.Date date2 = new java.util.Date();	  //date2是java.util.Date类型
~~~



### 编译单元

一个Java源代码文件就是一个编译单元。在编译单元内，至多有一个public类，而且它必须与文件同名。如果该编译单元中有其他类，则在**该包之外**是看不到它们的，这是因为它们不是public的，而只是该public类的**支持类（support class）**。

### 默认包

如果在编译单元中不使用`package`语句，那么就在当前包下创建一个**默认包**或**未命名包**。

只有在同一个包下的默认包中的各个类可以相互访问！对于不同包中或者同一个包中但已经打包（使用package语句）的类都不可以访问默认包下的类。

### 条件编译

Java缺少的一个功能是C语言的条件编译。它在C语言中最常用于解决跨平台问题：根据目标平台来编译代码的不同部分。Java旨在自动跨平台，因此不需要这样的功能。但条件编译还有其他用途。一个很常见的用法是调试代码。调试功能在开发过程中启用，而在发布的产品里禁用。你可以通过更改导入的package，将程序中使用的代码从调试版本更改为生产版本，从而实现这个功能。



### 模块

> 这里我们不详细介绍它，因为如果你正在编写自己的库，并且它足够大和复杂的话，你可能需要投入精力学习使用模块系统来实现它。而对于除了大型第三方库之外的任何项目，在不使用模块的情况下构建就可以了。

JDK 9最终引入了模块（module），它解决了这两个问题：

- 在JDK 9之前，Java程序会依赖整个Java库。这意味着即使最简单的程序也带有大量从未使用过的库代码。
- 尽管包访问似乎提供了有效的隐藏，但还是可以使用反射（参见第19章）来规避它。年来，一些Java程序员一直在访问部分底层的Java库组件，而这些库组件从未打算要被外部直接使用。这些程序员的代码与隐藏的组件耦合了起来。这意味着Java库设计者无法在不破坏用户代码的情况下修改这些组件，这极大地阻碍了对Java库的改进。

现在，当使用库组件时，你会仅仅获得该组件的模块及其依赖项，不会有不使用的模块。如果想继续使用隐藏的库组件，你必须启用“逃生舱口”（escape hatch），它清楚地表明你这样做违反了库的预期设计，因此将来如果因为更新这个隐藏组件（甚至完全删除）而引起任何破坏，都要由你自己来负责。



## 类加载

当编译一个.java文件时，**文件中的每个类都会有一个输出文件**。输出文件的名字就是其在.java文件中对应的类的名字，但扩展名为.class。

可以使用jar归档器将一个包下的`.class`文件打包并压缩成一个**Java档案文件（JAR）**。Java解释器负责查找、加载和解释jar文件。

解释器在加载类时，它找到环境变量`CLASSPATH`。`CLASSPATH`包含了一个或多个目录，这些目录是查找.class文件的根目录。从根目录开始，解释器把包名里的每个点替换成斜杠生成一个相对路径名，从而定位到`.class`文件。

注意：在CLASSPATH下必须写jar包的文件名，而不仅仅是jar包的路径。

~~~bash
CLASSPATH = ".;D:\JAVA\LIB;C:\flavors\grape.jar"
~~~



只有在**首次**需要某个类的代码的时候才会加载该文件。例如：

- 子类被加载，那么父类会一同加载
- 调用类的静态方法，或访问静态字段
- 实际上构造器也是静态方法，因此在创建对象时也会加载

## 编程风格

- 命名采用驼峰式命名法（Camel-Case）。对于类名，首字母要大写；对于方法名或对象名，首字母小写
- 对于final基本类型，使用全大写+下划线的命名法（C语言风格）



## JVM

### GC的工作原理

JVM分配内存采用与栈指针类似的策略——使用堆指针。Java的“堆指针”只是简单地向前移动到尚未分配的区域，因此它的效率实际上与C++的栈分配差不多。当然记录分配情况的簿记工作也会有一些额外的、可忽略不计的开销。

在回收垃圾的同时，垃圾收集器还会“压缩”堆中的所有对象，这样就可以很方便地将“堆指针”移到靠近传送带起点的位置，从而尽量避免缺页错误（page fault）。

垃圾收集的工作方式

- 引用计数（reference counting）是一种简单但速度很慢的垃圾收集技术。每个对象都包含一个引用计数器，并且每次该对象被引用时，引用计数都会增加。每次引用离开作用域或设置为null时，引用计数都会减少。垃圾收集器会遍历整个对象列表，当找到引用计数为零的对象时，就释放该对象占用的存储空间。如果对象彼此之间循环引用，就算变成了垃圾，它们的引用计数可能仍不是零。定位这种自引用的对象组需要垃圾收集器做大量额外的工作。这种方法没在任何JVM中实现过。



### JIT & AOT

